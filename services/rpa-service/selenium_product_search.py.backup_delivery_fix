#!/usr/bin/env python3
"""
–£—Ç–∏–ª–∏—Ç—ã –¥–ª—è Selenium-–ø–æ–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
–°–æ–¥–µ—Ä–∂–∏—Ç –∫–ª–∞—Å—Å—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ç–æ–≤–∞—Ä–∞—Ö –∏–∑ –≤–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü
"""

import asyncio
import logging
import re
from typing import List, Dict, Any, Optional
from selenium.webdriver.common.by import By

logger = logging.getLogger(__name__)

def is_xpath_selector(selector: str) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä XPath
    
    XPath –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å:
    - // (–Ω–∞–ø—Ä–∏–º–µ—Ä: //div[@class='test'])
    - (// (–Ω–∞–ø—Ä–∏–º–µ—Ä: (//ul//li)[1])
    - .// (–Ω–∞–ø—Ä–∏–º–µ—Ä: .//span)
    
    Returns:
        True –µ—Å–ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä —è–≤–ª—è–µ—Ç—Å—è XPath, False –µ—Å–ª–∏ CSS
    """
    if not selector:
        return False
    return selector.startswith('//') or selector.startswith('(//') or selector.startswith('.//')

def get_search_results_key(driver, container_selector: str, item_selector: str, url_selector: str) -> Optional[str]:
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –∫–ª—é—á –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
    
    –ö–ª—é—á = "count:{–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_—Ç–æ–≤–∞—Ä–æ–≤}|url:{url_–ø–µ—Ä–≤–æ–≥–æ_—Ç–æ–≤–∞—Ä–∞}"
    
    Args:
        driver: Selenium WebDriver
        container_selector: –°–µ–ª–µ–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
        item_selector: –°–µ–ª–µ–∫—Ç–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–∞ —Ç–æ–≤–∞—Ä–∞
        url_selector: –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è URL —Ç–æ–≤–∞—Ä–∞
        
    Returns:
        –°—Ç—Ä–æ–∫–∞-–∫–ª—é—á –∏–ª–∏ None –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω/–ø—É—Å—Ç
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –ø–µ—Ä–µ–¥–∞–Ω—ã
        if not container_selector or not item_selector or not url_selector:
            logger.debug(f"üîë Missing selectors: container={container_selector}, item={item_selector}, url={url_selector}")
            return None
        
        # –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        if is_xpath_selector(container_selector):
            container_elements = driver.find_elements(By.XPATH, container_selector)
        else:
            container_elements = driver.find_elements(By.CSS_SELECTOR, container_selector)
        
        if not container_elements:
            logger.debug(f"üîë Container not found: {container_selector}")
            return None
        
        container = container_elements[0]
        
        # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Ç–æ–≤–∞—Ä—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        if is_xpath_selector(item_selector):
            items = container.find_elements(By.XPATH, item_selector)
        else:
            items = container.find_elements(By.CSS_SELECTOR, item_selector)
        
        if not items:
            logger.debug(f"üîë No items found in container")
            return None
        
        item_count = len(items)
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º URL –ø–µ—Ä–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
        first_item = items[0]
        first_url = "no-url"
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç –∏–ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä
            if '@' in url_selector:
                # –≠—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç - –±–µ—Ä–µ–º href –Ω–∞–ø—Ä—è–º—É—é
                first_url = first_item.get_attribute('href') or "no-url"
            else:
                # –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç —Å URL
                if is_xpath_selector(url_selector):
                    url_element = first_item.find_element(By.XPATH, url_selector)
                else:
                    url_element = first_item.find_element(By.CSS_SELECTOR, url_selector)
                first_url = url_element.get_attribute('href') or "no-url"
            
            # –£–∫–æ—Ä–∞—á–∏–≤–∞–µ–º URL –¥–ª—è –∫–ª—é—á–∞ (–±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ path)
            if first_url and first_url != "no-url":
                from urllib.parse import urlparse
                parsed = urlparse(first_url)
                first_url = parsed.path or first_url
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Could not extract URL from first item: {e}")
            first_url = "no-url"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–ª—é—á
        key = f"count:{item_count}|url:{first_url}"
        logger.debug(f"üîë Search results key: {key}")
        return key
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Error calculating search results key: {e}")
        return None

def extract_numeric_value(driver, selector: str) -> Optional[float]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    
    Args:
        driver: Selenium WebDriver
        selector: CSS –∏–ª–∏ XPath —Å–µ–ª–µ–∫—Ç–æ—Ä
        
    Returns:
        –ß–∏—Å–ª–æ –∏–ª–∏ 0.0 –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å (–¥–ª—è —Å–ª—É—á–∞–µ–≤ —Ç–∏–ø–∞ "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ")
    """
    try:
        # –®–∞–≥ 1: –ù–∞–π—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç
        if selector.startswith('//') or selector.startswith('.//') or selector.startswith('(//'):
            element = driver.find_element(By.XPATH, selector)
        else:
            element = driver.find_element(By.CSS_SELECTOR, selector)
        
        # –®–∞–≥ 2: –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç
        text = element.text.strip()
        logger.info(f"üî¢ extract_numeric_value: –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç = '{text}' (selector: {selector[:50]}...)")
        
        if not text:
            logger.warning(f"‚ö†Ô∏è extract_numeric_value: –≠–ª–µ–º–µ–Ω—Ç –Ω–∞–π–¥–µ–Ω, –Ω–æ —Ç–µ–∫—Å—Ç –ø—É—Å—Ç–æ–π")
            return 0.0
        
        # –®–∞–≥ 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" –∏–ª–∏ –ø–æ–¥–æ–±–Ω—ã–µ —Ñ—Ä–∞–∑—ã
        if any(word in text.lower() for word in ['–±–µ—Å–ø–ª–∞—Ç–Ω', 'free', '–¥–∞—Ä–æ–º']):
            logger.info(f"‚úÖ extract_numeric_value: –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ '–ë–µ—Å–ø–ª–∞—Ç–Ω–æ' -> 0.0")
            return 0.0
        
        # –®–∞–≥ 4: –ò–∑–≤–ª–µ—á—å –ü–û–°–õ–ï–î–ù–ï–ï —á–∏—Å–ª–æ –ø–µ—Ä–µ–¥ —Å–∏–º–≤–æ–ª–æ–º –≤–∞–ª—é—Ç—ã ‚ÇΩ/—Ä—É–±
        # –ü–∞—Ç—Ç–µ—Ä–Ω: –∏—â–µ–º –≤—Å–µ —á–∏—Å–ª–∞ –ø–µ—Ä–µ–¥ ‚ÇΩ, –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ
        currency_pattern = r'[‚ÇΩ—Ä—É–±]'
        currency_match = re.search(currency_pattern, text, re.IGNORECASE)
        
        if currency_match:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –î–û –ø–µ—Ä–≤–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –≤–∞–ª—é—Ç—ã
            text_before_currency = text[:currency_match.start()]
            logger.debug(f"üìù –¢–µ–∫—Å—Ç –¥–æ –≤–∞–ª—é—Ç—ã: '{text_before_currency}'")
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –í–°–ï —á–∏—Å–ª–∞ (–º–æ–≥—É—Ç –±—ã—Ç—å —Å –ø—Ä–æ–±–µ–ª–∞–º–∏ —Ç–∏–ø–∞ "1 500")
            numbers = re.findall(r'\d+', text_before_currency)
            
            if numbers:
                # –ë–µ—Ä–µ–º –ü–û–°–õ–ï–î–ù–ï–ï —á–∏—Å–ª–æ –ø–µ—Ä–µ–¥ –≤–∞–ª—é—Ç–æ–π
                last_number_str = numbers[-1]
                logger.debug(f"üîç –í—Å–µ —á–∏—Å–ª–∞ –¥–æ –≤–∞–ª—é—Ç—ã: {numbers}, –≤—ã–±—Ä–∞–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ: '{last_number_str}'")
                
                try:
                    extracted_value = float(last_number_str)
                    logger.info(f"‚úÖ extract_numeric_value: –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value}")
                    return extracted_value
                except ValueError:
                    logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å '{last_number_str}' –≤ —á–∏—Å–ª–æ")
                    return 0.0
            else:
                logger.warning(f"‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ —á–∏—Å–µ–ª –ø–µ—Ä–µ–¥ —Å–∏–º–≤–æ–ª–æ–º –≤–∞–ª—é—Ç—ã")
        
        # –®–∞–≥ 5: Fallback - –ø—Ä–æ–±—É–µ–º —Å—Ç–∞—Ä—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –µ—Å–ª–∏ –Ω–µ—Ç —Å–∏–º–≤–æ–ª–∞ –≤–∞–ª—é—Ç—ã
        patterns = [
            r'–æ—Ç\s+(\d+[\s,]?\d*)',         # "–æ—Ç 1500"
            r'(\d+[\s,]?\d*)\s*$',          # —á–∏—Å–ª–æ –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏
            r'^(\d+[\s,]?\d*)',              # —á–∏—Å–ª–æ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
            r'(\d+[\s,]?\d*)',               # –ª—é–±–æ–µ —á–∏—Å–ª–æ –≤ —Å—Ç—Ä–æ–∫–µ
        ]
        
        for i, pattern in enumerate(patterns, 1):
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                number_str = match.group(1)
                # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∑–∞–ø—è—Ç—ã–µ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ —Ç—ã—Å—è—á)
                number_str = number_str.replace(' ', '').replace(',', '')
                
                try:
                    extracted_value = float(number_str)
                    logger.info(f"‚úÖ extract_numeric_value (fallback): –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value} (–ø–∞—Ç—Ç–µ—Ä–Ω {i})")
                    return extracted_value
                except ValueError:
                    logger.debug(f"‚ö†Ô∏è Pattern {i} matched but failed to parse: '{number_str}'")
                    continue
        
        # –®–∞–≥ 6: –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback - –ø—Ä–æ—Å—Ç–æ –∏—â–µ–º –ª—é–±—ã–µ —Ü–∏—Ñ—Ä—ã
        logger.warning(f"‚ö†Ô∏è extract_numeric_value: –í—Å–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã failed, –ø–æ—Å–ª–µ–¥–Ω–∏–π fallback")
        cleaned = re.sub(r'[^\d]', '', text)
        
        if cleaned:
            try:
                extracted_value = float(cleaned)
                logger.info(f"‚úÖ extract_numeric_value (last fallback): –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value}")
                return extracted_value
            except ValueError:
                logger.error(f"‚ùå extract_numeric_value: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å '{cleaned}' –≤ —á–∏—Å–ª–æ")
                return 0.0
        else:
            logger.warning(f"‚ö†Ô∏è extract_numeric_value: –ù–µ –Ω–∞–π–¥–µ–Ω–æ —á–∏—Å–µ–ª –≤ —Ç–µ–∫—Å—Ç–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0.0")
            return 0.0
        
    except Exception as e:
        logger.error(f"‚ùå extract_numeric_value: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ '{selector}': {e}")
        import traceback
        logger.debug(traceback.format_exc())
        return 0.0

class ProductSearchResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∞"""
    def __init__(self, order_item_id: int, product_name: str, search_query: str = None, 
                 found_name: str = None, price: float = 0.0, unit: str = '—à—Ç', 
                 quantity: float = 1.0, available_stock: int = 1, product_url: str = None,
                 lsd_name: str = None, search_position: int = 1, 
                 min_order_amount: float = 0.0, delivery_cost: float = 0.0, delivery_cost_model: dict = None,
                 is_alternative: bool = False, alternative_for: str = None):
        self.order_item_id = order_item_id
        self.product_name = product_name
        self.search_query = search_query or product_name
        self.found_name = found_name or product_name
        self.price = price
        self.unit = unit
        self.quantity = quantity
        self.available_stock = available_stock
        self.product_url = product_url
        self.lsd_name = lsd_name
        self.search_position = search_position
        self.min_order_amount = min_order_amount
        self.delivery_cost = delivery_cost
        self.delivery_cost_model = delivery_cost_model
        self.found_items = []
        self.search_successful = False
        self.error_message = None
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
        self.is_alternative = is_alternative
        self.alternative_for = alternative_for


async def extract_item_data_selenium_enhanced(
    item_element,
    search_config: dict,
    lsd_config,
    page_level_data: Dict[str, float] = None
) -> Optional[Dict[str, Any]]:
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–≤–∞—Ä–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –Ω–æ–≤—ã—Ö —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –°–∞–º–æ–∫–∞—Ç–∞
    """
    
    try:
        logger.info(f"üîç extract_item_data_selenium_enhanced: Starting extraction")
        logger.info(f"üîç search_config keys: {list(search_config.keys()) if search_config else 'None'}")
        
        # === –ü–†–û–í–ï–†–ö–ê –î–û–°–¢–£–ü–ù–û–°–¢–ò (–†–ê–ù–ù–Ø–Ø –§–ò–õ–¨–¢–†–ê–¶–ò–Ø) ===
        availability_text_required = search_config.get('availability_text_required')
        availability_text_selector = search_config.get('availability_text_selector')
        
        if availability_text_required:
            is_available = check_item_availability(
                item_element, 
                availability_text_required,
                availability_text_selector
            )
            
            if not is_available:
                logger.info("‚ö†Ô∏è Item not available - skipping extraction")
                return None  # –ù–µ –∏–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
        
        item_data = {
            'lsd_name': lsd_config.name,
            'lsd_display_name': lsd_config.display_name
        }
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –ù–ê–ó–í–ê–ù–ò–Ø ===
        name_selector = search_config.get('name_selector')
        logger.info(f"üîç name_selector from config: {name_selector}")
        if name_selector:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º enhanced –≤–µ—Ä—Å–∏—é –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ textContent –∏ innerHTML
            item_data['name'] = extract_text_safe_enhanced(item_element, name_selector, "name")
            logger.info(f"üîç extracted name result: {item_data.get('name')}")
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –¶–ï–ù–´ ===
        price_extracted = False
        price_selector = search_config.get('price_selector')
        
        if not price_selector:
            logger.error(f"‚ùå price_selector not found in search_config for {item_data.get('lsd_name')}")
        else:
            # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é - –ø—Ä–æ–±—É–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
            selectors = [s.strip() for s in price_selector.split(',')]
            
            for selector in selectors:
                try:
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ (XPath –∏–ª–∏ CSS)
                    if selector.startswith('//') or selector.startswith('.//') or selector.startswith('//'):
                        price_element = item_element.find_element(By.XPATH, selector)
                    else:
                        price_element = item_element.find_element(By.CSS_SELECTOR, selector)
                    price_text = price_element.text.strip()
                    if price_text:
                        item_data['price'] = parse_price_enhanced(price_text, search_config)
                        item_data['price_text'] = price_text
                        price_extracted = True
                        logger.debug(f"‚úÖ Extracted price with selector '{selector}': {item_data['price']}‚ÇΩ")
                        break  # –ù–∞–π–¥–µ–Ω–∞ —Ü–µ–Ω–∞ - –ø—Ä–µ–∫—Ä–∞—â–∞–µ–º –ø–æ–∏—Å–∫
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Selector '{selector}' failed: {e}")
                    continue  # –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Å–µ–ª–µ–∫—Ç–æ—Ä
            
            if not price_extracted:
                logger.warning(f"‚ö†Ô∏è Could not extract price with any selector from: {price_selector}")
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –ï–î–ò–ù–ò–¶–´ –ò–ó–ú–ï–†–ï–ù–ò–Ø ===
        # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ (—Å–∞–º—ã–π –Ω–∞–¥—ë–∂–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫)
        unit_extracted = False
        
        if item_data.get('name'):
            name_quantity, name_unit = extract_unit_and_quantity_from_name(item_data['name'])
            if name_quantity and name_unit:
                item_data['quantity'] = name_quantity
                item_data['unit'] = name_unit
                unit_extracted = True
                logger.info(f"‚úÖ Extracted from product name (priority): {name_quantity}{name_unit}")
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ü—Ä–æ–±—É–µ–º unit_selector (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –¥–∞–ª–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞)
        if not unit_extracted:
            unit_selector = search_config.get('unit_selector')
            if unit_selector:
                unit_text = extract_text_safe_enhanced(item_element, unit_selector, "unit")
                if unit_text:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑ —Ç–µ–∫—Å—Ç–∞
                    item_data['unit'] = extract_unit_from_text(unit_text)
                    logger.info(f"‚úÖ Extracted unit from selector: '{unit_text}' -> '{item_data['unit']}'")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —Ç–µ–∫—Å—Ç–µ "–∑–∞" - —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç "—Ü–µ–Ω–∞ –∑–∞ –µ–¥–∏–Ω–∏—Ü—É"
                    # –ù–∞–ø—Ä–∏–º–µ—Ä: "–∑–∞ 100 –≥", "–∑–∞ 1 –∫–≥" - —ç—Ç–æ –ù–ï quantity —Ç–æ–≤–∞—Ä–∞, –∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ü–µ–Ω–µ!
                    is_price_per_unit = '–∑–∞' in unit_text.lower()
                    
                    if not is_price_per_unit:
                        # –ï—Å–ª–∏ –ù–ï–¢ "–∑–∞" - –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å quantity (–Ω–∞–ø—Ä–∏–º–µ—Ä "300 –≥")
                        import re
                        match = re.match(r'([\d.,]+)\s*([–∞-—è–ê-–Øa-zA-Z]+)', unit_text.strip())
                        if match:
                            quantity_str = match.group(1).replace(',', '.')
                            try:
                                item_data['quantity'] = float(quantity_str)
                                unit_extracted = True
                                logger.info(f"‚úÖ Parsed quantity from selector: {item_data['quantity']}")
                            except ValueError:
                                logger.info(f"‚ö†Ô∏è Could not parse quantity from '{unit_text}'")
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 3: Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç data_selectors
        if not unit_extracted:
            data_selectors = search_config.get('data_selectors', {})
            unit_selector_old = data_selectors.get('unit')
            if unit_selector_old:
                unit_text = extract_text_safe_enhanced(item_element, unit_selector_old, "unit")
                if unit_text:
                    item_data['unit'] = extract_unit_from_text(unit_text)
                    logger.info(f"‚úÖ Extracted unit from data_selectors: '{unit_text}' -> '{item_data['unit']}'")
                    
                    # –¢–µ –∂–µ –ø—Ä–∞–≤–∏–ª–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ quantity
                    import re
                    match = re.match(r'([\d.,]+)\s*([–∞-—è–ê-–Øa-zA-Z]+)', unit_text.strip())
                    if match:
                        quantity_str = match.group(1).replace(',', '.')
                        try:
                            item_data['quantity'] = float(quantity_str)
                            unit_extracted = True
                        except ValueError:
                            pass  # –ù–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º unit_extracted
        
        # DEFAULT: –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–≤–ª–µ–∫–ª–∏ - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        if not unit_extracted:
            item_data['unit'] = '—à—Ç'
            item_data['quantity'] = 1.0
            logger.info(f"‚ö†Ô∏è Using default: quantity=1.0, unit='—à—Ç'")
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï URL –¢–û–í–ê–†–ê ===
        url_selector = search_config.get('url_selector')
        result_item_selector = search_config.get('result_item_selector', '')
        
        if url_selector:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞—é—Ç –ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∏–ª–∏ url_selector –≤—Ö–æ–¥–∏—Ç –≤ result_item_selector
                url_is_same_element = (
                    url_selector == result_item_selector or 
                    (result_item_selector and url_selector in result_item_selector)
                )
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤ url_selector —Å–∏–º–≤–æ–ª @ (—ç—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç)
                is_xpath_attribute = '@' in url_selector
                
                if url_is_same_element or is_xpath_attribute:
                    # –ï—Å–ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –æ–¥–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –ò–õ–ò —ç—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç, –±–µ—Ä–µ–º URL –∏–∑ item_element
                    logger.debug(f"üîß url_selector '{url_selector}' - getting href directly from item_element")
                    relative_url = item_element.get_attribute('href')
                else:
                    # –û–±—ã—á–Ω—ã–π —Å–ª—É—á–∞–π: –∏—â–µ–º URL –≤–Ω—É—Ç—Ä–∏ —ç–ª–µ–º–µ–Ω—Ç–∞
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ (XPath –∏–ª–∏ CSS)
                    if url_selector.startswith('//') or url_selector.startswith('.//') or url_selector.startswith('//'):
                        url_element = item_element.find_element(By.XPATH, url_selector)
                    else:
                        url_element = item_element.find_element(By.CSS_SELECTOR, url_selector)
                    relative_url = url_element.get_attribute('href')
                    
                if relative_url:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–æ–ª–Ω—ã–π URL –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    if relative_url.startswith('/'):
                        base_url = search_config.get('base_url', lsd_config.base_url)
                        item_data['url'] = f"{base_url}{relative_url}"
                    else:
                        item_data['url'] = relative_url
                    logger.debug(f"‚úÖ Extracted URL: {item_data['url']}")
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è Could not extract URL: {e}")
        
        
        # === –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï –î–ê–ù–ù–´–• –£–†–û–í–ù–Ø –°–¢–†–ê–ù–ò–¶–´ ===
        # –≠—Ç–∏ –¥–∞–Ω–Ω—ã–µ –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –∞ –Ω–µ –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–∞ —Ç–æ–≤–∞—Ä–∞
        if page_level_data:
            # –°—Ç–∞—Ä—ã–µ –ø–æ–ª—è (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
            item_data['min_order_amount'] = page_level_data.get('min_order_amount', 0.0)
            item_data['delivery_cost'] = page_level_data.get('delivery_cost', 0.0)
            # –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å
            item_data['delivery_cost_model'] = page_level_data.get('delivery_cost_model')
            logger.debug(f"‚úÖ Using page-level data: min_order={item_data['min_order_amount']}, delivery={item_data['delivery_cost']}, model={bool(item_data['delivery_cost_model'])}")
        else:
            # Fallback: –µ—Å–ª–∏ page_level_data –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ã, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            item_data['min_order_amount'] = 0.0
            item_data['delivery_cost'] = 0.0
            item_data['delivery_cost_model'] = None
            logger.debug("‚ö†Ô∏è page_level_data not provided, using defaults")
        
        # === –ü–†–û–í–ï–†–ö–ê –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–• –î–ê–ù–ù–´–• ===
        logger.info(f"üîç Final item_data before validation: {item_data}")
        logger.info(f"üîç price_extracted: {price_extracted}")
        
        if not item_data.get('name'):
            logger.debug("‚ö†Ô∏è Item missing name - skipping")
            return None
            
        if not price_extracted or not item_data.get('price'):
            logger.debug("‚ö†Ô∏è Item missing valid price - skipping")
            return None
            
        logger.debug(f"‚úÖ Item extraction successful: {item_data.get('name')} - {item_data.get('price')}")
        return item_data
        
    except Exception as e:
        logger.error(f"‚ùå Error extracting item data: {e}")
        return None

def extract_unit_and_quantity_from_name(product_name: str) -> tuple:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
    
    –ü—Ä–∏–º–µ—Ä—ã:
    - "–ú–æ–ª–æ–∫–æ –í–æ–ª–æ–≥–æ–¥—Å–∫–æ–µ 3,2%, 200–º–ª" -> (200.0, "–º–ª")
    - "–•–ª–µ–± –ë–æ—Ä–æ–¥–∏–Ω—Å–∫–∏–π, 400–≥" -> (400.0, "–≥")
    - "–Ø–π—Ü–∞ –°0, 10—à—Ç" -> (10.0, "—à—Ç")
    - "–°—ã—Ä –†–æ—Å—Å–∏–π—Å–∫–∏–π" -> (None, None)
    
    Returns:
        tuple: (quantity, unit) –∏–ª–∏ (None, None) –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    """
    if not product_name:
        return None, None
    
    # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞ —á–∏—Å–ª–∞ + –µ–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è
    # –ò—â–µ–º: —á–∏—Å–ª–æ (–º–æ–∂–µ—Ç –±—ã—Ç—å —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ —Ç–æ—á–∫–æ–π), –ø—Ä–æ–±–µ–ª –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω, –µ–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è
    # –í–∞–∂–Ω–æ: \s* –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ–±–µ–ª –º–µ–∂–¥—É —á–∏—Å–ª–æ–º –∏ –µ–¥–∏–Ω–∏—Ü–µ–π (200–º–ª –∏–ª–∏ 200 –º–ª)
    pattern = r'(\d+[,.]?\d*)\s*(–º–ª|–ª|–≥|–∫–≥|—à—Ç|—É–ø)(?=[^–∞-—èa-z]|$)'
    
    match = re.search(pattern, product_name.lower())
    if match:
        quantity_str = match.group(1).replace(',', '.')
        unit_str = match.group(2)
        try:
            quantity = float(quantity_str)
            return quantity, unit_str
        except ValueError:
            return None, None
    
    return None, None


def extract_unit_from_text(text: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–æ–ª—å–∫–æ –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑ —Ç–µ–∫—Å—Ç–∞
    
    –ü—Ä–∏–º–µ—Ä—ã:
    - "–∑–∞ 1 —à—Ç" -> "—à—Ç"
    - "–∑–∞ 1 –∫–≥" -> "–∫–≥"
    - "300 –≥" -> "–≥"
    - "1 –ª" -> "–ª"
    - "975 –º–ª" -> "–º–ª"
    - "975 ml" -> "–º–ª"  (–ª–∞—Ç–∏–Ω–∏—Ü–∞)
    - "—à—Ç" -> "—à—Ç"
    """
    if not text:
        return '—à—Ç'
    
    text_lower = text.lower().strip()
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∞—Ç–∏–Ω—Å–∫–∏–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è (ml, l, kg, g)
    # –í–∞–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –î–û –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏—Ö, —á—Ç–æ–±—ã "ml" –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª—Å—è –∫–∞–∫ "–ª"
    latin_units = {
        'ml': '–º–ª',
        'l': '–ª',
        'kg': '–∫–≥',
        'g': '–≥',
    }
    
    # –ò—â–µ–º –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞ (—Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏)
    for latin_unit, cyrillic_unit in latin_units.items():
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º regex –¥–ª—è –ø–æ–∏—Å–∫–∞ unit –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–ª–æ–≤–∞
        pattern = r'\b' + re.escape(latin_unit) + r'\b'
        if re.search(pattern, text_lower):
            logger.debug(f"üî§ Found latin unit '{latin_unit}' -> '{cyrillic_unit}' in text: '{text}'")
            return cyrillic_unit
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–ª–∏–Ω–µ (–æ—Ç –±–æ–ª—å—à–µ–≥–æ –∫ –º–µ–Ω—å—à–µ–º—É), —á—Ç–æ–±—ã "–º–ª" –ø—Ä–æ–≤–µ—Ä—è–ª–æ—Å—å —Ä–∞–Ω—å—à–µ "–ª"
    cyrillic_units = ['–º–ª', '–∫–≥', '—à—Ç', '—É–ø', '–ª', '–≥']
    
    for unit in cyrillic_units:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º regex –¥–ª—è –ø–æ–∏—Å–∫–∞ unit –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–ª–æ–≤–∞
        pattern = r'\b' + re.escape(unit) + r'\b'
        if re.search(pattern, text_lower):
            return unit
    
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "—à—Ç"
    logger.debug(f"‚ö†Ô∏è No unit found in text '{text}', using default '—à—Ç'")
    return '—à—Ç'


def check_item_availability(item_element, availability_text_required: Optional[List[str]], availability_text_selector: Optional[str] = None) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ç–æ–≤–∞—Ä–∞ –ø–æ –Ω–∞–ª–∏—á–∏—é —Ç—Ä–µ–±—É–µ–º–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤ –∫–∞—Ä—Ç–æ—á–∫–µ
    
    Args:
        item_element: WebElement –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞
        availability_text_required: –°–ø–∏—Å–æ–∫ —Ñ—Ä–∞–∑ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–ª–∏ None
        availability_text_selector: –°–µ–ª–µ–∫—Ç–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ç–µ–∫—Å—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω - –∏—â–µ–º —Ç–µ–∫—Å—Ç —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ä—Ç–æ—á–∫–∏.
            –ï—Å–ª–∏ None - –∏—â–µ–º –≤–æ –≤—Å–µ–π –∫–∞—Ä—Ç–æ—á–∫–µ —Ç–æ–≤–∞—Ä–∞.
        
    Returns:
        bool: True –µ—Å–ª–∏ —Ç–æ–≤–∞—Ä –¥–æ—Å—Ç—É–ø–µ–Ω (—Ñ—Ä–∞–∑–∞ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è),
              False –µ—Å–ª–∏ —Ç–æ–≤–∞—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–Ω–∏ –æ–¥–Ω–∞ —Ñ—Ä–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞)
    """
    # –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è - —Å—á–∏—Ç–∞–µ–º —Ç–æ–≤–∞—Ä –¥–æ—Å—Ç—É–ø–Ω—ã–º
    if not availability_text_required or len(availability_text_required) == 0:
        logger.debug("‚ÑπÔ∏è No availability check required - item considered available")
        return True
    
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        if availability_text_selector:
            # –†–ï–ñ–ò–ú 1: –ò—â–µ–º —Ç–µ–∫—Å—Ç —Ç–æ–ª—å–∫–æ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ
            logger.debug(f"üîç Using availability_text_selector: '{availability_text_selector}'")
            try:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ (XPath –∏–ª–∏ CSS)
                if availability_text_selector.startswith('//') or availability_text_selector.startswith('.//') or availability_text_selector.startswith('(//') :
                    target_element = item_element.find_element(By.XPATH, availability_text_selector)
                else:
                    target_element = item_element.find_element(By.CSS_SELECTOR, availability_text_selector)
                
                item_text = target_element.text.strip()
                logger.debug(f"üìç Found target element, text: '{item_text}'")
            except Exception as selector_error:
                # –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω - —Ç–æ–≤–∞—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                logger.debug(f"‚ö†Ô∏è availability_text_selector element not found: {selector_error}")
                logger.info(f"‚ùå Availability element not found - item NOT available")
                return False
        else:
            # –†–ï–ñ–ò–ú 2: –ò—â–µ–º —Ç–µ–∫—Å—Ç –≤–æ –≤—Å–µ–π –∫–∞—Ä—Ç–æ—á–∫–µ —Ç–æ–≤–∞—Ä–∞
            item_text = item_element.text
            logger.debug("üîç Using full card text (no selector specified)")
        
        if not item_text:
            logger.debug("‚ö†Ô∏è Item element has no text content")
            return False
        
        # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        item_text_lower = item_text.lower()
        
        # –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ –ø—Ä–æ–≤–µ—Ä–∫–∏
        logger.debug(f"üîç Checking availability for item")
        logger.debug(f"üìù Item text (first 100 chars): '{item_text[:100]}...'")
        logger.debug(f"üéØ Required phrases: {availability_text_required}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é —Ñ—Ä–∞–∑—É
        for phrase in availability_text_required:
            if not phrase:
                continue
                
            phrase_lower = phrase.lower()
            
            if phrase_lower in item_text_lower:
                # –ù–∞—à–ª–∏ —Ñ—Ä–∞–∑—É - —Ç–æ–≤–∞—Ä –¥–æ—Å—Ç—É–ø–µ–Ω
                logger.info(f"‚úÖ Found phrase: '{phrase}' - item available")
                return True
        
        # –ù–∏ –æ–¥–Ω–∞ —Ñ—Ä–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ - —Ç–æ–≤–∞—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        logger.info(f"‚ùå No required phrases found - item NOT available")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Error checking item availability: {e}")
        # –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å—á–∏—Ç–∞–µ–º —Ç–æ–≤–∞—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º (–±–µ–∑–æ–ø–∞—Å–Ω–µ–µ)
        return False


def extract_text_safe(element, selector: str, field_name: str) -> Optional[str]:
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π XPath –∏ CSS"""
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
        if selector.startswith('//') or selector.startswith('.//') or selector.startswith('(//'):
            found_element = element.find_element(By.XPATH, selector)
        else:
            found_element = element.find_element(By.CSS_SELECTOR, selector)
        
        text = found_element.text.strip()
        return text if text else None
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Could not extract {field_name} with selector '{selector}': {e}")
        return None

def extract_text_safe_enhanced(element, selector: str, field_name: str) -> Optional[str]:
    """
    –£–ª—É—á—à–µ–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å–∫—Ä—ã—Ç—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ XPath/CSS —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç textContent –¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (–ü—è—Ç—ë—Ä–æ—á–∫–∞)
    """
    try:
        logger.info(f"üîç extract_text_safe_enhanced called: field={field_name}, selector='{selector}'")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
        if selector.startswith('//') or selector.startswith('.//') or selector.startswith('(//'):
            found_element = element.find_element(By.XPATH, selector)
            logger.info(f"üîç Using XPath selector for {field_name}")
        else:
            found_element = element.find_element(By.CSS_SELECTOR, selector)
            logger.info(f"üîç Using CSS selector for {field_name}")
        
        # –ü—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ –æ–±—ã—á–Ω—ã–π text
        text = found_element.text.strip()
        if text:
            logger.debug(f"‚úÖ Extracted {field_name} via .text: '{text}'")
            return text
        
        # –ï—Å–ª–∏ text –ø—É—Å—Ç–æ–π, –ø—Ä–æ–±—É–µ–º textContent (–¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
        text_content = found_element.get_attribute('textContent')
        if text_content:
            text_content = text_content.strip()
            logger.debug(f"‚úÖ Extracted {field_name} via textContent: '{text_content}'")
            return text_content
        
        # –ü—Ä–æ–±—É–µ–º innerHTML –∏ –æ—á–∏—â–∞–µ–º –æ—Ç HTML —Ç–µ–≥–æ–≤
        innerHTML = found_element.get_attribute('innerHTML')
        if innerHTML:
            import re
            # –£–¥–∞–ª—è–µ–º HTML —Ç–µ–≥–∏
            clean_text = re.sub(r'<[^>]+>', '', innerHTML).strip()
            if clean_text:
                logger.debug(f"‚úÖ Extracted {field_name} via innerHTML (cleaned): '{clean_text}'")
                return clean_text
        
        logger.debug(f"‚ö†Ô∏è Element found but no text content for {field_name} with selector '{selector}'")
        return None
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Could not extract {field_name} with selector '{selector}': {e}")
        return None

def parse_price_enhanced(price_text: str, search_config: dict) -> float:
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω—ã —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π regex –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    """
    try:
        # –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å regex –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        price_regex = search_config.get('price_regex')
        if price_regex:
            match = re.search(price_regex, price_text)
            if match:
                price_str = match.group(1)
                # –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∑–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É
                price_str = price_str.replace(' ', '').replace(',', '.')
                return float(price_str)
        
        # Fallback: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥
        # –£–±–∏—Ä–∞–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä, —Ç–æ—á–µ–∫ –∏ –∑–∞–ø—è—Ç—ã—Ö
        cleaned = re.sub(r'[^\d.,]', '', price_text)
        # –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É
        cleaned = cleaned.replace(',', '.')
        return float(cleaned)
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Error parsing price '{price_text}': {e}")
        return 0.0

def parse_delivery_info(text: str) -> float:
    """
    –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —á–∏—Å–ª–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Ç–µ–∫—Å—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏ –∏–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–∞–∫–∞–∑–∞
    –ü—Ä–∏–º–µ—Ä—ã:
    - "5‚Äì15 –º–∏–Ω, 109 ‚ÇΩ" -> 109.0
    - "–ó–∞–∫–∞–∑ –æ—Ç 100 ‚ÇΩ" -> 100.0
    - "–î–æ—Å—Ç–∞–≤–∫–∞ 250" -> 250.0
    - "–û—Ç 500 —Ä—É–±" -> 500.0
    """
    try:
        if not text:
            return 0.0
        
        # –ò—â–µ–º —á–∏—Å–ª–æ —Å –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ —Ç—ã—Å—è—á –∏ –≤–∞–ª—é—Ç–æ–π
        # –ü–∞—Ç—Ç–µ—Ä–Ω: —á–∏—Å–ª–æ (—Å –ø—Ä–æ–±–µ–ª–∞–º–∏ –∏–ª–∏ –∑–∞–ø—è—Ç—ã–º–∏) + –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –≤–∞–ª—é—Ç–∞
        patterns = [
            r'(\d+[\s,]?\d*)\s*[‚ÇΩ—Ä—É–±]',  # "109 ‚ÇΩ", "1 000 —Ä—É–±"
            r'–æ—Ç\s+(\d+[\s,]?\d*)',      # "–æ—Ç 100", "–æ—Ç 1,500"
            r'(\d+[\s,]?\d*)\s*$',       # –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ –≤ –∫–æ–Ω—Ü–µ
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                number_str = match.group(1)
                # –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∑–∞–ø—è—Ç—ã–µ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ —Ç—ã—Å—è—á)
                number_str = number_str.replace(' ', '').replace(',', '')
                return float(number_str)
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–∞—Ç—Ç–µ—Ä–Ω, –ø—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç–æ –∏–∑–≤–ª–µ—á—å –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ
        numbers = re.findall(r'\d+', text)
        if numbers:
            return float(numbers[-1])  # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ (–æ–±—ã—á–Ω–æ —ç—Ç–æ —Ü–µ–Ω–∞)
        
        return 0.0
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Error parsing delivery info '{text}': {e}")
        return 0.0

async def wait_for_any_selector(driver, selectors: List[str], timeout_ms: int = 5000) -> bool:
    """
    –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è –ª—é–±–æ–≥–æ –∏–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    
    Args:
        driver: Selenium WebDriver
        selectors: –°–ø–∏—Å–æ–∫ CSS –∏–ª–∏ XPath —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è
        timeout_ms: –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5000)
    
    Returns:
        bool: True –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å–µ–ª–µ–∫—Ç–æ—Ä –ø–æ—è–≤–∏–ª—Å—è, False –ø—Ä–∏ —Ç–∞–π–º–∞—É—Ç–µ
    """
    if not selectors:
        logger.warning("‚ö†Ô∏è wait_for_any_selector: Empty selectors list")
        return False
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º null/None —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
    valid_selectors = [s for s in selectors if s and s != 'null']
    if not valid_selectors:
        logger.warning("‚ö†Ô∏è wait_for_any_selector: No valid selectors after filtering")
        return False
    
    timeout_sec = timeout_ms / 1000
    poll_interval = 0.1  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 100ms
    elapsed = 0
    
    logger.info(f"‚è≥ Waiting for any of {len(valid_selectors)} selector(s) to appear (timeout: {timeout_sec}s)...")
    logger.debug(f"üìã Selectors: {valid_selectors[:3]}..." if len(valid_selectors) > 3 else f"üìã Selectors: {valid_selectors}")
    
    try:
        while elapsed < timeout_sec:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä
            for idx, selector in enumerate(valid_selectors, 1):
                try:
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ (XPath –∏–ª–∏ CSS)
                    if is_xpath_selector(selector):
                        elements = driver.find_elements(By.XPATH, selector)
                    else:
                        elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –Ω–∞–π–¥–µ–Ω –ò –≤–∏–¥–∏–º
                    if elements and elements[0].is_displayed():
                        logger.info(f"‚úÖ Selector [{idx}] found after {elapsed:.1f}s: '{selector[:50]}...'")
                        return True
                        
                except Exception as e:
                    # –°–µ–ª–µ–∫—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É
                    logger.debug(f"‚ö†Ô∏è Selector [{idx}] not found yet: {e}")
                    continue
            
            # –ù–µ –Ω–∞—à–ª–∏ –Ω–∏ –æ–¥–∏–Ω —Å–µ–ª–µ–∫—Ç–æ—Ä - –∂–¥–µ–º
            await asyncio.sleep(poll_interval)
            elapsed += poll_interval
        
        # –¢–∞–π–º–∞—É—Ç - –Ω–∏ –æ–¥–∏–Ω —Å–µ–ª–µ–∫—Ç–æ—Ä –Ω–µ –ø–æ—è–≤–∏–ª—Å—è
        logger.warning(f"‚è±Ô∏è Timeout after {timeout_sec}s: none of {len(valid_selectors)} selector(s) appeared")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Error in wait_for_any_selector: {e}")
        import traceback
        logger.debug(traceback.format_exc())
        return False

async def execute_trigger_action(driver, action_config: dict, telegram_id: int = None) -> bool:
    """
    –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ trigger –¥–µ–π—Å—Ç–≤–∏—è
    
    Args:
        driver: Selenium WebDriver
        action_config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–µ–π—Å—Ç–≤–∏—è {"action": "click", "selector": "...", "wait_after": 500}
        telegram_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∑–∞–º–µ–Ω—ã –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤
    
    Returns:
        bool: True –µ—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
    """
    try:
        action_type = action_config.get('action', 'click')
        wait_after = action_config.get('wait_after', 500) / 1000  # –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
        
        # === NAVIGATE –∏ WAIT –Ω–µ —Ç—Ä–µ–±—É—é—Ç —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ ===
        if action_type == 'navigate':
            url = action_config.get('url')
            if not url:
                logger.error(f"‚ùå No URL in navigate action")
                return False
            
            logger.info(f"üåê Navigating to: {url}")
            driver.get(url)
            logger.info(f"‚úÖ Successfully navigated to: {url}")
            
            # –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            await asyncio.sleep(wait_after)
            return True
        
        if action_type == 'wait':
            logger.info(f"‚è≥ Waiting {wait_after}s...")
            await asyncio.sleep(wait_after)
            return True
        
        if action_type == 'wait_for':
            # –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
            selectors = action_config.get('selectors')
            if not selectors:
                logger.error(f"‚ùå No selectors in wait_for action")
                return False
            
            timeout_ms = action_config.get('timeout', 5000)
            logger.info(f"‚è≥ Waiting for selector(s) to appear (timeout: {timeout_ms}ms)")
            
            wait_success = await wait_for_any_selector(driver, selectors, timeout_ms)
            
            if not wait_success:
                logger.error(f"‚ùå wait_for timeout: selectors did not appear")
                return False
            
            logger.info(f"‚úÖ Selector(s) appeared successfully")
            await asyncio.sleep(wait_after)
            return True
        
        # === –î–õ–Ø –û–°–¢–ê–õ–¨–ù–´–• –î–ï–ô–°–¢–í–ò–ô –ù–£–ñ–ù–´ –°–ï–õ–ï–ö–¢–û–†–´ ===
        # –ü–û–î–î–ï–†–ñ–ö–ê –ú–ê–°–°–ò–í–ê –°–ï–õ–ï–ö–¢–û–†–û–í (fallback)
        selectors = action_config.get('selectors')
        if not selectors:
            # Fallback –Ω–∞ –æ–¥–∏–Ω–æ—á–Ω—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä
            single_selector = action_config.get('selector')
            if single_selector:
                selectors = [single_selector]
            else:
                logger.error(f"‚ùå No selector(s) in action: {action_config}")
                return False
        
        logger.info(f"üîò Executing action: {action_type} with {len(selectors)} selector(s)")
        
        # FALLBACK –õ–û–ì–ò–ö–ê: –ø—Ä–æ–±—É–µ–º –∫–∞–∂–¥—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä
        action_success = False
        last_error = None
        
        for idx, selector in enumerate(selectors, 1):
            logger.info(f"üîç Trying selector [{idx}/{len(selectors)}]: '{selector[:80]}...'")
            
            try:
                # –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —Ç–∏–ø—É
                if action_type == 'click':
                    if selector.startswith('//'):
                        element = driver.find_element(By.XPATH, selector)
                    else:
                        element = driver.find_element(By.CSS_SELECTOR, selector)
                    element.click()
                    logger.info(f"‚úÖ Clicked with selector [{idx}]")
                    action_success = True
                    break
                    
                elif action_type == 'hover':
                    from selenium.webdriver.common.action_chains import ActionChains
                    # –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π URL –ø–µ—Ä–µ–¥ hover
                    logger.info(f"üåê Current URL before hover: {driver.current_url}")
                    if selector.startswith('//'):
                        element = driver.find_element(By.XPATH, selector)
                    else:
                        element = driver.find_element(By.CSS_SELECTOR, selector)
                    ActionChains(driver).move_to_element(element).perform()
                    logger.info(f"‚úÖ Hovered with selector [{idx}]")
                    action_success = True
                    break
                    
                elif action_type == 'type':
                    # –í–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤
                    text_template = action_config.get('text', '')
                    if not text_template:
                        logger.error(f"‚ùå No text in type action")
                        return False
                    
                    # –ó–∞–º–µ–Ω—è–µ–º –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ unified_rpa_helpers)
                    from unified_rpa_helpers import (
                        get_user_phone_number_internal,
                        get_user_address_internal,
                        get_user_zipcode_internal,
                        get_user_address_wo_zipcode_internal
                    )
                    
                    final_text = text_template
                    
                    # –ó–∞–º–µ–Ω–∞ {phone_without_7}
                    if '{phone_without_7}' in final_text and telegram_id:
                        phone = await get_user_phone_number_internal(telegram_id)
                        if phone:
                            clean_phone = phone.replace('+7', '').replace('+', '')
                            final_text = final_text.replace('{phone_without_7}', clean_phone)
                            logger.info(f"üìû Replaced {{phone_without_7}}")
                    
                    # –ó–∞–º–µ–Ω–∞ {phone}
                    if '{phone}' in final_text and telegram_id:
                        phone = await get_user_phone_number_internal(telegram_id)
                        if phone:
                            final_text = final_text.replace('{phone}', phone)
                            logger.info(f"üìû Replaced {{phone}}")
                    
                    # –ó–∞–º–µ–Ω–∞ {address}
                    if '{address}' in final_text and telegram_id:
                        address = await get_user_address_internal(telegram_id)
                        if address:
                            final_text = final_text.replace('{address}', address)
                            logger.info(f"üè† Replaced {{address}}")
                    
                    # –ó–∞–º–µ–Ω–∞ {zipcode}
                    if '{zipcode}' in final_text and telegram_id:
                        zipcode = await get_user_zipcode_internal(telegram_id)
                        if zipcode:
                            final_text = final_text.replace('{zipcode}', zipcode)
                            logger.info(f"üìÆ Replaced {{zipcode}}")
                    
                    # –ó–∞–º–µ–Ω–∞ {address_wo_zipcode}
                    if '{address_wo_zipcode}' in final_text and telegram_id:
                        address_wo_zipcode = await get_user_address_wo_zipcode_internal(telegram_id)
                        if address_wo_zipcode:
                            final_text = final_text.replace('{address_wo_zipcode}', address_wo_zipcode)
                            logger.info(f"üè† Replaced {{address_wo_zipcode}}")
                    
                    # –í–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç
                    if selector.startswith('//'):
                        element = driver.find_element(By.XPATH, selector)
                    else:
                        element = driver.find_element(By.CSS_SELECTOR, selector)
                    element.clear()
                    element.send_keys(final_text)
                    logger.info(f"‚úÖ Typed text with selector [{idx}]")
                    action_success = True
                    break
                    
                else:
                    logger.error(f"‚ùå Unknown action type: {action_type}")
                    return False
                    
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è Selector [{idx}] failed: {e}")
                last_error = e
                continue  # –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Å–µ–ª–µ–∫—Ç–æ—Ä
        
        # –ï—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω —Å–µ–ª–µ–∫—Ç–æ—Ä –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
        if not action_success:
            logger.error(f"‚ùå All {len(selectors)} selector(s) failed. Last error: {last_error}")
            return False
        
        # –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
        await asyncio.sleep(wait_after)
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error executing trigger action: {e}")
        import traceback
        logger.debug(traceback.format_exc())
        return False

async def extract_delivery_ranges(driver, delivery_config: dict, telegram_id: int = None) -> tuple[List[Dict[str, Any]], Optional[float], bool]:
    """
    –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ –¥–æ—Å—Ç–∞–≤–∫–∏ –∏ min_order_amount –∏–∑ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
    
    Args:
        driver: Selenium WebDriver
        delivery_config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è delivery_ranges –∏–∑ search_config
        telegram_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∑–∞–º–µ–Ω—ã –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤ –≤ trigger actions
    
    Returns:
        tuple: (–°–ø–∏—Å–æ–∫ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤, min_order_amount –∏–ª–∏ None, is_delivery_available)
               is_delivery_available: True –µ—Å–ª–∏ –¥–æ—Å—Ç–∞–≤–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞, False –µ—Å–ª–∏ –Ω–µ—Ç
    """
    ranges_data = []
    min_order_amount = None
    
    # === –í–ê–õ–ò–î–ê–¶–ò–Ø –ö–û–ù–§–ò–ì–ê (Defence in Depth) ===
    if not delivery_config:
        logger.warning("‚ö†Ô∏è delivery_config is empty, returning empty ranges")
        return ranges_data, min_order_amount
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ enabled —Ñ–ª–∞–≥–∞ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞)
    if not delivery_config.get('enabled', False):
        logger.warning("‚ö†Ô∏è delivery_ranges.enabled is False, returning empty ranges")
        return ranges_data, min_order_amount
    
    logger.debug(f"üîß extract_delivery_ranges called with config keys: {list(delivery_config.keys())}")
    logger.debug(f"üîß enabled: {delivery_config.get('enabled', 'NOT SET')}")
    
    try:
        # –®–∞–≥ 1: –í—ã–ø–æ–ª–Ω–∏—Ç—å trigger (–æ—Ç–∫—Ä—ã—Ç—å –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ)
        trigger_config = delivery_config.get('trigger', {})
        
        # –ù–û–í–´–ô –§–û–†–ú–ê–¢: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–∞—Å—Å–∏–≤–∞ actions (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è)
        actions = trigger_config.get('actions')
        
        if actions:
            # === –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö actions ===
            logger.info(f"üéØ Sequential trigger mode: {len(actions)} action(s) to execute")
            
            previous_action_success = None  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ action
            
            for idx, action_config in enumerate(actions, 1):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä skip_if_previous_success
                should_skip = (
                    action_config.get('skip_if_previous_success', False) and 
                    previous_action_success is True
                )
                
                if should_skip:
                    action_name = action_config.get('action', 'unknown')
                    comment = action_config.get('comment', '')
                    logger.info(f"‚è≠Ô∏è [{idx}/{len(actions)}] Skipping action '{action_name}' (previous action was successful)")
                    if comment:
                        logger.info(f"   Comment: {comment}")
                    # –°—á–∏—Ç–∞–µ–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–π action —É—Å–ø–µ—à–Ω—ã–º –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
                    previous_action_success = True
                    continue
                
                logger.info(f"üîò [{idx}/{len(actions)}] Executing action: {action_config.get('action', 'unknown')}")
                
                success = await execute_trigger_action(driver, action_config, telegram_id)
                previous_action_success = success  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ action
                
                if not success:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º optional —Ñ–ª–∞–≥
                    is_optional = action_config.get('optional', False)
                    if is_optional:
                        logger.warning(f"‚ö†Ô∏è [{idx}/{len(actions)}] Action failed but marked as optional, continuing...")
                        previous_action_success = False  # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ failed –¥–ª—è skip_if_previous_success
                        continue
                    else:
                        logger.error(f"‚ùå Action [{idx}] failed, stopping trigger sequence")
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                        from datetime import datetime
                        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                        log_file = f"/Users/ss/GenAI/korzinka/logs/page_dump_{timestamp}.html"
                        try:
                            with open(log_file, 'w', encoding='utf-8') as f:
                                f.write(driver.page_source)
                            logger.warning(f"‚ö†Ô∏è Page HTML saved to: {log_file}")
                        except:
                            pass
                        return ranges_data, min_order_amount
                
                logger.info(f"‚úÖ [{idx}/{len(actions)}] Action completed successfully")
            
            logger.info(f"üéâ All {len(actions)} trigger actions completed successfully")
            
        else:
            # === –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê: –û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å selector/selectors ===
            trigger_action = trigger_config.get('action', 'click')
            
            # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–∞—Å—Å–∏–≤–∞ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ (fallback) –∏ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
            trigger_selectors = trigger_config.get('selectors')
            if not trigger_selectors:
                # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç —Å –æ–¥–Ω–∏–º —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–º
                single_selector = trigger_config.get('selector')
                if single_selector:
                    trigger_selectors = [single_selector]
                else:
                    logger.error("‚ùå No trigger selector(s) in delivery_ranges config")
                    return ranges_data, min_order_amount
            
            wait_after = trigger_config.get('wait_after', 500) / 1000  # –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
            
            logger.info(f"üîò Fallback trigger mode: {trigger_action} with {len(trigger_selectors)} selector(s)")
            
            # –ü—Ä–æ–±—É–µ–º –∫–∞–∂–¥—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä –ø–æ –æ—á–µ—Ä–µ–¥–∏ (FALLBACK –ª–æ–≥–∏–∫–∞)
            trigger_found = False
            last_error = None
            
            for idx, trigger_selector in enumerate(trigger_selectors, 1):
                logger.info(f"üîç Trying selector [{idx}/{len(trigger_selectors)}]: '{trigger_selector}'")
                
                try:
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ trigger
                    if trigger_action == 'click':
                        if trigger_selector.startswith('//'):
                            trigger_element = driver.find_element(By.XPATH, trigger_selector)
                        else:
                            trigger_element = driver.find_element(By.CSS_SELECTOR, trigger_selector)
                        trigger_element.click()
                        logger.info(f"‚úÖ Trigger clicked successfully with selector [{idx}]")
                        trigger_found = True
                        break
                        
                    elif trigger_action == 'hover':
                        from selenium.webdriver.common.action_chains import ActionChains
                        if trigger_selector.startswith('//'):
                            trigger_element = driver.find_element(By.XPATH, trigger_selector)
                        else:
                            trigger_element = driver.find_element(By.CSS_SELECTOR, trigger_selector)
                        ActionChains(driver).move_to_element(trigger_element).perform()
                        logger.info(f"‚úÖ Trigger hovered successfully with selector [{idx}]")
                        trigger_found = True
                        break
                        
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Selector [{idx}] failed: {e}")
                    last_error = e
                    continue
            
            # –ï—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω —Å–µ–ª–µ–∫—Ç–æ—Ä –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
            if not trigger_found:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                from datetime import datetime
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                log_file = f"/Users/ss/GenAI/korzinka/logs/page_dump_{timestamp}.html"
                
                try:
                    html_content = driver.page_source
                    with open(log_file, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                    logger.warning(f"‚ö†Ô∏è None of {len(trigger_selectors)} trigger selector(s) found. Page HTML saved to: {log_file}")
                    logger.warning(f"‚ö†Ô∏è Current URL: {driver.current_url}")
                    logger.warning(f"‚ö†Ô∏è Tried selectors: {trigger_selectors}")
                except Exception as save_error:
                    logger.error(f"‚ùå Failed to save page HTML: {save_error}")
                
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
                return ranges_data, min_order_amount
            
            # –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ trigger
            await asyncio.sleep(wait_after)
        
        
        
        # –®–∞–≥ 1.5: –í—ã–ø–æ–ª–Ω–∏—Ç—å navigate (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–æ–Ω—Ñ–∏–≥–µ)
        navigate_config = delivery_config.get('navigate')
        
        if navigate_config:
            logger.info("üöÄ Found navigate config, executing navigation...")
            
            # navigate - —ç—Ç–æ –æ–¥–∏–Ω action
            navigate_success = await execute_trigger_action(driver, navigate_config, telegram_id)
            
            if not navigate_success:
                logger.error("‚ùå Failed to execute navigate action")
                return ranges_data, min_order_amount
                
            logger.info(f"‚úÖ Successfully executed navigate, current URL: {driver.current_url}")
        else:
            logger.debug("üìù No navigate config found, continuing on current page")
        
        # –®–∞–≥ 1.5: –ò–∑–≤–ª–µ—á—å min_order_amount (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–æ–Ω—Ñ–∏–≥–µ)
        min_order_config_selector = delivery_config.get('min_order_amount_selector')
        
        if min_order_config_selector:
            logger.info(f"üí∞ Found min_order_amount_selector in config: {min_order_config_selector}")
            
            if isinstance(min_order_config_selector, dict):
                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä (—Ñ–æ—Ä–º–∞—Ç {"selector": "...", "fallback": ...})
                selector = min_order_config_selector.get('selector')
                fallback = min_order_config_selector.get('fallback')
                
                if selector:
                    logger.info(f"üîç Extracting min_order_amount via selector: {selector}")
                    try:
                        extracted_value = extract_numeric_value(driver, selector)
                        if extracted_value is not None:
                            min_order_amount = extracted_value
                            logger.info(f"‚úÖ Extracted min_order_amount: {min_order_amount}‚ÇΩ")
                        elif fallback is not None:
                            min_order_amount = float(fallback)
                            logger.info(f"üîÑ Using fallback min_order_amount: {min_order_amount}‚ÇΩ")
                        else:
                            logger.warning("‚ö†Ô∏è Failed to extract min_order_amount and no fallback provided")
                    except Exception as e:
                        logger.error(f"‚ùå Error extracting min_order_amount via selector: {e}")
                        if fallback is not None:
                            min_order_amount = float(fallback)
                            logger.info(f"üîÑ Using fallback due to error: {min_order_amount}‚ÇΩ")
                else:
                    logger.warning("‚ö†Ô∏è min_order_amount_selector config has no selector")
                    if fallback is not None:
                        min_order_amount = float(fallback)
                        logger.info(f"üîÑ Using fallback (no selector): {min_order_amount}‚ÇΩ")
                        
            elif isinstance(min_order_config_selector, str):
                # –≠—Ç–æ —Å–µ–ª–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä—è–º—É—é (—Å—Ç—Ä–æ–∫–∞ —Å XPath –∏–ª–∏ CSS)
                logger.info(f"üîç Extracting min_order_amount via selector string: {min_order_config_selector}")
                try:
                    extracted_value = extract_numeric_value(driver, min_order_config_selector)
                    if extracted_value is not None:
                        min_order_amount = extracted_value
                        logger.info(f"‚úÖ Extracted min_order_amount: {min_order_amount}‚ÇΩ")
                    else:
                        logger.warning(f"‚ö†Ô∏è Failed to extract min_order_amount from selector string: {min_order_config_selector}")
                except Exception as e:
                    logger.error(f"‚ùå Error extracting min_order_amount via selector string: {e}")
                        
            elif isinstance(min_order_config_selector, (int, float)):
                # –°—Ç–∞—Ç–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                min_order_amount = float(min_order_config_selector)
                logger.info(f"üí∞ Using static min_order_amount: {min_order_amount}‚ÇΩ")
            else:
                logger.warning(f"‚ö†Ô∏è Unknown min_order_amount_selector config format: {type(min_order_config_selector)}")
        else:
            logger.debug("üìù No min_order_amount_selector in config")
        
        # –®–∞–≥ 1.75: –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ delivery ranges
        ordered_extraction = delivery_config.get('ordered_extraction', {})
        fee_selectors = ordered_extraction.get('fee_selectors', [])
        threshold_selectors = ordered_extraction.get('threshold_selectors', [])
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è - –∂–¥–µ–º –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏—è
        if fee_selectors and threshold_selectors:
            logger.info(f"‚è≥ Waiting for delivery range selectors to appear...")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π —Å–µ–ª–µ–∫—Ç–æ—Ä –∂–¥–∞—Ç—å (–±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –Ω–µ–ø—É—Å—Ç–æ–π)
            selector_to_wait = None
            
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: fee_selectors[0] –µ—Å–ª–∏ –Ω–µ null, –∏–Ω–∞—á–µ threshold_selectors[0]
            if fee_selectors[0] and fee_selectors[0] != 'null':
                selector_to_wait = fee_selectors[0]
                logger.debug(f"üéØ Will wait for fee_selector: '{selector_to_wait[:50]}...'")
            elif threshold_selectors[0]:
                selector_to_wait = threshold_selectors[0]
                logger.debug(f"üéØ Will wait for threshold_selector (fee is null): '{selector_to_wait[:50]}...'")
            
            if selector_to_wait:
                # –¢–∞–π–º–∞—É—Ç –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç 5000ms
                wait_timeout = delivery_config.get('wait_after_trigger', 5000)
                
                # –ñ–¥–µ–º –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
                wait_success = await wait_for_any_selector(driver, [selector_to_wait], wait_timeout)
                
                if not wait_success:
                    # –°–µ–ª–µ–∫—Ç–æ—Ä—ã –Ω–µ –ø–æ—è–≤–∏–ª–∏—Å—å - —Å–æ—Ö—Ä–∞–Ω—è–µ–º HTML –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ
                    logger.error(f"‚ö†Ô∏è Delivery range selectors did not appear within {wait_timeout}ms")
                    
                    from datetime import datetime
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    log_file = f"/Users/ss/GenAI/korzinka/logs/page_dump_{timestamp}.html"
                    
                    try:
                        with open(log_file, 'w', encoding='utf-8') as f:
                            f.write(driver.page_source)
                        logger.warning(f"‚ö†Ô∏è Page HTML saved to: {log_file}")
                    except Exception as save_error:
                        logger.error(f"‚ùå Failed to save page HTML: {save_error}")
                    
                    logger.warning(f"‚ö†Ô∏è Current URL: {driver.current_url}")
                    logger.warning(f"‚ö†Ô∏è Expected selector: {selector_to_wait}")
                    
                    return ranges_data, min_order_amount
                else:
                    logger.info(f"‚úÖ Delivery range selectors appeared successfully")
            else:
                logger.warning(f"‚ö†Ô∏è Both fee_selectors[0] and threshold_selectors[0] are null/empty - skipping wait")
        
        # –®–∞–≥ 2: –ò–∑–≤–ª–µ—á—å –¥–∏–∞–ø–∞–∑–æ–Ω—ã –ø–æ –º–∞—Å—Å–∏–≤–∞–º —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
        
        if not fee_selectors or not threshold_selectors:
            # FALLBACK: –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –¥–æ—Å—Ç–∞–≤–∫–∏ —Å min_order_amount
            if min_order_amount is not None and min_order_amount > 0:
                logger.info(f"üìù Using simple delivery model (no ordered_extraction): min_order_amount={min_order_amount}‚ÇΩ")
                logger.info(f"‚ÑπÔ∏è This is a supported configuration - creating 2-range model")
                
                # –°–æ–∑–¥–∞—ë–º –¥–≤–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞:
                # 1) 0 - min_order_amount: –¥–æ—Å—Ç–∞–≤–∫–∞ = min_order_amount
                # 2) min_order_amount - ‚àû: –¥–æ—Å—Ç–∞–≤–∫–∞ = 0 (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)
                ranges_data = [
                    {
                        'fee': float(min_order_amount),
                        'threshold': 0.0,
                        'fee_text': f'–ú–∏–Ω–∏–º–∞–ª–∫–∞ {min_order_amount}‚ÇΩ',
                        'threshold_text': '–î–æ –º–∏–Ω–∏–º–∞–ª–∫–∏'
                    },
                    {
                        'fee': 0.0,
                        'threshold': float(min_order_amount),
                        'fee_text': f'–æ—Ç {min_order_amount}‚ÇΩ',
                        'threshold_text': f'–û—Ç {min_order_amount}‚ÇΩ'
                    }
                ]
                
                logger.info(f"‚úÖ Simple delivery model created: 2 ranges (0-{min_order_amount}‚ÇΩ fee={min_order_amount}‚ÇΩ, {min_order_amount}‚ÇΩ+ fee=0‚ÇΩ)")
                return ranges_data, min_order_amount
            else:
                logger.info("üìù No ordered_extraction and no min_order_amount - this LSD has no delivery cost model")
                return ranges_data, min_order_amount
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å
        if len(fee_selectors) != len(threshold_selectors):
            logger.error(f"‚ùå Mismatch: {len(fee_selectors)} fee_selectors vs {len(threshold_selectors)} threshold_selectors")
            return ranges_data, min_order_amount
        
        logger.info(f"üìã Extracting {len(fee_selectors)} delivery ranges")
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –∫–∞–∂–¥–æ–π –ø–∞—Ä–µ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
        for i, (fee_sel, threshold_sel) in enumerate(zip(fee_selectors, threshold_selectors), 1):
            try:
                logger.debug(f"üîç [{i}] Fee selector: '{fee_sel}'")
                logger.debug(f"üîç [{i}] Threshold selector: '{threshold_sel}'")
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º fee (–µ—Å–ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä –Ω–µ null)
                if fee_sel is None or fee_sel == 'null':
                    # null —Å–µ–ª–µ–∫—Ç–æ—Ä –æ–∑–Ω–∞—á–∞–µ—Ç fee = 0 (–±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞)
                    fee = 0.0
                    fee_text = "–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞"
                    logger.debug(f"üìù [{i}] Fee selector is null, using fee=0.0")
                else:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º XPath (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å // –∏–ª–∏ (//)
                    if fee_sel.startswith('//') or fee_sel.startswith('(//'):
                        fee_element = driver.find_element(By.XPATH, fee_sel)
                    else:
                        fee_element = driver.find_element(By.CSS_SELECTOR, fee_sel)
                    fee_text = fee_element.text.strip()
                    fee = parse_delivery_fee(fee_text)
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º threshold (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π)
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º XPath (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å // –∏–ª–∏ (//)
                if threshold_sel.startswith('//') or threshold_sel.startswith('(//'):
                    threshold_element = driver.find_element(By.XPATH, threshold_sel)
                else:
                    threshold_element = driver.find_element(By.CSS_SELECTOR, threshold_sel)
                threshold_text = threshold_element.text.strip()
                threshold = parse_delivery_info(threshold_text)
                
                logger.debug(f"üìù [{i}] Fee text: '{fee_text}', Threshold text: '{threshold_text}'")
                
                ranges_data.append({
                    'fee': fee,
                    'threshold': threshold,
                    'fee_text': fee_text,
                    'threshold_text': threshold_text
                })
                
                logger.info(f"‚úÖ [{i}] Extracted range: fee={fee}‚ÇΩ, threshold={threshold}‚ÇΩ")
                
            except Exception as item_error:
                logger.warning(f"‚ö†Ô∏è [{i}] Error extracting range: {item_error}")
                logger.warning(f"‚ö†Ô∏è Skipping range [{i}], continuing with already extracted ranges")
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–æ —Å–ª–µ–¥—É—é—â–∏–º
                continue
        
        # –®–∞–≥ 3: –ó–∞–∫—Ä—ã—Ç—å –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω close_trigger)
        close_trigger = delivery_config.get('close_trigger', {})
        if close_trigger and close_trigger.get('selector'):
            try:
                close_selector = close_trigger['selector']
                logger.info(f"üîò Closing modal with: {close_selector}")
                
                if close_selector.startswith('//'):
                    close_element = driver.find_element(By.XPATH, close_selector)
                else:
                    close_element = driver.find_element(By.CSS_SELECTOR, close_selector)
                close_element.click()
                
                logger.info(f"‚úÖ Modal closed successfully")
                await asyncio.sleep(0.5)  # –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è
                
            except Exception as close_error:
                if not close_trigger.get('optional', False):
                    logger.error(f"‚ùå Error closing modal: {close_error}")
                else:
                    logger.debug(f"‚ö†Ô∏è Optional close trigger failed: {close_error}")
        
        logger.info(f"üéâ Successfully extracted {len(ranges_data)} delivery ranges")
        if min_order_amount is not None:
            logger.info(f"üí∞ Extracted min_order_amount: {min_order_amount}‚ÇΩ")
        return ranges_data, min_order_amount
        
    except Exception as e:
        logger.error(f"‚ùå Error extracting delivery ranges: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return ranges_data, min_order_amount

def parse_delivery_fee(text: str) -> float:
    """
    –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ –∏–∑ —Ç–µ–∫—Å—Ç–∞
    –ü—Ä–∏–º–µ—Ä—ã:
    - "–î–æ—Å—Ç–∞–≤–∫–∞ 134 ‚ÇΩ" -> 134.0
    - "–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞" -> 0.0
    - "134 ‚ÇΩ" -> 134.0
    """
    try:
        if not text:
            return 0.0
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ—Å–ø–ª–∞—Ç–Ω—É—é –¥–æ—Å—Ç–∞–≤–∫—É
        if '–±–µ—Å–ø–ª–∞—Ç–Ω' in text.lower() or 'free' in text.lower():
            return 0.0
        
        # –ò—â–µ–º —á–∏—Å–ª–æ —Å –≤–∞–ª—é—Ç–æ–π
        match = re.search(r'(\d+[\s,]?\d*)\s*[‚ÇΩ—Ä—É–±]', text, re.IGNORECASE)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace(' ', '').replace(',', '')
            return float(number_str)
        
        # –ò—â–µ–º –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ
        numbers = re.findall(r'\d+', text)
        if numbers:
            return float(numbers[0])
        
        return 0.0
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Error parsing delivery fee '{text}': {e}")
        return 0.0

def parse_delivery_ranges_to_model(ranges_data: List[Dict[str, Any]], min_order_amount: Optional[float] = None) -> Dict[str, Any]:
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ –≤ JSON –º–æ–¥–µ–ª—å delivery_cost_model
    
    Args:
        ranges_data: [{"fee": 134.0, "threshold": 0.0}, {"fee": 94.0, "threshold": 1150.0}]
        min_order_amount: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –∑–∞–∫–∞–∑–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    
    Returns:
        {
          "delivery_cost": [
            {"min": 0.0, "max": 1150.0, "fee": 134.0, "label": "–î–æ 1 150‚ÇΩ"},
            {"min": 1150.0, "max": 1950.0, "fee": 94.0, "label": "1 150‚ÇΩ - 1 950‚ÇΩ"},
            {"min": 1950.0, "max": None, "fee": 0.0, "label": "–û—Ç 1 950‚ÇΩ"}
          ],
          "min_order_amount": 1500.0  # –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ
        }
    """
    if not ranges_data:
        logger.warning("‚ö†Ô∏è No ranges data to parse")
        result = {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": 0.0, "label": "Unknown"}
            ]
        }
        if min_order_amount is not None:
            result["min_order_amount"] = float(min_order_amount)
        return result
    
    # –í–ê–õ–ò–î–ê–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ fee –∏ threshold - –≤–∞–ª–∏–¥–Ω—ã–µ —á–∏—Å–ª–∞
    try:
        for i, range_item in enumerate(ranges_data):
            fee = range_item.get('fee')
            threshold = range_item.get('threshold')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
            if fee is None or threshold is None:
                logger.error(f"‚ùå Range [{i}] missing required fields: fee={fee}, threshold={threshold}")
                return {
                    "delivery_cost": [
                        {"min": 0.0, "max": None, "fee": 0.0, "label": "Invalid data"}
                    ]
                }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —á–∏—Å–ª–∞
            if not isinstance(fee, (int, float)) or not isinstance(threshold, (int, float)):
                logger.error(f"‚ùå Range [{i}] has non-numeric values: fee={type(fee).__name__}, threshold={type(threshold).__name__}")
                return {
                    "delivery_cost": [
                        {"min": 0.0, "max": None, "fee": 0.0, "label": "Invalid data"}
                    ]
                }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —á–∏—Å–ª–∞ >= 0
            if fee < 0 or threshold < 0:
                logger.error(f"‚ùå Range [{i}] has negative values: fee={fee}, threshold={threshold}")
                return {
                    "delivery_cost": [
                        {"min": 0.0, "max": None, "fee": 0.0, "label": "Invalid data"}
                    ]
                }
    except Exception as e:
        logger.error(f"‚ùå Error validating ranges data: {e}")
        return {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": 0.0, "label": "Validation error"}
            ]
        }
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ threshold (–æ—Ç –º–µ–Ω—å—à–µ–≥–æ –∫ –±–æ–ª—å—à–µ–º—É)
    try:
        sorted_ranges = sorted(ranges_data, key=lambda x: x['threshold'])
    except Exception as e:
        logger.error(f"‚ùå Error sorting ranges: {e}")
        return {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": 0.0, "label": "Sort error"}
            ]
        }
    
    # –í–ê–õ–ò–î–ê–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∏–∞–ø–∞–∑–æ–Ω—ã –∏–¥—É—Ç –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é (–±–µ–∑ –ø—Ä–æ–ø—É—Å–∫–æ–≤)
    for i in range(len(sorted_ranges) - 1):
        current_threshold = sorted_ranges[i]['threshold']
        next_threshold = sorted_ranges[i + 1]['threshold']
        
        if next_threshold <= current_threshold:
            logger.error(f"‚ùå Ranges not in ascending order: [{i}]={current_threshold} >= [{i+1}]={next_threshold}")
            return {
                "delivery_cost": [
                    {"min": 0.0, "max": None, "fee": 0.0, "label": "Order error"}
                ]
            }
    
    delivery_cost = []
    
    # –°–æ–∑–¥–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –∏–∑ –∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    for i, range_item in enumerate(sorted_ranges):
        min_val = range_item['threshold']
        fee = range_item['fee']
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º max: —ç—Ç–æ min —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–ª–∏ None –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ
        if i < len(sorted_ranges) - 1:
            max_val = sorted_ranges[i + 1]['threshold']
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º label
            if min_val == 0:
                label = f"–î–æ {format_price(max_val)}"
            else:
                label = f"{format_price(min_val)} - {format_price(max_val)}"
        else:
            # –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
            max_val = None
            label = f"–û—Ç {format_price(min_val)}"
        
        delivery_cost.append({
            "min": float(min_val),
            "max": float(max_val) if max_val is not None else None,
            "fee": float(fee),
            "label": label
        })
    
    # –î–û–ë–ê–í–õ–Ø–ï–ú –ù–£–õ–ï–í–û–ô –î–ò–ê–ü–ê–ó–û–ù, –µ—Å–ª–∏ –µ—Å—Ç—å min_order_amount > 0 –ò –ø–µ—Ä–≤—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –ù–ï –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0
    if min_order_amount is not None and min_order_amount > 0 and len(delivery_cost) > 0:
        first_range = delivery_cost[0]
        
        # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–≤—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –ù–ï –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0
        # –ï—Å–ª–∏ –ø–µ—Ä–≤—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —É–∂–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0 - –∑–Ω–∞—á–∏—Ç –¥–∏–∞–ø–∞–∑–æ–Ω—ã —É–∂–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
        if first_range['min'] > 0:
            # –ù—É–ª–µ–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω: –æ—Ç 0 –¥–æ –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
            zero_range = {
                "min": 0.0,
                "max": float(first_range['min']),  # –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                "fee": float(first_range['fee'] + min_order_amount),  # fee –ø–µ—Ä–≤–æ–≥–æ + –º–∏–Ω–∏–º–∞–ª–∫–∞
                "label": f"–î–æ {format_price(first_range['min'])}"
            }
            
            # –í—Å—Ç–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ
            delivery_cost.insert(0, zero_range)
            logger.info(f"‚ûï Added zero range (0 - {first_range['min']}‚ÇΩ) with fee={zero_range['fee']}‚ÇΩ (first_fee={first_range['fee']}‚ÇΩ + min_order={min_order_amount}‚ÇΩ)")
        else:
            logger.info(f"‚ÑπÔ∏è First range already starts at 0 - skipping zero range addition")
    
    model = {"delivery_cost": delivery_cost}
    
    # –î–æ–±–∞–≤–ª—è–µ–º min_order_amount –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω
    if min_order_amount is not None:
        model["min_order_amount"] = float(min_order_amount)
        logger.info(f"üí∞ Added min_order_amount to model: {min_order_amount}‚ÇΩ")
    
    logger.info(f"üìä Created delivery_cost_model with {len(delivery_cost)} ranges")
    logger.debug(f"üìä Model: {model}")
    
    return model

def format_price(price: float) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    –ü—Ä–∏–º–µ—Ä—ã:
    - 1150.0 -> "1 150‚ÇΩ"
    - 94.0 -> "94‚ÇΩ"
    """
    price_int = int(price)
    # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã –¥–ª—è —Ç—ã—Å—è—á
    price_str = f"{price_int:,}".replace(',', ' ')
    return f"{price_str}‚ÇΩ"

async def extract_page_level_data(driver, search_config: dict, lsd_config=None, telegram_id: int = None) -> Dict[str, Any]:
    """
    –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —É—Ä–æ–≤–Ω—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã (min_order_amount, delivery_cost, delivery_cost_model)
    –≠—Ç–∏ –¥–∞–Ω–Ω—ã–µ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –º–∞–≥–∞–∑–∏–Ω—É –≤ —Ü–µ–ª–æ–º, –∞ –Ω–µ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Ç–æ–≤–∞—Ä—É
    
    –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è delivery_cost_model:
    1. –ï—Å–ª–∏ –µ—Å—Ç—å delivery_ranges.enabled -> –∏–∑–≤–ª–µ–∫–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã —á–µ—Ä–µ–∑ –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
    2. –ï—Å–ª–∏ –µ—Å—Ç—å min_order_selector -> –∏–∑–≤–ª–µ–∫–∞–µ–º min_order_amount –∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç—É—é –º–æ–¥–µ–ª—å
    3. –ï—Å–ª–∏ –ù–ï –∏–∑–≤–ª–µ–∫–ª–∏ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã -> –±–µ—Ä–µ–º delivery_cost_model –∏–∑ lsd_config
    4. –ï—Å–ª–∏ –≤ –∫–æ–Ω—Ñ–∏–≥–µ –Ω–µ—Ç –º–æ–¥–µ–ª–∏ -> –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –∫–æ–Ω—Ñ–∏–≥–∞ –≤ –º–æ–¥–µ–ª—å
    """
    result = {
        'min_order_amount': 0.0,
        'delivery_cost': 0.0,
        'delivery_cost_model': None
    }
    
    extracted_from_page = False
    
    try:
        # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ delivery_ranges –≤ –∫–æ–Ω—Ñ–∏–≥–µ
        delivery_ranges_config = search_config.get('delivery_ranges', {})
        if delivery_ranges_config.get('enabled', False):
            logger.info("üéØ delivery_ranges enabled - extracting ranges from modal")
            
            try:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –∏–∑ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ (–ø–µ—Ä–µ–¥–∞–µ–º telegram_id –¥–ª—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤)
                ranges_data = await extract_delivery_ranges(driver, delivery_ranges_config, telegram_id=telegram_id)
                
                if ranges_data:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ JSON –º–æ–¥–µ–ª—å
                    result['delivery_cost_model'] = parse_delivery_ranges_to_model(ranges_data)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–æ–¥–µ–ª—å –≤–∞–ª–∏–¥–Ω–∞ (–Ω–µ –≤–µ—Ä–Ω—É–ª—Å—è fallback)
                    if result['delivery_cost_model'] and len(result['delivery_cost_model'].get('delivery_cost', [])) > 0:
                        first_range = result['delivery_cost_model']['delivery_cost'][0]
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –Ω–µ –æ—à–∏–±–æ—á–Ω—ã–π fallback
                        if first_range.get('label') not in ['Unknown', 'Invalid data', 'Validation error', 'Sort error', 'Order error']:
                            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º min_order_amount –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
                            if len(ranges_data) > 0:
                                result['min_order_amount'] = ranges_data[0]['threshold']
                            
                            extracted_from_page = True
                            logger.info(f"‚úÖ Extracted delivery_cost_model from ranges: {len(ranges_data)} ranges")
                        else:
                            logger.error(f"‚ùå Invalid delivery_cost_model returned (label={first_range.get('label')}), will use config fallback")
                    else:
                        logger.error("‚ùå Empty or invalid delivery_cost_model, will use config fallback")
                else:
                    # –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –æ—Ç extract_delivery_ranges() –æ–∑–Ω–∞—á–∞–µ—Ç –æ—à–∏–±–∫—É —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
                    logger.error("‚ùå No ranges extracted from delivery_ranges (selector error), will use config fallback")
            
            except Exception as ranges_error:
                logger.error(f"‚ùå Error extracting delivery_ranges: {ranges_error}")
                import traceback
                logger.debug(traceback.format_exc())
                logger.info("üîÑ Falling back to min_order_selector due to delivery_ranges error")
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ï—Å–ª–∏ –Ω–µ –∏–∑–≤–ª–µ–∫–ª–∏ —á–µ—Ä–µ–∑ delivery_ranges, –ø—Ä–æ–±—É–µ–º min_order_selector
        if not extracted_from_page:
            min_order_selector = search_config.get('min_order_selector')
            if min_order_selector:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ XPath –∏–ª–∏ CSS
                    if min_order_selector.startswith('//') or min_order_selector.startswith('(//'):
                        elements = driver.find_elements(By.XPATH, min_order_selector)
                        if elements:
                            min_order_text = elements[0].text.strip()
                            result['min_order_amount'] = parse_delivery_info(min_order_text)
                            extracted_from_page = True
                            logger.info(f"‚úÖ Extracted min_order_amount from page: {result['min_order_amount']} (text: '{min_order_text}')")
                    else:
                        elements = driver.find_elements(By.CSS_SELECTOR, min_order_selector)
                        if elements:
                            min_order_text = elements[0].text.strip()
                            result['min_order_amount'] = parse_delivery_info(min_order_text)
                            extracted_from_page = True
                            logger.info(f"‚úÖ Extracted min_order_amount from page: {result['min_order_amount']} (text: '{min_order_text}')")
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Could not extract min_order_amount: {e}")
                    logger.info("üîÑ Falling back to lsd_config due to min_order_selector error")
            
            # –ï—Å–ª–∏ –∏–∑–≤–ª–µ–∫–ª–∏ min_order —á–µ—Ä–µ–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä - —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç—É—é JSON –º–æ–¥–µ–ª—å
            if extracted_from_page and result['min_order_amount'] > 0:
                result['delivery_cost_model'] = {
                    "delivery_cost": [
                        {"min": 0.0, "max": float(result['min_order_amount']), "fee": float(result['min_order_amount']), "label": "R1"},
                        {"min": float(result['min_order_amount']), "max": None, "fee": 0.0, "label": "R2"}
                    ]
                }
                logger.info(f"‚úÖ Created delivery_cost_model from extracted min_order_amount: {result['delivery_cost_model']}")
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 3: –ï—Å–ª–∏ –ù–ï –ò–ó–í–õ–ï–ö–õ–ò –°–û –°–¢–†–ê–ù–ò–¶–´ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥
        if not extracted_from_page and lsd_config:
            logger.info("üìù Using fallback: lsd_config data (page extraction failed)")
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3.1: –±–µ—Ä–µ–º –≥–æ—Ç–æ–≤—É—é –º–æ–¥–µ–ª—å –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
            config_delivery_model = getattr(lsd_config, 'delivery_cost_model', None)
            if config_delivery_model:
                result['delivery_cost_model'] = config_delivery_model
                result['min_order_amount'] = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                logger.info(f"‚ÑπÔ∏è Using delivery_cost_model from lsd_config (min_order from config: {result['min_order_amount']})")
            else:
                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3.2: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –∫–æ–Ω—Ñ–∏–≥–∞ –≤ –º–æ–¥–µ–ª—å
                config_min_order = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                config_delivery_cost = getattr(lsd_config, 'delivery_cost', 0.0) or 0.0
                
                result['min_order_amount'] = float(config_min_order)
                result['delivery_cost'] = float(config_delivery_cost)
                
                if config_min_order > 0 or config_delivery_cost > 0:
                    result['delivery_cost_model'] = convert_legacy_to_model(
                        result['min_order_amount'], 
                        result['delivery_cost']
                    )
                    logger.info(f"üîÑ Converted legacy config fields to delivery_cost_model (min_order={config_min_order}, delivery={config_delivery_cost})")
                else:
                    logger.warning("‚ö†Ô∏è No delivery data in config - using defaults (0.0)")
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Error extracting page level data: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return result

def convert_legacy_to_model(min_order_amount: float, delivery_cost: float) -> Dict[str, Any]:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—Ç–∞—Ä—ã—Ö –ø–æ–ª–µ–π min_order_amount –∏ delivery_cost –≤ –Ω–æ–≤—É—é JSON –º–æ–¥–µ–ª—å
    
    –ü—Ä–∞–≤–∏–ª–∞:
    - –ï—Å–ª–∏ min_order_amount > 0: –ø–µ—Ä–≤—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –∏–º–µ–µ—Ç fee = min_order_amount (—ç—Ç–æ —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏ –¥–æ –ø–æ—Ä–æ–≥–∞)
    - –í—Ç–æ—Ä–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω (–æ—Ç min_order_amount –∏ –≤—ã—à–µ) –≤—Å–µ–≥–¥–∞ –∏–º–µ–µ—Ç fee = 0 (–±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞)
    
    –ü—Ä–∏–º–µ—Ä—ã:
    - min_order=0, delivery=0 -> –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞ –≤—Å–µ–≥–¥–∞
    - min_order=0, delivery=199 -> —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞ 199‚ÇΩ
    - min_order=500, delivery=0 -> –¥–æ—Å—Ç–∞–≤–∫–∞ 500‚ÇΩ –¥–æ –ø–æ—Ä–æ–≥–∞, –±–µ—Å–ø–ª–∞—Ç–Ω–æ –æ—Ç 500‚ÇΩ
    """
    if min_order_amount == 0 and delivery_cost == 0:
        # –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞ –≤—Å–µ–≥–¥–∞
        return {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": 0.0, "label": "Free"}
            ]
        }
    elif min_order_amount == 0 and delivery_cost > 0:
        # –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞
        return {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": float(delivery_cost), "label": "Fixed"}
            ]
        }
    elif min_order_amount > 0:
        # –î–æ—Å—Ç–∞–≤–∫–∞ —Å—Ç–æ–∏—Ç min_order_amount –¥–æ –ø–æ—Ä–æ–≥–∞, –∑–∞—Ç–µ–º –±–µ—Å–ø–ª–∞—Ç–Ω–æ
        # (—Å–ª—É—á–∞–π delivery_cost –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º, —Ç.–∫. min_order_amount - —ç—Ç–æ –∏ –µ—Å—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏)
        return {
            "delivery_cost": [
                {"min": 0.0, "max": float(min_order_amount), "fee": float(min_order_amount), "label": "R1"},
                {"min": float(min_order_amount), "max": None, "fee": 0.0, "label": "R2"}
            ]
        }
    else:
        # –ù–µ –¥–æ–ª–∂–Ω–æ –ø–æ–ø–∞–¥–∞—Ç—å —Å—é–¥–∞, –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        return {
            "delivery_cost": [
                {"min": 0.0, "max": None, "fee": 0.0, "label": "Unknown"}
            ]
        }

def check_delivery_availability(driver, config: dict) -> tuple:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    
    –ï—Å–ª–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–∞–π–¥–µ–Ω—ã –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏,
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç False –∏ –ø—Ä–∏—á–∏–Ω—É.
    
    Args:
        driver: Selenium WebDriver
        config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è delivery_unavailable_indicators –∏–∑ search_config_rpa
               {
                 "enabled": true,
                 "selectors": ["div.delivery-content__title", "..."],
                 "text_patterns": ["–î–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ –≤—Ä–µ–º–µ–Ω–∏", "..."]
               }
    
    Returns:
        tuple: (is_available: bool, unavailable_reason: str | None)
               - (True, None) –µ—Å–ª–∏ –¥–æ—Å—Ç–∞–≤–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
               - (False, "reason") –µ—Å–ª–∏ –¥–æ—Å—Ç–∞–≤–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞
    
    Examples:
        >>> is_available, reason = check_delivery_availability(driver, config)
        >>> if not is_available:
        >>>     logger.warning(f"Delivery unavailable: {reason}")
        >>>     return []  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –õ–°–î
    """
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞: –≤–∫–ª—é—á–µ–Ω–∞ –ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞
    if not config or not config.get('enabled', False):
        logger.debug("‚úÖ Delivery availability check disabled - assuming available")
        return True, None
    
    selectors = config.get('selectors', [])
    text_patterns = config.get('text_patterns', [])
    
    if not selectors or not text_patterns:
        logger.warning("‚ö†Ô∏è Delivery unavailable indicators config incomplete - assuming available")
        return True, None
    
    try:
        logger.debug(f"üîç Checking delivery availability with {len(selectors)} selector(s) and {len(text_patterns)} pattern(s)")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä
        for selector in selectors:
            try:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
                if is_xpath_selector(selector):
                    elements = driver.find_elements(By.XPATH, selector)
                else:
                    elements = driver.find_elements(By.CSS_SELECTOR, selector)
                
                if not elements:
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∂–¥–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                for element in elements:
                    try:
                        element_text = element.text.strip()
                        if not element_text:
                            continue
                        
                        element_text_lower = element_text.lower()
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
                        for pattern in text_patterns:
                            if not pattern:
                                continue
                            
                            pattern_lower = pattern.lower()
                            
                            if pattern_lower in element_text_lower:
                                # –ù–∞—à–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏!
                                logger.warning(f"üö´ Delivery UNAVAILABLE detected!")
                                logger.warning(f"   Selector: {selector[:80]}")
                                logger.warning(f"   Text: '{element_text}'")
                                logger.warning(f"   Pattern matched: '{pattern}'")
                                
                                reason = f"Found indicator: '{element_text}' (pattern: '{pattern}')" 
                                return False, reason
                    
                    except Exception as text_error:
                        logger.debug(f"‚ö†Ô∏è Error reading element text: {text_error}")
                        continue
            
            except Exception as selector_error:
                logger.debug(f"‚ö†Ô∏è Selector '{selector}' failed: {selector_error}")
                continue
        
        # –ù–∏ –æ–¥–∏–Ω –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω - –¥–æ—Å—Ç–∞–≤–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
        logger.debug("‚úÖ No unavailability indicators found - delivery is available")
        return True, None
    
    except Exception as e:
        logger.error(f"‚ùå Error checking delivery availability: {e}")
        import traceback
        logger.debug(traceback.format_exc())
        # –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å—á–∏—Ç–∞–µ–º –¥–æ—Å—Ç–∞–≤–∫—É –¥–æ—Å—Ç—É–ø–Ω–æ–π (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –±–µ–∑ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏)
        return True, None

def check_page_for_not_found(driver, not_found_phrases: List[str]) -> Optional[str]:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ñ—Ä–∞–∑ "—Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω"
    
    Args:
        driver: Selenium WebDriver
        not_found_phrases: –°–ø–∏—Å–æ–∫ —Ñ—Ä–∞–∑-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, ["–Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "–Ω–µ –Ω–∞—à–ª–æ—Å—å"])
    
    Returns:
        –ù–∞–π–¥–µ–Ω–Ω–∞—è —Ñ—Ä–∞–∑–∞ –µ—Å–ª–∏ —Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏–Ω–∞—á–µ None
    """
    if not not_found_phrases:
        return None
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        page_text = driver.find_element(By.TAG_NAME, 'body').text
        
        # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        page_text_lower = page_text.lower()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é —Ñ—Ä–∞–∑—É
        for phrase in not_found_phrases:
            if not phrase:
                continue
            
            phrase_lower = phrase.lower()
            
            if phrase_lower in page_text_lower:
                # –ù–∞—à–ª–∏ —Ñ—Ä–∞–∑—É - —Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
                logger.info(f"üö´ Product not found - detected phrase: '{phrase}'")
                
                # DEBUG: –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–æ–∫—Ä—É–≥ —Ñ—Ä–∞–∑—ã (50 —Å–∏–º–≤–æ–ª–æ–≤ –¥–æ –∏ –ø–æ—Å–ª–µ)
                phrase_index = page_text_lower.index(phrase_lower)
                context_start = max(0, phrase_index - 50)
                context_end = min(len(page_text), phrase_index + len(phrase_lower) + 50)
                context = page_text[context_start:context_end]
                logger.debug(f"üìù Context: ...{context}...")
                
                return phrase
        
        # –§—Ä–∞–∑—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã - —Ç–æ–≤–∞—Ä—ã –µ—Å—Ç—å
        return None
        
    except Exception as e:
        logger.error(f"‚ùå Error checking page for not_found phrases: {e}")
        return None
