#!/usr/bin/env python3
"""
–£—Ç–∏–ª–∏—Ç—ã –¥–ª—è Selenium-–ø–æ–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
–°–æ–¥–µ—Ä–∂–∏—Ç –∫–ª–∞—Å—Å—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ç–æ–≤–∞—Ä–∞—Ö –∏–∑ –≤–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü
"""

import asyncio
import logging
import re
from typing import List, Dict, Any, Optional
from selenium.webdriver.common.by import By

logger = logging.getLogger(__name__)

def get_search_results_key(driver, container_selector: str, item_selector: str, url_selector: str) -> Optional[str]:
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –∫–ª—é—á –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
    
    –ö–ª—é—á = "count:{–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_—Ç–æ–≤–∞—Ä–æ–≤}|url:{url_–ø–µ—Ä–≤–æ–≥–æ_—Ç–æ–≤–∞—Ä–∞}"
    
    Args:
        driver: Selenium WebDriver
        container_selector: –°–µ–ª–µ–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
        item_selector: –°–µ–ª–µ–∫—Ç–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–∞ —Ç–æ–≤–∞—Ä–∞
        url_selector: –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è URL —Ç–æ–≤–∞—Ä–∞
        
    Returns:
        –°—Ç—Ä–æ–∫–∞-–∫–ª—é—á –∏–ª–∏ None –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω/–ø—É—Å—Ç
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –ø–µ—Ä–µ–¥–∞–Ω—ã
        if not container_selector or not item_selector or not url_selector:
            logger.debug(f"üîë Missing selectors: container={container_selector}, item={item_selector}, url={url_selector}")
            return None
        
        # –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        if container_selector.startswith('//'):
            container_elements = driver.find_elements(By.XPATH, container_selector)
        else:
            container_elements = driver.find_elements(By.CSS_SELECTOR, container_selector)
        
        if not container_elements:
            logger.debug(f"üîë Container not found: {container_selector}")
            return None
        
        container = container_elements[0]
        
        # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Ç–æ–≤–∞—Ä—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        if item_selector.startswith('//'):
            items = container.find_elements(By.XPATH, item_selector)
        else:
            items = container.find_elements(By.CSS_SELECTOR, item_selector)
        
        if not items:
            logger.debug(f"üîë No items found in container")
            return None
        
        item_count = len(items)
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º URL –ø–µ—Ä–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
        first_item = items[0]
        first_url = "no-url"
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç –∏–ª–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä
            if '@' in url_selector:
                # –≠—Ç–æ XPath –∞—Ç—Ä–∏–±—É—Ç - –±–µ—Ä–µ–º href –Ω–∞–ø—Ä—è–º—É—é
                first_url = first_item.get_attribute('href') or "no-url"
            else:
                # –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç —Å URL
                if url_selector.startswith('//'):
                    url_element = first_item.find_element(By.XPATH, url_selector)
                else:
                    url_element = first_item.find_element(By.CSS_SELECTOR, url_selector)
                first_url = url_element.get_attribute('href') or "no-url"
            
            # –£–∫–æ—Ä–∞—á–∏–≤–∞–µ–º URL –¥–ª—è –∫–ª—é—á–∞ (–±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ path)
            if first_url and first_url != "no-url":
                from urllib.parse import urlparse
                parsed = urlparse(first_url)
                first_url = parsed.path or first_url
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Could not extract URL from first item: {e}")
            first_url = "no-url"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–ª—é—á
        key = f"count:{item_count}|url:{first_url}"
        logger.debug(f"üîë Search results key: {key}")
        return key
        
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Error calculating search results key: {e}")
        return None

def extract_numeric_value(driver, selector: str) -> Optional[float]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    
    Args:
        driver: Selenium WebDriver
        selector: CSS –∏–ª–∏ XPath —Å–µ–ª–µ–∫—Ç–æ—Ä
        
    Returns:
        –ß–∏—Å–ª–æ –∏–ª–∏ 0.0 –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å (–¥–ª—è —Å–ª—É—á–∞–µ–≤ —Ç–∏–ø–∞ "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ")
    """
    try:
        # –®–∞–≥ 1: –ù–∞–π—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç
        if selector.startswith('//') or selector.startswith('.//') or selector.startswith('(//'):
            element = driver.find_element(By.XPATH, selector)
        else:
            element = driver.find_element(By.CSS_SELECTOR, selector)
        
        # –®–∞–≥ 2: –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç
        text = element.text.strip()
        logger.info(f"üî¢ extract_numeric_value: –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç = '{text}' (selector: {selector[:50]}...)")
        
        if not text:
            logger.warning(f"‚ö†Ô∏è extract_numeric_value: –≠–ª–µ–º–µ–Ω—Ç –Ω–∞–π–¥–µ–Ω, –Ω–æ —Ç–µ–∫—Å—Ç –ø—É—Å—Ç–æ–π")
            return 0.0
        
        # –®–∞–≥ 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" –∏–ª–∏ –ø–æ–¥–æ–±–Ω—ã–µ —Ñ—Ä–∞–∑—ã
        if any(word in text.lower() for word in ['–±–µ—Å–ø–ª–∞—Ç–Ω', 'free', '–¥–∞—Ä–æ–º']):
            logger.info(f"‚úÖ extract_numeric_value: –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ '–ë–µ—Å–ø–ª–∞—Ç–Ω–æ' -> 0.0")
            return 0.0
        
        # –®–∞–≥ 4: –ò–∑–≤–ª–µ—á—å –ü–û–°–õ–ï–î–ù–ï–ï —á–∏—Å–ª–æ –ø–µ—Ä–µ–¥ —Å–∏–º–≤–æ–ª–æ–º –≤–∞–ª—é—Ç—ã ‚ÇΩ/—Ä—É–±
        # –ü–∞—Ç—Ç–µ—Ä–Ω: –∏—â–µ–º –≤—Å–µ —á–∏—Å–ª–∞ –ø–µ—Ä–µ–¥ ‚ÇΩ, –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ
        currency_pattern = r'[‚ÇΩ—Ä—É–±]'
        currency_match = re.search(currency_pattern, text, re.IGNORECASE)
        
        if currency_match:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –î–û –ø–µ—Ä–≤–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –≤–∞–ª—é—Ç—ã
            text_before_currency = text[:currency_match.start()]
            logger.debug(f"üìù –¢–µ–∫—Å—Ç –¥–æ –≤–∞–ª—é—Ç—ã: '{text_before_currency}'")
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –í–°–ï —á–∏—Å–ª–∞ (–º–æ–≥—É—Ç –±—ã—Ç—å —Å –ø—Ä–æ–±–µ–ª–∞–º–∏ —Ç–∏–ø–∞ "1 500")
            numbers = re.findall(r'\d+', text_before_currency)
            
            if numbers:
                # –ë–µ—Ä–µ–º –ü–û–°–õ–ï–î–ù–ï–ï —á–∏—Å–ª–æ –ø–µ—Ä–µ–¥ –≤–∞–ª—é—Ç–æ–π
                last_number_str = numbers[-1]
                logger.debug(f"üîç –í—Å–µ —á–∏—Å–ª–∞ –¥–æ –≤–∞–ª—é—Ç—ã: {numbers}, –≤—ã–±—Ä–∞–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ: '{last_number_str}'")
                
                try:
                    extracted_value = float(last_number_str)
                    logger.info(f"‚úÖ extract_numeric_value: –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value}")
                    return extracted_value
                except ValueError:
                    logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å '{last_number_str}' –≤ —á–∏—Å–ª–æ")
                    return 0.0
            else:
                logger.warning(f"‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ —á–∏—Å–µ–ª –ø–µ—Ä–µ–¥ —Å–∏–º–≤–æ–ª–æ–º –≤–∞–ª—é—Ç—ã")
        
        # –®–∞–≥ 5: Fallback - –ø—Ä–æ–±—É–µ–º —Å—Ç–∞—Ä—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –µ—Å–ª–∏ –Ω–µ—Ç —Å–∏–º–≤–æ–ª–∞ –≤–∞–ª—é—Ç—ã
        patterns = [
            r'–æ—Ç\s+(\d+[\s,]?\d*)',         # "–æ—Ç 1500"
            r'(\d+[\s,]?\d*)\s*$',          # —á–∏—Å–ª–æ –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏
            r'^(\d+[\s,]?\d*)',              # —á–∏—Å–ª–æ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
            r'(\d+[\s,]?\d*)',               # –ª—é–±–æ–µ —á–∏—Å–ª–æ –≤ —Å—Ç—Ä–æ–∫–µ
        ]
        
        for i, pattern in enumerate(patterns, 1):
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                number_str = match.group(1)
                # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∑–∞–ø—è—Ç—ã–µ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ —Ç—ã—Å—è—á)
                number_str = number_str.replace(' ', '').replace(',', '')
                
                try:
                    extracted_value = float(number_str)
                    logger.info(f"‚úÖ extract_numeric_value (fallback): –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value} (–ø–∞—Ç—Ç–µ—Ä–Ω {i})")
                    return extracted_value
                except ValueError:
                    logger.debug(f"‚ö†Ô∏è Pattern {i} matched but failed to parse: '{number_str}'")
                    continue
        
        # –®–∞–≥ 6: –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback - –ø—Ä–æ—Å—Ç–æ –∏—â–µ–º –ª—é–±—ã–µ —Ü–∏—Ñ—Ä—ã
        logger.warning(f"‚ö†Ô∏è extract_numeric_value: –í—Å–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã failed, –ø–æ—Å–ª–µ–¥–Ω–∏–π fallback")
        cleaned = re.sub(r'[^\d]', '', text)
        
        if cleaned:
            try:
                extracted_value = float(cleaned)
                logger.info(f"‚úÖ extract_numeric_value (last fallback): –ò–∑–≤–ª–µ—á–µ–Ω–æ —á–∏—Å–ª–æ = {extracted_value}")
                return extracted_value
            except ValueError:
                logger.error(f"‚ùå extract_numeric_value: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å '{cleaned}' –≤ —á–∏—Å–ª–æ")
                return 0.0
        else:
            logger.warning(f"‚ö†Ô∏è extract_numeric_value: –ù–µ –Ω–∞–π–¥–µ–Ω–æ —á–∏—Å–µ–ª –≤ —Ç–µ–∫—Å—Ç–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0.0")
            return 0.0
        
    except Exception as e:
        logger.error(f"‚ùå extract_numeric_value: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ '{selector}': {e}")
        import traceback
        logger.debug(traceback.format_exc())
        return 0.0

class ProductSearchResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∞"""
    def __init__(self, order_item_id: int, product_name: str, search_query: str = None, 
                 found_name: str = None, price: float = 0.0, unit: str = '—à—Ç', 
                 quantity: float = 1.0, available_stock: int = 1, product_url: str = None,
                 lsd_name: str = None, search_position: int = 1, 
                 min_order_amount: float = 0.0, delivery_cost: float = 0.0, delivery_cost_model: dict = None,
                 is_alternative: bool = False, alternative_for: str = None):
        self.order_item_id = order_item_id
        self.product_name = product_name
        self.search_query = search_query or product_name
        self.found_name = found_name or product_name
        self.price = price
        self.unit = unit
        self.quantity = quantity
        self.available_stock = available_stock
        self.product_url = product_url
        self.lsd_name = lsd_name
        self.search_position = search_position
        self.min_order_amount = min_order_amount
        self.delivery_cost = delivery_cost
        self.delivery_cost_model = delivery_cost_model
        self.found_items = []
        self.search_successful = False
        self.error_message = None
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
        self.is_alternative = is_alternative
        self.alternative_for = alternative_for


