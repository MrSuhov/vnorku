#!/usr/bin/env python3
"""
–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π RPA —Å–µ—Ä–≤–∏—Å —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Selenium
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

# === –ö–†–ò–¢–ò–ß–ù–û: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –ü–ï–†–ï–î –≤—Å–µ–º–∏ –∏–º–ø–æ—Ä—Ç–∞–º–∏ ===
import logging
from shared.utils.unified_logging import setup_service_logging

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (—Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏)
setup_service_logging('rpa-service', level=logging.INFO)
# === –ö–æ–Ω–µ—Ü —Ä–∞–Ω–Ω–µ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ===

import re
import json
import asyncio
from typing import Dict, Any, Optional, List
from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel
import uvicorn
import urllib.parse as urlparse
import html
from decimal import Decimal
import time

# –ò–º–ø–æ—Ä—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞
from shared.database import get_async_session
from shared.database.models import LSDConfig, User, Order, OrderItem, LSDStock, UserSession
from shared.utils.text_normalizer import normalize_product_name
from order_quantity_calculator import calculate_order_quantity
from shared.utils.text_processing import (
    get_word_synonyms, 
    enhanced_lemmatize, 
    normalize_and_extract_keywords, 
    detect_processing_modifiers,
    extract_numeric_parameters,
    calculate_numeric_mismatch_penalty,
    detect_extra_products_same_category,
    calculate_extra_products_penalty
)



# –ò–ú–ü–û–†–¢ SELENIUM –ü–û–ò–°–ö–ê –¢–û–í–ê–†–û–í
from selenium_product_search import ProductSearchResult

# –ò–ú–ü–û–†–¢ CDP COOKIE MANAGER
from cdp_cookie_manager import CDPCookieManager

# –ò–ú–ü–û–†–¢ COOKIE FILE MANAGER
from cookie_file_manager import cookie_manager
from _save_cookies_helper import _save_cookies_before_return

# –ò–ú–ü–û–†–¢ –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–´–• RPA HELPERS
from unified_rpa_helpers import (
    execute_unified_click_step,
    execute_unified_hover_step,  # –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è!
    execute_scroll_step, 
    execute_unified_wait_for_step,
    execute_unified_clear_step,
    execute_unified_phone_input_step,
    request_unified_sms_code,
    execute_unified_sms_input_step,
    execute_unified_auth_verification,
    execute_unified_qr_extraction_step,
    execute_save_address_step  # –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–¥—Ä–µ—Å–∞!
)

from browser_profile_manager import profile_manager
from contextlib import asynccontextmanager

from shared.models.base import OrderStatus
from shared.utils.units import get_base_unit, convert_to_base_unit
from shared.utils.egg_categories import get_egg_category_coefficient, extract_egg_category, extract_egg_count_from_name
from sqlalchemy import select, update
from config.settings import settings
from shared.database.models import LSDStock
from sqlalchemy import delete
from datetime import datetime

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
from dotenv import load_dotenv
load_dotenv()

# –ö–†–ò–¢–ò–ß–ù–û: –ü–æ–ª—É—á–∞–µ–º logger –ü–û–°–õ–ï –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
# –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ logger –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ handlers
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
active_browser_sessions = {}
max_concurrent_sessions = 2
background_task = None

# –ö–†–ò–¢–ò–ß–ù–û: –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å–µ–º–∞—Ñ–æ—Ä –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ /search/products endpoint –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è MAX_CONCURRENT_BROWSERS
browser_semaphore = asyncio.Semaphore(settings.max_concurrent_browsers)

# =============== –§–£–ù–ö–¶–ò–Ø –°–û–•–†–ê–ù–ï–ù–ò–Ø HTML DUMP ===============

def save_debug_html_dump(driver, lsd_name: str, reason: str, product_query: str = "") -> Optional[str]:
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç HTML –¥–∞–º–ø —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –ø—Ä–æ–±–ª–µ–º
    
    Args:
        driver: WebDriver instance
        lsd_name: –ù–∞–∑–≤–∞–Ω–∏–µ –õ–°–î
        reason: –ü—Ä–∏—á–∏–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (timeout, no_elements, error –∏ —Ç.–¥.)
        product_query: –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        
    Returns:
        –ü—É—Ç—å –∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
    """
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
        product_part = f"_{product_query[:30]}" if product_query else ""
        filename = f"debug_dump_{lsd_name}_{reason}{product_part}_{timestamp}.html"
        
        # –£–±–∏—Ä–∞–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
        filename = re.sub(r'[^\w\-_\. ]', '_', filename)
        filename = filename.replace(' ', '_')
        
        # –ü—É—Ç—å –∫ logs –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        logs_dir = "/Users/ss/GenAI/korzinka/logs"
        filepath = os.path.join(logs_dir, filename)
        
        # –ü–æ–ª—É—á–∞–µ–º HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        page_html = driver.page_source
        current_url = driver.current_url
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(f"<!-- DEBUG DUMP -->\n")
            f.write(f"<!-- LSD: {lsd_name} -->\n")
            f.write(f"<!-- Reason: {reason} -->\n")
            f.write(f"<!-- Product Query: {product_query} -->\n")
            f.write(f"<!-- Current URL: {current_url} -->\n")
            f.write(f"<!-- Timestamp: {timestamp} -->\n")
            f.write("\n\n")
            f.write(page_html)
        
        logger.info(f"üíæ HTML dump saved: {filepath}")
        logger.debug(f"   Reason: {reason}")
        logger.debug(f"   URL: {current_url}")
        
        return filepath
        
    except Exception as e:
        logger.error(f"‚ùå Failed to save HTML dump: {e}")
        return None

# =============== –§–£–ù–ö–¶–ò–Ø –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –ú–û–õ–û–ß–ù–´–• –ü–†–û–î–£–ö–¢–û–í ===============

def is_milk_product(product_name: str) -> bool:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–æ–¥—É–∫—Ç –º–æ–ª–æ—á–Ω—ã–º –ø–æ –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—é"""
    if not product_name:
        return False
    
    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    name_lower = product_name.lower()
    
    # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –º–æ–ª–æ—á–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤
    milk_keywords = [
        '–º–æ–ª–æ–∫–æ', 'milk', '–∫–µ—Ñ–∏—Ä', '—Ä—è–∂–µ–Ω–∫–∞', '—Å–ª–∏–≤–∫–∏', '–π–æ–≥—É—Ä—Ç',
        '—Ç–≤–æ—Ä–æ–≥', '—Å–º–µ—Ç–∞–Ω–∞', '–ø—Ä–æ—Å—Ç–æ–∫–≤–∞—à–∞', '–≤–∞—Ä–µ–Ω–µ—Ü', '–±–∏—Ñ–∏–¥–æ–∫',
        '—Å–Ω–µ–∂–æ–∫', '–∞—Ü–∏–¥–æ—Ñ–∏–ª–∏–Ω', '–ø–∞—Ö—Ç–∞', '—Å—ã–≤–æ—Ä–æ—Ç–∫–∞'
    ]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
    for keyword in milk_keywords:
        if keyword in name_lower:
            # –ò—Å–∫–ª—é—á–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–µ-–º–æ–ª–æ—á–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã
            exclude_keywords = ['—Å–≥—É—â–µ–Ω–∫–∞', '—Å–≥—É—â–µ–Ω–Ω–æ–µ', '—Å—É—Ö–æ–µ –º–æ–ª–æ–∫–æ', '–ø–æ—Ä–æ—à–æ–∫']
            if any(exclude in name_lower for exclude in exclude_keywords):
                return False
            return True
    
    return False

# =============== –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –†–ê–°–ß–ï–¢–ê MATCH_SCORE v2.0 ===============

def levenshtein_distance(s1: str, s2: str) -> int:
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –õ–µ–≤–µ–Ω—à—Ç–µ–π–Ω–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Å—Ç—Ä–æ–∫–∞–º–∏"""
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    
    if len(s2) == 0:
        return len(s1)
    
    previous_row = list(range(len(s2) + 1))
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]

def fuzzy_word_similarity(word1: str, word2: str) -> float:
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –Ω–µ—á—ë—Ç–∫–æ–π —Å—Ö–æ–∂–µ—Å—Ç–∏ –º–µ–∂–¥—É —Å–ª–æ–≤–∞–º–∏ (0.0 - 1.0)"""
    if word1 == word2:
        return 1.0
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω–æ–Ω–∏–º—ã –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞–ø–∏—Å–∞–Ω–∏—è
    synonyms = get_word_synonyms(word1)
    if word2 in synonyms:
        return 0.95
    
    # –ï—Å–ª–∏ –æ–¥–Ω–æ —Å–ª–æ–≤–æ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ –¥—Ä—É–≥–æ–º
    if word1 in word2 or word2 in word1:
        shorter = min(len(word1), len(word2))
        longer = max(len(word1), len(word2))
        return shorter / longer * 0.9
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –õ–µ–≤–µ–Ω—à—Ç–µ–π–Ω–∞
    max_len = max(len(word1), len(word2))
    if max_len == 0:
        return 1.0
    
    distance = levenshtein_distance(word1, word2)
    similarity = 1.0 - (distance / max_len)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ö–æ–∂–µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—ã—Å–æ–∫–∞—è
    return similarity if similarity >= 0.7 else 0.0

def calculate_advanced_match_score(search_query: str, found_name: str) -> tuple[float, bool]:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–∞—Å—á—ë—Ç match_score v5.7 - –¥–æ–±–∞–≤–ª–µ–Ω–æ –æ–±—Ä–∞—Ç–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ (reverse coverage)"""
    if not search_query or not found_name:
        return 0.0, False
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤
    normalized_search_query = normalize_product_name(search_query)
    normalized_found_name = normalize_product_name(found_name)
    
    logger.debug(f"üßπ Normalized names for scoring:")
    logger.debug(f"   Search: '{search_query}' -> '{normalized_search_query}'")
    logger.debug(f"   Found:  '{found_name}' -> '{normalized_found_name}'")
    
    search_words = normalize_and_extract_keywords(normalized_search_query)
    found_words = normalize_and_extract_keywords(normalized_found_name)
    
    logger.debug(f"Enhanced match analysis: '{normalized_search_query}' -> {search_words} vs '{normalized_found_name}' -> {found_words}")
    
    if not search_words:
        return 0.3, False
    
    # –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –Ω–∞–±–æ—Ä–æ–≤ —Å–ª–æ–≤
    if set(search_words) == set(found_words):
        logger.debug("Exact keyword set match")
        return 1.0, True
    
    # –ü–æ–¥—Å—á—ë—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    total_search_words = len(search_words)
    total_found_words = len(found_words)
    match_score = 0.0
    exact_matches = 0
    fuzzy_matches = 0
    
    for search_word in search_words:
        best_match_score = 0.0
        found_exact = False
        
        for found_word in found_words:
            similarity = fuzzy_word_similarity(search_word, found_word)
            
            if similarity == 1.0:
                best_match_score = 1.0
                found_exact = True
                break
            elif similarity >= 0.95:
                best_match_score = max(best_match_score, 0.95)
            elif similarity >= 0.7:
                best_match_score = max(best_match_score, similarity * 0.8)
        
        if found_exact:
            exact_matches += 1
            match_score += 1.0
        elif best_match_score >= 0.7:
            fuzzy_matches += 1
            match_score += best_match_score
    
    base_score = match_score / total_search_words
    bonus = 0.0
    penalty = 0.0
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ
    has_full_coverage = (exact_matches + fuzzy_matches) >= total_search_words
    
    # –ù–û–í–û–ï v5.7: –û–ë–†–ê–¢–ù–û–ï –ü–û–ö–†–´–¢–ò–ï (reverse coverage)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ —Å–ª–æ–≤–∞ found_name –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ search_query
    # –≠—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è —Å–ª—É—á–∞–µ–≤ —Ç–∏–ø–∞: search="–ò–∫—Ä–∞ —á–µ—Ä–Ω–∞—è 100–≥ OFI –æ—Å–µ—Ç—Ä–∞" vs found="–ò–∫—Ä–∞ —á–µ—Ä–Ω–∞—è"
    found_in_search_count = 0
    for found_word in found_words:
        best_similarity = 0.0
        for search_word in search_words:
            similarity = fuzzy_word_similarity(found_word, search_word)
            best_similarity = max(best_similarity, similarity)
            if similarity >= 0.95:  # –ù–∞—à–ª–∏ —Ö–æ—Ä–æ—à–µ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                found_in_search_count += 1
                break
    
    reverse_coverage_ratio = found_in_search_count / total_found_words if total_found_words > 0 else 0.0
    has_reverse_coverage = reverse_coverage_ratio >= 0.95  # –ü–æ—á—Ç–∏ –≤—Å–µ —Å–ª–æ–≤–∞ found –µ—Å—Ç—å –≤ search
    
    # –®—Ç—Ä–∞—Ñ –∑–∞ –¥–ª–∏–Ω—É
    word_count_ratio = total_found_words / total_search_words
    if word_count_ratio > 2.0:
        length_penalty = min(0.3, (word_count_ratio - 2.0) * 0.1)
        penalty += length_penalty
        logger.debug(f"‚ö†Ô∏è Length penalty: -{length_penalty:.2f}")
    
    # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –®–¢–†–ê–§ –∑–∞ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞
    if search_words and found_words:
        first_search_word = search_words[0]
        first_found_word = found_words[0]
        
        first_word_similarity = fuzzy_word_similarity(first_search_word, first_found_word)
        
        if first_word_similarity < 0.7:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ø-3
            found_in_top3 = False
            top3_position = -1
            for i, found_word in enumerate(found_words[:3]):
                if fuzzy_word_similarity(first_search_word, found_word) >= 0.8:
                    found_in_top3 = True
                    top3_position = i
                    break
            
            if not found_in_top3:
                # –ù–ï –≤ —Ç–æ–ø-3: —à—Ç—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø–æ–ª–Ω–æ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è
                if has_full_coverage:
                    first_word_mismatch_penalty = 0.25  # –ú—è–≥–∫–∏–π —à—Ç—Ä–∞—Ñ –µ—Å–ª–∏ –í–°–ï —Å–ª–æ–≤–∞ –Ω–∞–π–¥–µ–Ω—ã
                    penalty += first_word_mismatch_penalty
                    logger.debug(f"‚ö†Ô∏è First word not in top-3, BUT full coverage (-0.25)")
                else:
                    first_word_mismatch_penalty = 0.45  # –ñ–µ—Å—Ç–∫–∏–π —à—Ç—Ä–∞—Ñ
                    penalty += first_word_mismatch_penalty
                    logger.debug(f"‚ùå CRITICAL: First word not in top-3 AND incomplete (-0.45)")
            else:
                # –í —Ç–æ–ø-3 –Ω–æ –Ω–µ –ø–µ—Ä–≤–æ–µ
                coverage_ratio = (exact_matches + fuzzy_matches) / total_search_words
                if coverage_ratio >= 0.9:
                    first_word_mismatch_penalty = 0.15
                    logger.debug(f"‚ö†Ô∏è First word at pos {top3_position+1} but high coverage (-0.15)")
                else:
                    first_word_mismatch_penalty = 0.25
                    logger.debug(f"‚ö†Ô∏è First word at pos {top3_position+1} with low coverage (-0.25)")
                penalty += first_word_mismatch_penalty
        else:
            # –•–æ—Ä–æ—à–µ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞
            if first_word_similarity >= 0.95:
                bonus += 0.2
                logger.debug(f"‚úÖ First word high similarity: +0.2")
            elif first_word_similarity >= 0.7:
                bonus += 0.1
                logger.debug(f"‚úÖ First word medium similarity: +0.1")
    
    # –®–¢–†–ê–§ –ó–ê –ù–ï–ó–ê–ü–†–û–®–ï–ù–ù–£–Æ –û–ë–†–ê–ë–û–¢–ö–£ –ü–†–û–î–£–ö–¢–ê (v5.4 - —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    search_modifiers = detect_processing_modifiers(normalized_search_query)
    found_modifiers = detect_processing_modifiers(normalized_found_name)
    
    # –õ–æ–≥–∏—Ä—É–µ–º –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
    if search_modifiers or found_modifiers:
        logger.info(f"üîç Processing modifiers check: search={search_modifiers}, found={found_modifiers}")
    
    # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ –Ω–∞–π–¥–µ–Ω–Ω–æ–º, –Ω–æ –ù–ï–¢ –≤ –∑–∞–ø—Ä–æ—Å–µ
    unrequested_modifiers = found_modifiers - search_modifiers
    has_unrequested_processing = len(unrequested_modifiers) > 0
    
    if has_unrequested_processing:
        # –ï—Å—Ç—å –Ω–µ–∑–∞–ø—Ä–æ—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
        processing_penalty = 0.50  # –£—Å–∏–ª–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ (–±—ã–ª–æ 0.40)
        penalty += processing_penalty
        logger.info(f"‚ùå Unrequested processing detected: {unrequested_modifiers} (penalty: -{processing_penalty:.2f})")
    
    # –®–¢–†–ê–§ –ó–ê –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–û–î–£–ö–¢–´ –¢–û–ô –ñ–ï –ö–ê–¢–ï–ì–û–†–ò–ò (v5.6)
    extra_products_info = detect_extra_products_same_category(
        normalized_search_query, 
        normalized_found_name
    )
    
    if extra_products_info['has_extra']:
        extra_products_penalty = calculate_extra_products_penalty(
            extra_products_info['extra_products']
        )
        penalty += extra_products_penalty
        logger.info(f"‚ùå Extra products in same category ({extra_products_info['category']}): "
                    f"{extra_products_info['extra_products']} (penalty: -{extra_products_penalty:.2f})")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç–∏ –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –±–æ–Ω—É—Å–æ–≤
    has_extra_products = extra_products_info['has_extra']
    
    # –ù–û–í–û–ï v5.5: –®–¢–†–ê–§ –ó–ê –ù–ï–°–û–í–ü–ê–î–ï–ù–ò–ï –ß–ò–°–õ–û–í–´–• –ü–ê–†–ê–ú–ï–¢–†–û–í (–ø—Ä–æ—Ü–µ–Ω—Ç—ã, –≤–µ—Å, –æ–±—ä–µ–º)
    search_numeric = extract_numeric_parameters(normalized_search_query)
    found_numeric = extract_numeric_parameters(normalized_found_name)
    
    numeric_penalty, numeric_reason = calculate_numeric_mismatch_penalty(
        search_params=search_numeric,
        found_params=found_numeric
    )
    
    # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    if (search_numeric['percentages'] or search_numeric['weights'] or 
        search_numeric['volumes'] or search_numeric['pieces'] or
        found_numeric['percentages'] or found_numeric['weights'] or 
        found_numeric['volumes'] or found_numeric['pieces']):
        logger.info(f"üî¢ Numeric params: search={search_numeric}, found={found_numeric}")
    
    if numeric_penalty > 0:
        penalty += numeric_penalty
        logger.info(f"‚ùå Numeric parameter mismatch: {numeric_reason} (penalty: -{numeric_penalty:.2f})")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω–æ–≥–æ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    critical_numeric_mismatch = numeric_penalty >= 0.35
    
    # –ù–û–í–û–ï v5.7: –ë–û–ù–£–° –ó–ê –û–ë–†–ê–¢–ù–û–ï –ü–û–ö–†–´–¢–ò–ï
    # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ç–æ–≤–∞—Ä - —ç—Ç–æ "–ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ" –∑–∞–ø—Ä–æ—Å–∞ (–≤—Å–µ —Å–ª–æ–≤–∞ found –µ—Å—Ç—å –≤ search)
    # –ü—Ä–∏–º–µ—Ä: search="–ò–∫—Ä–∞ —á–µ—Ä–Ω–∞—è 100–≥ OFI" vs found="–ò–∫—Ä–∞ —á–µ—Ä–Ω–∞—è" -> reverse coverage = 100%
    if has_reverse_coverage and total_found_words >= 2:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫–∏—Ä—É—é—â–∏–µ —É—Å–ª–æ–≤–∏—è
        if penalty < 0.5 and not has_unrequested_processing and not critical_numeric_mismatch and not has_extra_products:
            # –ë–æ–Ω—É—Å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è –¥–ª–∏–Ω
            length_ratio = total_search_words / total_found_words
            
            if length_ratio <= 2.0:
                # –ó–∞–ø—Ä–æ—Å –Ω–µ —Å–∏–ª—å–Ω–æ –¥–ª–∏–Ω–Ω–µ–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ (–≤ 2 —Ä–∞–∑–∞ –º–∞–∫—Å–∏–º—É–º)
                reverse_coverage_bonus = 0.40
                bonus += reverse_coverage_bonus
                logger.debug(f"‚úÖ Reverse coverage bonus: +{reverse_coverage_bonus:.2f} (found is subset, ratio={length_ratio:.1f})")
            elif length_ratio <= 4.0:
                # –ó–∞–ø—Ä–æ—Å –¥–ª–∏–Ω–Ω–µ–µ –≤ 2-4 —Ä–∞–∑–∞ (–º–Ω–æ–≥–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–µ—Ç–∞–ª–µ–π)
                reverse_coverage_bonus = 0.35
                bonus += reverse_coverage_bonus
                logger.debug(f"‚úÖ Reverse coverage bonus: +{reverse_coverage_bonus:.2f} (found is subset, ratio={length_ratio:.1f})")
            else:
                # –ó–∞–ø—Ä–æ—Å –û–ß–ï–ù–¨ –¥–ª–∏–Ω–Ω—ã–π (4+ —Ä–∞–∑) - –º–µ–Ω—å—à–∏–π –±–æ–Ω—É—Å
                reverse_coverage_bonus = 0.25
                bonus += reverse_coverage_bonus
                logger.debug(f"‚úÖ Reverse coverage bonus: +{reverse_coverage_bonus:.2f} (found is subset, long ratio={length_ratio:.1f})")
        else:
            reasons = []
            if has_unrequested_processing:
                reasons.append("unrequested processing")
            if critical_numeric_mismatch:
                reasons.append("critical numeric mismatch")
            if has_extra_products:
                reasons.append("extra products")
            if penalty >= 0.5:
                reasons.append(f"high penalty ({penalty:.2f})")
            logger.info(f"‚ö†Ô∏è Reverse coverage bonus blocked: {', '.join(reasons)}")
    
    # –ë–æ–Ω—É—Å—ã –¥–∞—é—Ç—Å—è –ø—Ä–∏ penalty < 0.5 (—Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–Ω—ã–π –ø–æ—Ä–æ–≥)
    # –ù–û: –±–ª–æ–∫–∏—Ä—É–µ–º –±–æ–Ω—É—Å—ã –µ—Å–ª–∏:
    # 1. has_unrequested_processing (–Ω–µ–∑–∞–ø—Ä–æ—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞)
    # 2. critical_numeric_mismatch (–∫—Ä–∏—Ç–∏—á–Ω–æ–µ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤/–≤–µ—Å–∞)
    # 3. has_extra_products (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã —Ç–æ–π –∂–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏) [v5.6]
    if total_search_words <= 2 and has_full_coverage:
        if penalty < 0.5 and not has_unrequested_processing and not critical_numeric_mismatch and not has_extra_products:
            full_coverage_bonus = 0.15
            bonus += full_coverage_bonus
            logger.debug(f"‚úÖ Full coverage bonus: +{full_coverage_bonus:.2f}")
        elif has_unrequested_processing:
            logger.info(f"‚ö†Ô∏è Full coverage bonus blocked due to unrequested processing")
        elif critical_numeric_mismatch:
            logger.info(f"‚ö†Ô∏è Full coverage bonus blocked due to critical numeric mismatch")
        elif has_extra_products:
            logger.info(f"‚ö†Ô∏è Full coverage bonus blocked due to extra products in same category")
    
    exact_ratio = exact_matches / total_search_words
    if exact_ratio >= 0.5:
        if penalty < 0.5 and not has_unrequested_processing and not critical_numeric_mismatch and not has_extra_products:
            exact_match_bonus = exact_ratio * 0.1
            bonus += exact_match_bonus
            logger.debug(f"‚úÖ Exact ratio bonus: +{exact_match_bonus:.2f}")
        elif has_unrequested_processing:
            logger.info(f"‚ö†Ô∏è Exact ratio bonus blocked due to unrequested processing")
        elif critical_numeric_mismatch:
            logger.info(f"‚ö†Ô∏è Exact ratio bonus blocked due to critical numeric mismatch")
        elif has_extra_products:
            logger.info(f"‚ö†Ô∏è Exact ratio bonus blocked due to extra products in same category")
    
    # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –ø—Ä–∏ penalty < 0.3
    if has_full_coverage and penalty < 0.3:
        min_score_for_full_coverage = 0.7
        if (base_score + bonus - penalty) < min_score_for_full_coverage:
            coverage_adjustment = min_score_for_full_coverage - (base_score + bonus - penalty)
            bonus += coverage_adjustment
            logger.debug(f"‚úÖ Coverage floor: +{coverage_adjustment:.2f}")
    
    final_score = base_score + bonus - penalty
    final_score = max(0.0, min(1.0, final_score))
    final_score = round(final_score, 3)
    
    is_exact = (exact_matches >= total_search_words or 
               (final_score >= 0.95 and exact_matches + fuzzy_matches >= total_search_words))
    
    logger.info(f"üìä Score breakdown v5.7: base={base_score:.3f}, bonus={bonus:.3f}, penalty={penalty:.3f} (extra_products={extra_products_penalty if extra_products_info['has_extra'] else 0.0:.2f}, numeric={numeric_penalty:.3f}), reverse_coverage={reverse_coverage_ratio:.2f}, final={final_score:.3f}")
    
    return final_score, is_exact

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è lsd_config_id –ø–æ –∏–º–µ–Ω–∏ –∏–∑ –ë–î
async def get_lsd_id_by_name(lsd_name: str) -> Optional[int]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ ID –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î –ø–æ –∏–º–µ–Ω–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(LSDConfig.id).where(LSDConfig.name == lsd_name)
            )
            lsd_id = result.scalar_one_or_none()
            
            if lsd_id:
                logger.debug(f"üì¶ LSD mapping: '{lsd_name}' -> ID {lsd_id}")
            else:
                logger.warning(f"‚ö†Ô∏è LSD '{lsd_name}' not found in database")
            
            return lsd_id
            
    except Exception as e:
        logger.error(f"‚ùå Error getting LSD ID for '{lsd_name}': {e}")
        return None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan event handler"""
    global background_task

    # Startup
    # –û–¢–ö–õ–Æ–ß–ï–ù–û: –§–æ–Ω–æ–≤—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–∫–∞–∑–æ–≤ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ Order-service
    # Order-service —É–ø—Ä–∞–≤–ª—è–µ—Ç –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –∑–∞–∫–∞–∑–∞ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç RPA-service —á–µ—Ä–µ–∑ API
    # logger.info("üöÄ Starting background order monitoring...")

    # –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–∏—Å—à–∏—Ö –±—Ä–∞—É–∑–µ—Ä–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    if not os.environ.get('_RPA_SERVICE_STARTED'):
        logger.info("üöÄ RPA Service starting...")

        try:
            from cleanup_browsers import cleanup_all_browsers
            killed_count = cleanup_all_browsers(max_age_hours=1)
            if killed_count > 0:
                logger.warning(f"üßπ Cleaned up {killed_count} orphaned browser processes on startup")
        except Exception as e:
            logger.error(f"‚ùå Failed to cleanup browsers on startup: {e}")

        logger.info("üöÄ RPA Service started (background monitoring disabled)")
        os.environ['_RPA_SERVICE_STARTED'] = '1'
    else:
        logger.debug("‚ôªÔ∏è RPA Service reloaded (skipping startup log)")

    yield

    # Shutdown
    logger.info("üõë Shutting down RPA service...")

    # Cleanup –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ - —É–±–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –±—Ä–∞—É–∑–µ—Ä—ã
    try:
        from cleanup_browsers import cleanup_all_browsers
        killed_count = cleanup_all_browsers(max_age_hours=0)  # –£–±–∏—Ç—å –≤—Å–µ automation –±—Ä–∞—É–∑–µ—Ä—ã
        if killed_count > 0:
            logger.info(f"üßπ Cleaned up {killed_count} browser processes on shutdown")
    except Exception as e:
        logger.error(f"‚ùå Failed to cleanup browsers on shutdown: {e}")
    if background_task:
        background_task.cancel()
        try:
            await background_task
        except asyncio.CancelledError:
            pass

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è SMS –∫–æ–¥–æ–≤ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ë–î

app = FastAPI(
    title="Korzinka RPA Service", 
    description="RPA —Å–µ—Ä–≤–∏—Å —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Selenium",
    version="3.0.0",
    lifespan=lifespan
)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã - –ò–°–ü–û–õ–¨–ó–£–ï–ú –ì–õ–û–ë–ê–õ–¨–ù–£–Æ –ù–ê–°–¢–†–û–ô–ö–£ HEADLESS
active_sessions: Dict[str, Any] = {}
telegram_callbacks: Dict[str, Dict[str, Any]] = {}
success_notifications_sent: Dict[int, Dict[str, Any]] = {}

# API –º–æ–¥–µ–ª–∏
class BrowseRequest(BaseModel):
    telegram_id: int
    lsd_name: str
    auto_close_timeout: int = 300
    use_selenium: bool = True

class AuthRequest(BaseModel):
    telegram_id: int
    lsd_name: str

class SMSCodeRequest(BaseModel):
    session_id: str
    sms_code: str

class ProductSearchRequest(BaseModel):
    telegram_id: int
    lsd_name: str
    products: List[Dict[str, Any]]

class ProductSearchResponse(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    message: Optional[str] = None

@app.get("/health")
async def health():
    return {
        "status": "healthy",
        "service": "rpa-service-selenium",
        "active_sessions": len(active_sessions),
        "browser_profile": profile_manager.default_profile,
        "version": "3.0.0 - Full Selenium Integration"
    }


@app.get("/profiles/check/{telegram_id}")
async def check_user_profiles(telegram_id: int):
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –õ–°–î.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –õ–°–î —Å/–±–µ–∑ –ø—Ä–æ—Ñ–∏–ª–µ–π.
    """
    try:
        from pathlib import Path

        logger.info(f"üîç Checking persistent profiles for user {telegram_id}")

        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –õ–°–î –∏–∑ –ë–î
        async for db in get_async_session():
            from sqlalchemy import select
            result = await db.execute(
                select(LSDConfig).where(
                    LSDConfig.is_active == True
                ).order_by(LSDConfig.display_name)
            )
            active_lsds = result.scalars().all()

            profiles_status = []
            lsds_with_profiles = []
            lsds_without_profiles = []

            for lsd in active_lsds:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è
                profile_dir = Path(__file__).parent / "browser_profiles" / f"user_{telegram_id}_lsd_{lsd.name}"
                cookies_db_path = profile_dir / "Default" / "Cookies"

                has_profile = cookies_db_path.exists()

                lsd_info = {
                    "lsd_name": lsd.name,
                    "display_name": lsd.display_name,
                    "has_profile": has_profile
                }

                profiles_status.append(lsd_info)

                if has_profile:
                    lsds_with_profiles.append(lsd.display_name)
                else:
                    lsds_without_profiles.append(lsd.display_name)

            logger.info(f"‚úÖ Profile check complete: {len(lsds_with_profiles)}/{len(active_lsds)} LSDs have profiles")

            return {
                "success": True,
                "data": {
                    "telegram_id": telegram_id,
                    "total_lsds": len(active_lsds),
                    "with_profiles": len(lsds_with_profiles),
                    "without_profiles": len(lsds_without_profiles),
                    "lsds_with_profiles": lsds_with_profiles,
                    "lsds_without_profiles": lsds_without_profiles,
                    "profiles_status": profiles_status
                }
            }
    except Exception as e:
        logger.error(f"‚ùå Error checking profiles: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/search/products")
async def search_products(request: ProductSearchRequest):
    """–ü–æ–∏—Å–∫ —Ç–æ–≤–∞—Ä–æ–≤ –≤ –õ–°–î —á–µ—Ä–µ–∑ Selenium RPA"""
    logger.info(f"üîç Starting Selenium product search for {request.lsd_name} (user: {request.telegram_id})")
    logger.info(f"üì¶ Products to search: {len(request.products)}")
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—É–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –õ–°–î
        cookies_data = await get_user_cookies(request.telegram_id, request.lsd_name)
        if not cookies_data:
            raise HTTPException(
                status_code=400,
                detail=f"–ö—É–∫–∏ –¥–ª—è {request.lsd_name} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é."
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –õ–°–î
        lsd_config = await get_lsd_config(request.lsd_name)
        if not lsd_config:
            raise HTTPException(
                status_code=404,
                detail=f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è {request.lsd_name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ–∏—Å–∫–∞ –¥–ª—è –õ–°–î
        search_config = lsd_config.search_config_rpa
        if not search_config:
            raise HTTPException(
                status_code=400,
                detail=f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–ª—è {request.lsd_name}"
            )
        
        logger.info(f"üìã Using enhanced search config for {lsd_config.display_name}")

        # –ö–†–ò–¢–ò–ß–ù–û: –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Å–ª–æ—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–Ω–æ–º —Å–µ–º–∞—Ñ–æ—Ä–µ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞
        logger.info(f"üîí [{lsd_config.display_name}] Waiting for browser slot (limit: {settings.max_concurrent_browsers})...")
        async with browser_semaphore:
            acquired_slots = browser_semaphore._value
            logger.info(f"‚úÖ [{lsd_config.display_name}] Browser slot acquired (free slots: {acquired_slots}/{settings.max_concurrent_browsers})")

            # –ö–†–ò–¢–ò–ß–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –≤ 5 –º–∏–Ω—É—Ç (300 —Å–µ–∫) –¥–ª—è –ø–æ–∏—Å–∫–∞
            # –ï—Å–ª–∏ –ø–æ–∏—Å–∫ –Ω–µ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –∑–∞ 5 –º–∏–Ω—É—Ç - —É–±–∏–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä, –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Å–ª–æ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —á–∞—Å—Ç–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            search_timeout_seconds = 300  # 5 –º–∏–Ω—É—Ç
            logger.info(f"‚è±Ô∏è [{lsd_config.display_name}] Search timeout set to {search_timeout_seconds}s (5 minutes)")

            try:
                # –í–´–ü–û–õ–ù–Ø–ï–ú SELENIUM –ü–û–ò–°–ö –° CDP –ü–†–ï–î–ó–ê–ì–†–£–ó–ö–û–ô –ö–£–ö + localStorage + sessionStorage
                search_results = await asyncio.wait_for(
                    perform_product_search_with_cdp_cookies(
                        lsd_config=lsd_config,
                        search_config=search_config,
                        cookies=cookies_data['cookies'],
                        local_storage=cookies_data.get('localStorage', {}),
                        session_storage=cookies_data.get('sessionStorage', {}),
                        products=request.products,
                        telegram_id=request.telegram_id
                    ),
                    timeout=search_timeout_seconds
                )
            except asyncio.TimeoutError:
                logger.error(f"‚è∞ [{lsd_config.display_name}] TIMEOUT! Search exceeded {search_timeout_seconds}s (5 minutes)")
                logger.error(f"üî™ Browser was force-closed by finally block in perform_product_search_with_cdp_cookies()")
                logger.error(f"üíæ Partial results were saved to database before cleanup")
                logger.error(f"üîì Browser slot will be released automatically")
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ - —á–∞—Å—Ç–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —É–∂–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ë–î CancelledError handler
                search_results = []
            except asyncio.CancelledError:
                # –≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –µ—Å–ª–∏ —Å–∞–º search_products –≤—ã–∑–æ–≤ –±—É–¥–µ—Ç –æ—Ç–º–µ–Ω–µ–Ω
                logger.error(f"üö´ [{lsd_config.display_name}] Search was CANCELLED externally")
                logger.error(f"üíæ Partial results should have been saved in CancelledError handler")
                search_results = []

            logger.info(f"üîì [{lsd_config.display_name}] Browser slot released")
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        product_search_results = []
        for result in search_results:
            if result.found_items:
                for item in result.found_items:
                    # –°–æ–∑–¥–∞–µ–º ProductSearchResult –∏–∑ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                    psr = ProductSearchResult(
                        order_item_id=result.order_item_id,
                        product_name=result.product_name,
                        found_name=item.get('name', result.product_name),
                        price=item.get('price', 0.0),
                        unit=item.get('unit', '—à—Ç'),
                        quantity=item.get('quantity', 1.0),  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                        available_stock=1 if item.get('available', True) else 0,
                        product_url=item.get('url'),
                        lsd_name=request.lsd_name,
                        search_position=len(product_search_results) + 1,
                        min_order_amount=item.get('min_order_amount', 0.0),
                        delivery_cost=item.get('delivery_cost', 0.0),
                        delivery_cost_model=item.get('delivery_cost_model')  # –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å
                    )
                    product_search_results.append(psr)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ lsd_stocks
        saved_count = await save_search_results_to_db(
            search_results=product_search_results,
            lsd_config_id=lsd_config.id,
            telegram_id=request.telegram_id
        )
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º failed_products (—Ç–æ–≤–∞—Ä—ã –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤)
        searched_item_ids = {product['order_item_id'] for product in request.products}
        found_item_ids = {result.order_item_id for result in product_search_results}
        failed_products = list(searched_item_ids - found_item_ids)
        
        logger.info(f"‚úÖ Selenium product search completed: {len(product_search_results)} results, {saved_count} saved to DB")
        if failed_products:
            logger.warning(f"‚ö†Ô∏è {len(failed_products)} products not found: {failed_products}")
        
        return {
            "success": True,
            "data": {
                "method": "selenium",
                "lsd_name": request.lsd_name,
                "display_name": lsd_config.display_name,
                "products_searched": len(request.products),
                "results_found": len(product_search_results),
                "results_saved": saved_count,
                "failed_products": failed_products,  # NEW: —Å–ø–∏—Å–æ–∫ order_item_id –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                "results": [
                    {
                        "order_item_id": result.order_item_id,
                        "product_name": result.product_name,
                        "found_name": result.found_name,
                        "price": result.price,
                        "unit": result.unit,
                        "product_url": result.product_url,
                        "search_position": result.search_position
                    }
                    for result in product_search_results[:20]  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 20
                ]
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Error in Selenium product search: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

async def perform_product_search_with_cdp_cookies(
    lsd_config,
    search_config: dict,
    cookies: list,
    local_storage: dict,
    session_storage: dict,
    products: List[Dict[str, Any]],
    telegram_id: int
) -> List[ProductSearchResult]:
    """
    –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è –±—Ä–∞—É–∑–µ—Ä–∞ (–∫–∞–∫ /browse)
    –ö—É–∫–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ SQLite –±–∞–∑–µ Chrome - –∏–Ω—ä–µ–∫—Ü–∏—è –Ω–µ –Ω—É–∂–Ω–∞, –±—Ä–∞—É–∑–µ—Ä –∑–∞–≥—Ä—É–∂–∞–µ—Ç –∏—Ö –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    """

    logger.info(f"üîç Starting product search with PERSISTENT PROFILE for {len(products)} products on {lsd_config.display_name}")

    results = []
    failed_items = []  # –°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è retry
    driver = None
    profile_dir = None

    try:
        # –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–º—É –ø—Ä–æ—Ñ–∏–ª—é (–∫–∞–∫ –≤ /browse)
        from pathlib import Path
        profile_dir = Path(__file__).parent / "browser_profiles" / f"user_{telegram_id}_lsd_{lsd_config.name}"

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–∞ –ª–∏ –∏–Ω—ä–µ–∫—Ü–∏—è –∫—É–∫–æ–≤ –∏–∑ JSON —Ñ–∞–π–ª–∞ (–¥–ª—è –õ–°–î —Å cdp_enabled)
        rpa_config = lsd_config.rpa_config or {}
        cdp_enabled = rpa_config.get('cdp_enabled', False)

        # –î–ª—è CDP –±—Ä–∞—É–∑–µ—Ä–∞ (–°–∞–º–æ–∫–∞—Ç, –Ø–Ω–¥–µ–∫—Å –õ–∞–≤–∫–∞) –ø—Ä–æ—Ñ–∏–ª—å –ù–ï –Ω—É–∂–µ–Ω - –∫—É–∫–∏ –∏–Ω–∂–µ–∫—Ç–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ CDP
        # –î–ª—è –æ–±—ã—á–Ω–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞ (–ü–µ—Ä–µ–∫—Ä—ë—Å—Ç–æ–∫) –ø—Ä–æ—Ñ–∏–ª—å –û–ë–Ø–ó–ê–¢–ï–õ–ï–ù - –∫—É–∫–∏ –≤ SQLite
        if cdp_enabled:
            logger.info(f"üîß cdp_enabled=true: CDP browser mode (NO persistent profile needed)")
            logger.info(f"üíâ Cookies will be injected from JSON via CDP protocol")
            profile_exists = False  # –ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è CDP –±—Ä–∞—É–∑–µ—Ä–∞
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞
            profile_exists = (profile_dir / "Default" / "Cookies").exists()

            if profile_exists:
                logger.info(f"üìÅ Using existing persistent profile: {profile_dir}")
                logger.info(f"‚ôªÔ∏è cdp_enabled=false: Using cookies from SQLite DB - no injection needed")
            else:
                logger.info(f"üìÅ Profile doesn't exist yet: {profile_dir}")
                logger.info(f"‚ö†Ô∏è User needs to authenticate first via /auth command")
                logger.warning(f"‚ö†Ô∏è Skipping search - no authenticated session available")
                return []  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫, –µ—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—è –Ω–µ—Ç

        # –ö–†–ò–¢–ò–ß–ù–û: –£–±–∏–≤–∞–µ–º –í–°–ï Chrome –ø—Ä–æ—Ü–µ—Å—Å—ã —Å —ç—Ç–∏–º –ø—Ä–æ—Ñ–∏–ª–µ–º –ü–ï–†–ï–î –æ—Ç–∫—Ä—ã—Ç–∏–µ–º
        # (–¢–û–õ–¨–ö–û –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞ —Å persistent profile)
        # CDP –±—Ä–∞—É–∑–µ—Ä –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å, –ø–æ—ç—Ç–æ–º—É –Ω–µ –Ω—É–∂–Ω–æ —É–±–∏–≤–∞—Ç—å –ø—Ä–æ—Ü–µ—Å—Å—ã
        if not cdp_enabled:
            logger.info(f"üî™ Killing any existing Chrome processes with this profile...")
            import subprocess
            profile_dir_str = str(profile_dir)

            try:
                result = subprocess.run(
                    ['ps', 'aux'],
                    capture_output=True,
                    text=True,
                    timeout=5
                )

                killed_count = 0
                for line in result.stdout.split('\n'):
                    if 'Chrome' in line and profile_dir_str in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            try:
                                pid = int(parts[1])
                                subprocess.run(['kill', '-9', str(pid)], timeout=2)
                                killed_count += 1
                                logger.debug(f"   Killed Chrome process: {pid}")
                            except (ValueError, subprocess.TimeoutExpired):
                                continue

                if killed_count > 0:
                    logger.info(f"‚úÖ Killed {killed_count} Chrome processes")
                    import time
                    time.sleep(1)  # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ cleanup
                else:
                    logger.info(f"‚ÑπÔ∏è No Chrome processes found (good!)")

            except Exception as kill_error:
                logger.warning(f"‚ö†Ô∏è Failed to kill Chrome processes: {kill_error}")

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—ã–π URL
        base_url = lsd_config.base_url

        # –ß–∏—Ç–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        block_media = search_config.get('block_media', True)
        logger.info(f"üìä block_media from config: {block_media}")

        # –î–õ–Ø –ü–û–ò–°–ö–ê –í–°–ï–ì–î–ê –∏—Å–ø–æ–ª—å–∑—É–µ–º SimpleUndetectedBrowser —Å persistent profile
        # CDP –Ω—É–∂–µ–Ω –¢–û–õ–¨–ö–û –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ (–≤ RPA flow), –ù–ï –ø—Ä–∏ –ø–æ–∏—Å–∫–µ!
        # –ö—É–∫–∏ —É–∂–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ SQLite –ø—Ä–æ—Ñ–∏–ª—è –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏

        logger.info(f"üîß Opening browser with persistent profile for search")
        logger.info(f"üí° Cookies already in SQLite with Chrome encryption")

        from simple_browser_manager import SimpleUndetectedBrowser

        # –û—Ç–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø—Ä–æ—Ñ–∏–ª–µ–º
        # Cookies —É–∂–µ —Ç–∞–º, –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã Chrome Keychain, –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ —Å–µ—Å—Å–∏–∏
        driver = SimpleUndetectedBrowser.create_simple_browser(
            headless=settings.rpa_headless,
            user_data_dir=str(profile_dir),
            block_media=block_media
        )
        cdp_manager = None  # –ù–µ—Ç CDP –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞

        logger.info(f"‚úÖ Browser opened with persistent profile")

        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è - –∫—É–∫–∏ —É–∂–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ
        logger.info(f"üìç Navigating to {base_url} to initialize session...")
        driver.get(base_url)

        # –î–∞—ë–º —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –∫—É–∫–æ–≤
        # –ü–µ—Ä–µ–∫—Ä—ë—Å—Ç–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–µ—Å—Å–∏–∏
        init_wait = 5 if lsd_config.name == "perek" else 1
        logger.info(f"‚è≥ Waiting {init_wait}s for page to load with cookies...")
        await asyncio.sleep(init_wait)

        logger.info(f"‚úÖ Session initialized - cookies loaded from persistent profile")

        # ============ –ü–†–û–í–ï–†–ö–ê –ê–í–¢–û–†–ò–ó–ê–¶–ò–ò ============
        # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –î–û –Ω–∞—á–∞–ª–∞ –ø–æ–∏—Å–∫–∞ –¥–ª—è –í–°–ï–• LSD
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∏–∑ RPA flow (wait_for –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞)
        # –≠—Ç–∏ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç—ã –ê–í–¢–û–†–ò–ó–û–í–ê–ù–ù–û–ì–û –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (ProfileButton/ProfileCard)
        # –ï—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏–º —ç—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã - –∑–Ω–∞—á–∏—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ï–°–¢–¨
        # –ï—Å–ª–∏ –ù–ï –Ω–∞—Ö–æ–¥–∏–º - –∑–Ω–∞—á–∏—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ù–ï–¢
        auth_valid = True  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤–∞–ª–∏–¥–Ω–æ–π

        try:
            # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∏–∑ RPA config (–ø–µ—Ä–≤—ã–π —à–∞–≥ wait_for)
            auth_check_selectors = []
            if rpa_config and 'steps' in rpa_config and len(rpa_config['steps']) > 0:
                first_step = rpa_config['steps'][0]
                if 'wait_for' in first_step and 'selectors' in first_step['wait_for']:
                    auth_check_selectors = first_step['wait_for']['selectors']
                    logger.info(f"üîç Using {len(auth_check_selectors)} auth check selectors from RPA flow")

            if not auth_check_selectors:
                logger.warning(f"‚ö†Ô∏è No auth check selectors found in RPA config - skipping auth validation")
            else:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø—Ä–æ—Ñ–∏–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                # –≠—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã (ProfileButton, ProfileCard) –ø–æ—è–≤–ª—è—é—Ç—Å—è –¢–û–õ–¨–ö–û —É –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                found_profile_elements = []
                from selenium.webdriver.common.by import By
                from selenium.common.exceptions import NoSuchElementException

                for selector in auth_check_selectors:
                    try:
                        # XPath —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å //
                        if selector.startswith('//'):
                            elements = driver.find_elements(By.XPATH, selector)
                        else:
                            elements = driver.find_elements(By.CSS_SELECTOR, selector)

                        if elements:
                            found_profile_elements.append(selector)
                            logger.info(f"‚úÖ Found profile element: {selector}")
                    except Exception as selector_error:
                        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–æ–∏—Å–∫–∞ - —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–æ—Å—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω
                        pass

                # –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –õ–û–ì–ò–ö–ê: –ï—Å–ª–∏ –ù–ï –Ω–∞—à–ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ—Ñ–∏–ª—è - –∑–Ω–∞—á–∏—Ç –ù–ï–¢ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                if not found_profile_elements:
                    auth_valid = False
                    logger.error(f"‚ùå AUTHENTICATION FAILED for {lsd_config.display_name}!")
                    logger.error(f"   Profile elements NOT found on page - user is not authenticated")
                    logger.error(f"   Expected to find one of these selectors:")
                    for elem in auth_check_selectors:
                        logger.error(f"     - {elem}")
                    logger.error(f"   User needs to re-authenticate - cookies may be expired or invalid")

                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                    try:
                        debug_dir = Path(__file__).parent / "debug_html"
                        debug_dir.mkdir(exist_ok=True)
                        debug_file = debug_dir / f"{lsd_config.name}_auth_failed_{telegram_id}.html"
                        with open(debug_file, 'w', encoding='utf-8') as f:
                            f.write(driver.page_source)
                        logger.info(f"üíæ Saved HTML dump to {debug_file}")
                    except Exception as save_error:
                        logger.warning(f"‚ö†Ô∏è Could not save HTML dump: {save_error}")

                    # –ü—Ä–µ—Ä—ã–≤–∞–µ–º –ø–æ–∏—Å–∫ - –Ω–µ—Ç —Å–º—ã—Å–ª–∞ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                    logger.error(f"‚ö†Ô∏è Skipping search - user needs to re-authenticate via /auth {lsd_config.name}")
                    logger.error(f"üîç DEBUG: About to return [] with auth_valid={auth_valid}, driver={driver is not None}")
                    return []  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫

                else:
                    logger.info(f"‚úÖ Authentication valid for {lsd_config.display_name} - found {len(found_profile_elements)} profile elements")

        except Exception as auth_check_error:
            logger.warning(f"‚ö†Ô∏è Could not verify authentication: {auth_check_error}")
            # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∏—Å–∫ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ (fallback)

        # ============ –ü–†–û–í–ï–†–ö–ê –ë–õ–û–ö–ò–†–û–í–ö–ò ============
        from block_detector import check_if_blocked, get_html_snippet
        from lsd_blocks_db import save_lsd_block
        import asyncpg

        is_blocked, block_type, http_status = check_if_blocked(driver, base_url)

        if is_blocked:
            logger.error(f"üö´ LSD {lsd_config.display_name} is BLOCKED by {block_type}!")
            logger.error(f"   HTTP Status: {http_status}")
            logger.error(f"   URL: {driver.current_url}")

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ –≤ –ë–î
            try:
                async for db in get_async_session():
                    html_snippet = get_html_snippet(driver, 1000)

                    await save_lsd_block(
                        conn=db.connection(),
                        lsd_config_id=lsd_config.id,
                        block_type=block_type,
                        blocked_url=driver.current_url,
                        order_id=order_id if 'order_id' in locals() else None,
                        user_id=telegram_id,
                        http_status=http_status,
                        block_reason=f"Blocked during search: {block_type}",
                        html_snippet=html_snippet
                    )

                    logger.info(f"üíæ Block info saved to lsd_blocks table")
            except Exception as db_error:
                logger.error(f"‚ùå Failed to save block info: {db_error}")

            # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç - –ù–ï –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∏—Å–∫
            logger.warning(f"‚ö†Ô∏è Skipping all searches for {lsd_config.display_name} due to block")
            return []  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        else:
            logger.info(f"‚úÖ No block detected - proceeding with search")
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –£–°–õ–û–í–ò–ô –î–û–°–¢–ê–í–ö–ò (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–æ–Ω—Ñ–∏–≥–µ) ===
        delivery_info = None
        delivery_ranges_config = search_config.get('delivery_ranges', {})
        if delivery_ranges_config and delivery_ranges_config.get('enabled', False):
            logger.info(f"üì¶ delivery_ranges enabled - extracting delivery conditions...")
            try:
                # –ù–ï –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ base_url - —ç—Ç–æ –¥–µ–ª–∞–µ—Ç action "navigate" –≤–Ω—É—Ç—Ä–∏ extract_delivery_ranges
                # trigger.actions[0] –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å navigate –Ω–∞ –Ω—É–∂–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
                current_url = driver.current_url
                logger.info(f"üìã Current URL before delivery extraction: {current_url}")
                logger.info(f"‚û°Ô∏è Trigger actions will handle navigation")
                
                # Trigger actions –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ extract_delivery_ranges
                # –£–¥–∞–ª–µ–Ω–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ: –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ–º trigger actions –∑–¥–µ—Å—å
                logger.info(f"‚û°Ô∏è extract_delivery_ranges() will handle all trigger actions")
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –¥–æ—Å—Ç–∞–≤–∫–∏
                from selenium_product_search import extract_delivery_ranges, parse_delivery_ranges_to_model
                
                delivery_ranges, extracted_min_order, is_delivery_available = await extract_delivery_ranges(
                    driver=driver,
                    delivery_config=delivery_ranges_config,
                    telegram_id=telegram_id,  # –ü–µ—Ä–µ–¥–∞–µ–º –¥–ª—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤
                    base_url=lsd_config.base_url  # –ü–µ—Ä–µ–¥–∞–µ–º –¥–ª—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ {base_url}
                )
                
                # === –ü–†–û–í–ï–†–ö–ê: –î–û–°–¢–ê–í–ö–ê –ù–ï–î–û–°–¢–£–ü–ù–ê ===
                if not is_delivery_available:
                    logger.warning(f"üö´ Delivery UNAVAILABLE for {lsd_config.display_name}")
                    logger.warning(f"‚ö†Ô∏è Skipping all searches for this LSD due to delivery unavailability")
                    logger.info(f"üíæ Cookies will be saved automatically in persistent profile")
                    return []  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                
                if delivery_ranges:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–æ–¥–µ–ª—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
                    delivery_info = parse_delivery_ranges_to_model(delivery_ranges, extracted_min_order)
                    logger.info(f"‚úÖ Extracted delivery info: {len(delivery_ranges)} ranges")
                    if extracted_min_order is not None:
                        logger.info(f"üí∞ Extracted min_order_amount: {extracted_min_order}‚ÇΩ")
                    logger.debug(f"üìä Delivery model: {delivery_info}")
                else:
                    logger.warning(f"‚ö†Ô∏è No delivery ranges extracted")

            except Exception as e:
                logger.error(f"‚ùå Error extracting delivery_ranges: {e}")
                import traceback
                logger.debug(traceback.format_exc())
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ delivery_info
        else:
            # –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
            if 'delivery_ranges' in search_config:
                enabled_status = search_config['delivery_ranges'].get('enabled', 'NOT SET')
                logger.info(f"üìù delivery_ranges present but not enabled (enabled={enabled_status}), skipping")
            else:
                logger.info(f"üìù No delivery_ranges in config, skipping delivery info extraction")

        # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É –ø–æ–∏—Å–∫–æ–≤—ã–º–∏ –∑–∞–ø—Ä–æ—Å–∞–º–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–∞–Ω—Ç–∏–±–æ—Ç –∑–∞—â–∏—Ç–∞)
        search_delay_seconds = float(search_config.get('search_delay_seconds', 1.0))
        logger.info(f"‚è±Ô∏è Search delay configured: {search_delay_seconds}s between queries")

        # –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ –ü–û–ò–°–ö–ê –ü–û –ü–†–û–î–£–ö–¢–ê–ú
        for i, product in enumerate(products, 1):
            product_name = product['product_name']
            is_alternative_group = product.get('is_alternative_group', False)
            alternatives = product.get('alternatives', [])
            
            logger.info(f"\n{'='*60}")
            logger.info(f"üîé [{i}/{len(products)}] Processing product: {product_name}")
            
            if is_alternative_group and alternatives:
                logger.info(f"üîÑ This is an alternative group with {len(alternatives)} alternatives: {alternatives}")
                logger.info(f"üëâ Will search: '{product_name}' + {alternatives}")
            else:
                logger.info(f"üëâ Single product search (no alternatives)")
            
            # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞
            search_variants = [{
                'name': product_name,
                'is_alternative': False,
                'alternative_for': None
            }]
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã
            if is_alternative_group and alternatives:
                for alt_name in alternatives:
                    search_variants.append({
                        'name': alt_name,
                        'is_alternative': True,
                        'alternative_for': product_name
                    })
            
            logger.info(f"üìã Total search variants: {len(search_variants)}")
            
            # –ò—â–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            for variant_idx, variant in enumerate(search_variants, 1):
                variant_name = variant['name']
                is_alt = variant['is_alternative']
                alt_for = variant['alternative_for']
                
                alt_marker = "üîÑ" if is_alt else "üîé"
                logger.info(f"\n{alt_marker} [{i}.{variant_idx}] Searching: '{variant_name}'" + 
                          (f" (alternative for '{alt_for}')" if is_alt else ""))
                
                try:
                    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                    result = ProductSearchResult(
                        order_item_id=product['order_item_id'],
                        product_name=variant_name,
                        search_query=variant_name,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º product_name –¥–ª—è –ø–æ–∏—Å–∫–∞
                        is_alternative=is_alt,
                        alternative_for=alt_for
                    )
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ –¥–ª—è —ç—Ç–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ —á–µ—Ä–µ–∑ CDP –¥—Ä–∞–π–≤–µ—Ä
                    search_success = await search_single_product_cdp(
                        driver=driver,
                        lsd_config=lsd_config,
                        search_config=search_config,
                        product={
                            **product,  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                            'product_name': variant_name  # –ü–æ–¥–º–µ–Ω—è–µ–º –∏–º—è –¥–ª—è –ø–æ–∏—Å–∫–∞
                        },
                        result=result,
                        delivery_info=delivery_info
                    )
                    
                    if search_success:
                        found_count = len(result.found_items)
                        logger.info(f"‚úÖ [{i}.{variant_idx}] Found {found_count} items for '{variant_name}'")
                    else:
                        logger.warning(f"‚ö†Ô∏è [{i}.{variant_idx}] No items found for '{variant_name}', adding to retry queue")
                        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –¥–ª—è retry
                        failed_items.append({
                            'product': product,
                            'variant': variant,
                            'result': result
                        })
                    
                    results.append(result)
                    
                except Exception as variant_error:
                    logger.error(f"‚ùå [{i}.{variant_idx}] Error searching '{variant_name}': {variant_error}")
                    
                    # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å –æ—à–∏–±–∫–æ–π
                    error_result = ProductSearchResult(
                        order_item_id=product['order_item_id'],
                        product_name=variant_name,
                        search_query=product['original_text'],
                        is_alternative=is_alt,
                        alternative_for=alt_for
                    )
                    error_result.search_successful = False
                    error_result.error_message = str(variant_error)
                    results.append(error_result)
                
                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ (–∞–Ω—Ç–∏–±–æ—Ç –∑–∞—â–∏—Ç–∞ –∏–∑ search_config_rpa)
                if variant_idx < len(search_variants):
                    logger.debug(f"‚è±Ô∏è Pausing {search_delay_seconds}s before next variant (antibot protection)")
                    await asyncio.sleep(search_delay_seconds)
            
            logger.info(f"{'='*60}\n")

            # –ü–†–ò–ú–ï–ß–ê–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ù–ï –ù–£–ñ–ù–ê –≤ persistent profile —Ä–µ–∂–∏–º–µ
            # –ö—É–∫–∏ —É–∂–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ SQLite –±–∞–∑–µ Chrome –∏ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
            # –ù–µ—Ç CDP –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ - –æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç SimpleUndetectedBrowser 
            
            # –ê–ù–¢–ò–ë–û–¢ –ó–ê–©–ò–¢–ê: –ü–∞—É–∑–∞ –º–µ–∂–¥—É –ø—Ä–æ–¥—É–∫—Ç–∞–º–∏ (–∏–∑ search_config_rpa)
            if i < len(products):
                logger.info(f"‚è±Ô∏è Antibot pause: waiting {search_delay_seconds}s before next product...")
                await asyncio.sleep(search_delay_seconds)
        
        logger.info(f"üéâ CDP product search completed: {len(results)} products processed")
        
        # === RETRY LOGIC ===
        if failed_items:
            logger.info(f"\n{'='*60}")
            logger.info(f"üîÑ RETRY PHASE: {len(failed_items)} items failed on first attempt")
            logger.info(f"üìã Failed items: {[item['variant']['name'] for item in failed_items]}")
            
            max_retries = 3
            retry_delay = search_delay_seconds  # –∑–∞–¥–µ—Ä–∂–∫–∞ –∏–∑ search_config_rpa
            
            for retry_attempt in range(1, max_retries + 1):
                if not failed_items:
                    break
                    
                logger.info(f"\nüîÑ Retry attempt {retry_attempt}/{max_retries} for {len(failed_items)} items")
                
                still_failed = []
                
                for item_data in failed_items:
                    product = item_data['product']
                    variant = item_data['variant']
                    result = item_data['result']
                    variant_name = variant['name']
                    
                    logger.info(f"üîÑ Retrying: '{variant_name}'")
                    
                    try:
                        # –ê–Ω—Ç–∏–±–æ—Ç –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ retry (—É–ø—Ä–∞–≤–ª—è–µ–º–∞—è —á–µ—Ä–µ–∑ .env)
                        logger.debug(f"‚è±Ô∏è Retry delay: {retry_delay}s (antibot protection)")
                        await asyncio.sleep(retry_delay)
                        
                        # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–∏—Å–∫–∞
                        search_success = await search_single_product_cdp(
                            driver=driver,
                            lsd_config=lsd_config,
                            search_config=search_config,
                            product={**product, 'product_name': variant_name},
                            result=result,
                            delivery_info=delivery_info
                        )
                        
                        if search_success:
                            found_count = len(result.found_items)
                            logger.info(f"‚úÖ Retry SUCCESS for '{variant_name}' - found {found_count} items")
                            # –†–µ–∑—É–ª—å—Ç–∞—Ç —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω –≤ result, –∫–æ—Ç–æ—Ä—ã–π —É–∂–µ –≤ results
                        else:
                            logger.warning(f"‚ö†Ô∏è Retry FAILED for '{variant_name}'")
                            still_failed.append(item_data)
                            
                    except Exception as retry_error:
                        logger.error(f"‚ùå Retry error for '{variant_name}': {retry_error}")
                        still_failed.append(item_data)
                
                failed_items = still_failed
                
                if failed_items and retry_attempt < max_retries:
                    logger.info(f"‚è≥ Waiting {retry_delay}s before next retry attempt...")
                    await asyncio.sleep(retry_delay)
            
            # –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            if failed_items:
                logger.warning(f"\n‚ùå {len(failed_items)} items FAILED after {max_retries} retries:")
                for item_data in failed_items:
                    logger.warning(f"   - {item_data['variant']['name']}")
            else:
                logger.info(f"\n‚úÖ All items found after retry attempts!")

            logger.info(f"{'='*60}\n")

        # üíæ Cookies –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ persistent profile –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –±—Ä–∞—É–∑–µ—Ä–∞
        logger.info(f"üíæ Cookies will be saved automatically in persistent profile on browser close")

        return results

    except asyncio.CancelledError:
        # –¢–∞–π–º–∞—É—Ç –æ—Ç asyncio.wait_for() - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —á–∞—Å—Ç–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        logger.warning(f"‚è∞ Search was CANCELLED (timeout) - saving partial results...")
        logger.warning(f"üíæ Found {len(results)} results before timeout")

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º results –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        product_search_results = []
        for result in results:
            if result.found_items:
                for item in result.found_items:
                    from models.product_search import ProductSearchResult as PSR
                    psr = PSR(
                        order_item_id=result.order_item_id,
                        product_name=result.product_name,
                        found_name=item.get('name', result.product_name),
                        price=item.get('price', 0.0),
                        unit=item.get('unit', '—à—Ç'),
                        quantity=item.get('quantity', 1.0),
                        available_stock=1 if item.get('available', True) else 0,
                        product_url=item.get('url'),
                        lsd_name=lsd_config.name,
                        search_position=len(product_search_results) + 1,
                        min_order_amount=item.get('min_order_amount', 0.0),
                        delivery_cost=item.get('delivery_cost', 0.0),
                        delivery_cost_model=item.get('delivery_cost_model')
                    )
                    product_search_results.append(psr)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —á–∞—Å—Ç–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –ë–î
        if product_search_results:
            try:
                saved_count = await save_search_results_to_db(
                    search_results=product_search_results,
                    lsd_config_id=lsd_config.id,
                    telegram_id=telegram_id
                )
                logger.info(f"‚úÖ Saved {saved_count} partial results to database before timeout cleanup")
            except Exception as save_error:
                logger.error(f"‚ùå Failed to save partial results: {save_error}")
        else:
            logger.warning(f"‚ö†Ô∏è No results to save (search timed out before finding anything)")

        # –ü–µ—Ä–µ-–≤—ã–∑—ã–≤–∞–µ–º CancelledError —á—Ç–æ–±—ã finally block –≤—ã–ø–æ–ª–Ω–∏–ª—Å—è –∏ –∑–∞–∫—Ä—ã–ª –±—Ä–∞—É–∑–µ—Ä
        raise

    except Exception as e:
        logger.error(f"‚ùå Critical error in CDP product search: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise

    finally:
        # –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ (–∑–∞–∫—Ä—ã—Ç–∏–µ –±—Ä–∞—É–∑–µ—Ä–∞)
        logger.info(f"üßπ Cleaning up browser resources...")
        logger.info(f"üîç DEBUG: Finally block - auth_valid in locals: {'auth_valid' in locals()}, value: {locals().get('auth_valid', 'NOT_SET')}, driver exists: {driver is not None if 'driver' in locals() else 'NO_DRIVER'}")

        # –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ CDP - –∏—Å–ø–æ–ª—å–∑—É–µ–º CDP cleanup
        if 'cdp_manager' in locals() and cdp_manager:
            try:
                logger.info(f"üßπ Cleaning up CDP browser...")
                cdp_manager.cleanup()
                logger.info(f"‚úÖ CDP cleanup completed (no persistent profile)")

                # –ö–†–ò–¢–ò–ß–ù–û: –ñ–¥—ë–º –∑–∞–∫—Ä—ã—Ç–∏—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ Chrome (–¥–ª—è —Å–µ–º–∞—Ñ–æ—Ä–∞)
                import time
                time.sleep(1.0)  # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ force-kill –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
                logger.info(f"‚è±Ô∏è Waited 1s for CDP cleanup")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up CDP browser: {cleanup_error}")

        # –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ persistent profile - –∑–∞–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä
        elif driver:
            try:
                # –ö–†–ò–¢–ò–ß–ù–û: –í–°–ï–ì–î–ê –≤—ã–∑—ã–≤–∞–µ–º driver.quit() –ø–µ—Ä–≤—ã–º –¥–µ–ª–æ–º
                # –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç auth_valid - —ç—Ç–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–ø–æ—Å–æ–± –∑–∞–∫—Ä—ã—Ç—å –±—Ä–∞—É–∑–µ—Ä
                logger.info(f"üßπ Closing browser (calling driver.quit())...")
                from simple_browser_manager import SimpleUndetectedBrowser

                try:
                    SimpleUndetectedBrowser.close_browser(driver)
                    logger.info(f"‚úÖ driver.quit() completed successfully")
                except Exception as quit_error:
                    logger.error(f"‚ùå driver.quit() failed: {quit_error}")
                    logger.error(f"üîç This means Chrome may still be running!")

                # –ü–æ—Å–ª–µ driver.quit() –ø—Ä–æ–≤–µ—Ä—è–µ–º auth_valid –¥–ª—è –¥–æ–ø. –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è
                auth_valid_flag = locals().get('auth_valid', True)
                logger.info(f"üîç auth_valid={auth_valid_flag}, profile cleanup={'SKIP (keep good cookies)' if auth_valid_flag else 'DELETE (prevent bad cookies)'}")

                if not auth_valid_flag and 'profile_dir' in locals() and profile_dir:
                    # –ï—Å–ª–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ–≤–∞–ª–∏–¥–Ω–∞ - –º–æ–∂–µ–º —É–¥–∞–ª–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å
                    logger.warning(f"‚ö†Ô∏è Authentication invalid - consider deleting profile {profile_dir}")
                    # TODO: –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

                # –ö–†–ò–¢–ò–ß–ù–û: –ñ–¥—ë–º –∑–∞–∫—Ä—ã—Ç–∏—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ Chrome (–¥–ª—è —Å–µ–º–∞—Ñ–æ—Ä–∞)
                # –î–∞—ë–º –≤—Ä–µ–º—è –±—Ä–∞—É–∑–µ—Ä—É –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –ø–æ—Å–ª–µ driver.quit()
                import time
                time.sleep(1.0)
                logger.info(f"‚è±Ô∏è Waited 1s for browser cleanup after driver.quit()")

                # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è (–µ—Å–ª–∏ –±—ã–ª persistent profile)
                if 'profile_dir' in locals() and profile_dir:
                    logger.info(f"üíæ Browser profile saved to: {profile_dir}")
                    logger.info(f"üíæ Profile contains: cookies, localStorage, IndexedDB, Service Workers, Cache")

            except Exception as cleanup_error:
                logger.error(f"‚ùå Error closing browser: {cleanup_error}")
        else:
            logger.debug(f"‚ÑπÔ∏è No browser to cleanup (not initialized or already cleaned)")

async def handle_search_results_with_modals(driver, search_config: dict, lsd_config):
    """
    –£–º–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∂–¥—ë–º –ª–∏–±–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏,
    –ª–∏–±–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω. –ß—Ç–æ –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞–Ω—å—à–µ - —Ç–æ –∏ –æ–±—Ä–∞–±–æ—Ç–∞–µ–º.
    –ù–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–µ—Ä–∂–µ–∫ - —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.
    """
    from selenium.webdriver.common.by import By
    import time
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞
    container_selector = search_config.get('result_container_selector')
    post_search_modals = search_config.get('post_search_modals', [])
    
    if not container_selector:
        logger.warning("‚ö†Ô∏è No container selector configured")
        return
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–∞–π–º–∞—É—Ç –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–≤ –º—Å), –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10000 –º—Å (10 —Å–µ–∫)
    wait_timeout_ms = search_config.get('wait_timeout', 10000)
    max_wait_time = wait_timeout_ms / 1000  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
    check_interval = 0.2  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 200–º—Å
    
    logger.debug(f"‚è±Ô∏è Using wait_timeout: {wait_timeout_ms}ms ({max_wait_time}s)")
    start_time = time.time()
    
    container_found = False
    modal_handled = False
    
    logger.debug(f"üîç Starting smart wait: container='{container_selector}', modals={len(post_search_modals)}")
    
    while (time.time() - start_time) < max_wait_time:
        elapsed = time.time() - start_time
        
        try:
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ (–æ–Ω–∏ –º–æ–≥—É—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç)
            if not modal_handled and post_search_modals:
                for modal in post_search_modals:
                    modal_id = modal.get('id', 'unknown')
                    trigger_selector = modal.get('trigger_selector')
                    action_selector = modal.get('action_selector')
                    
                    if not trigger_selector or not action_selector:
                        continue
                    
                    try:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–æ–¥–∞–ª–∫–∏
                        if trigger_selector.startswith('//'):
                            modal_element = driver.find_element(By.XPATH, trigger_selector)
                        else:
                            modal_element = driver.find_element(By.CSS_SELECTOR, trigger_selector)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –≤–∏–¥–∏–º—ã–π
                        if modal_element.is_displayed():
                            logger.info(f"‚úÖ Modal '{modal_id}' detected after {elapsed:.1f}s, handling...")
                            
                            # –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ
                            if action_selector.startswith('//'):
                                action_element = driver.find_element(By.XPATH, action_selector)
                            else:
                                action_element = driver.find_element(By.CSS_SELECTOR, action_selector)
                            
                            action_element.click()
                            logger.info(f"‚úÖ Modal '{modal_id}' handled successfully")
                            modal_handled = True
                            
                            # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª–∫–∏
                            await asyncio.sleep(0.3)
                            break
                    except Exception:
                        # –ú–æ–¥–∞–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                        continue
            
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
            if not container_found:
                try:
                    if container_selector.startswith('//'):
                        container_element = driver.find_element(By.XPATH, container_selector)
                    else:
                        container_element = driver.find_element(By.CSS_SELECTOR, container_selector)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤–∏–¥–∏–º—ã–π
                    if container_element.is_displayed():
                        logger.info(f"‚úÖ Container found after {elapsed:.1f}s")
                        container_found = True
                        # –ù–∞—à–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä - –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞
                        return
                except Exception:
                    # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –µ—â—ë –Ω–µ –ø–æ—è–≤–∏–ª—Å—è
                    pass
            
            # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Check error: {e}")
            await asyncio.sleep(check_interval)
            continue
    
    # –¢–∞–π–º–∞—É—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç
    if not container_found and not modal_handled:
        logger.warning(f"‚ö†Ô∏è Timeout after {max_wait_time}s: no container or modals found")
    elif not container_found:
        logger.warning(f"‚ö†Ô∏è Timeout after {max_wait_time}s: modal handled but container not found")

async def wait_for_page_body_with_retries(
    driver,
    wait_timeout: int,
    max_retries: int = 3,
    lsd_name: str = "unknown"
) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–∞–≥—Ä—É–∑–∫—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–Ω–∞–ª–∏—á–∏–µ <body>) —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏.
    
    Args:
        driver: Selenium WebDriver
        wait_timeout: –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö (–∏–∑ search_config)
        max_retries: –ú–∞–∫—Å. –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–≤—Ç–æ—Ä–æ–≤ –ø—Ä–∏ –Ω–µ—É–¥–∞—á–µ
        lsd_name: –ù–∞–∑–≤–∞–Ω–∏–µ –õ–°–î –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        
    Returns:
        True –µ—Å–ª–∏ body –∑–∞–≥—Ä—É–∂–µ–Ω, False –ø–æ—Å–ª–µ –≤—Å–µ—Ö –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
    """
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
    import time
    
    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º wait_timeout –∏–∑ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥ –≤ —Å–µ–∫—É–Ω–¥—ã
    timeout_seconds = wait_timeout / 1000
    logger.info(f"‚è≥ Waiting for page body to load (timeout: {timeout_seconds}s, max_retries: {max_retries})")
    
    for retry in range(1, max_retries + 1):
        start_time = time.time()
        
        try:
            # –ñ–¥—ë–º –ø–æ—è–≤–ª–µ–Ω–∏—è <body> —ç–ª–µ–º–µ–Ω—Ç–∞
            wait = WebDriverWait(driver, timeout_seconds)
            wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
            
            elapsed = time.time() - start_time
            logger.info(f"‚úÖ Page body loaded successfully in {elapsed:.2f}s")
            return True
            
        except TimeoutException:
            elapsed = time.time() - start_time
            
            if retry < max_retries:
                # –ï—â—ë –µ—Å—Ç—å –ø–æ–ø—ã—Ç–∫–∏ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º HTML –∏ –¥–µ–ª–∞–µ–º refresh
                logger.warning(f"üîÑ Retry {retry}/{max_retries}: Body not found after {elapsed:.2f}s, refreshing page...")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML dump –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                from datetime import datetime
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"page_body_retry_{retry}_{lsd_name}_{timestamp}.html"
                filepath = f"/Users/ss/GenAI/korzinka/logs/{filename}"
                
                try:
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(f"<!-- Retry {retry}/{max_retries} -->\n")
                        f.write(f"<!-- URL: {driver.current_url} -->\n")
                        f.write(driver.page_source)
                    logger.info(f"üìÑ Page dump saved: {filename}")
                except Exception as save_error:
                    logger.error(f"‚ùå Failed to save page dump: {save_error}")
                
                # –î–µ–ª–∞–µ–º refresh —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                try:
                    driver.refresh()
                    await asyncio.sleep(2)  # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫—É
                except Exception as refresh_error:
                    logger.error(f"‚ùå Failed to refresh page: {refresh_error}")
                    return False
            else:
                # –ò—Å—á–µ—Ä–ø–∞–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏
                logger.error(f"‚ùå Failed to load page body after {max_retries} retries")
                return False
        
        except Exception as e:
            logger.error(f"‚ùå Unexpected error waiting for body: {e}")
            return False
    
    return False

async def handle_post_search_modals(driver, search_config: dict):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –ø–æ—Å–ª–µ –ø–æ–∏—Å–∫–∞
    (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤–æ–∑—Ä–∞—Å—Ç–∞ –≤ –ê—à–∞–Ω–µ)
    """
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
    
    post_search_modals = search_config.get('post_search_modals', [])
    if not post_search_modals:
        return
    
    logger.info(f"üîç Checking for post-search modals ({len(post_search_modals)} configured)...")
    
    for modal in post_search_modals:
        modal_id = modal.get('id', 'unknown')
        trigger_selector = modal.get('trigger_selector')
        action_selector = modal.get('action_selector')
        timeout_ms = modal.get('timeout', 3000)
        is_optional = modal.get('optional', True)
        
        if not trigger_selector or not action_selector:
            logger.warning(f"‚ö†Ô∏è Modal {modal_id}: missing selectors")
            continue
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—è–≤–ª–µ–Ω–∏–µ –º–æ–¥–∞–ª–∫–∏
            wait = WebDriverWait(driver, timeout_ms / 1000)
            
            if trigger_selector.startswith('//'):
                modal_element = wait.until(
                    EC.presence_of_element_located((By.XPATH, trigger_selector))
                )
            else:
                modal_element = wait.until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, trigger_selector))
                )
            
            logger.info(f"‚úÖ Modal '{modal_id}' detected, handling...")
            
            # –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ
            if action_selector.startswith('//'):
                action_element = driver.find_element(By.XPATH, action_selector)
            else:
                action_element = driver.find_element(By.CSS_SELECTOR, action_selector)
            
            action_element.click()
            logger.info(f"‚úÖ Modal '{modal_id}' handled successfully")
            
            # –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª–∫–∏
            await asyncio.sleep(0.5)
            
        except TimeoutException:
            if is_optional:
                logger.debug(f"‚ÑπÔ∏è Modal '{modal_id}' not found (optional, continuing)")
            else:
                logger.warning(f"‚ö†Ô∏è Required modal '{modal_id}' not found")
        except Exception as e:
            logger.error(f"‚ùå Error handling modal '{modal_id}': {e}")
            if not is_optional:
                raise

async def search_single_product_cdp(
    driver,
    lsd_config,
    search_config: dict,
    product: Dict[str, Any],
    result: ProductSearchResult,
    delivery_info: dict = None
) -> bool:
    """
    –ü–æ–∏—Å–∫ –æ–¥–Ω–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ —á–µ—Ä–µ–∑ CDP –¥—Ä–∞–π–≤–µ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–≤—É—Ö –º–µ—Ç–æ–¥–æ–≤:
    - search_method: "url" - –ø—Ä—è–º–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ URL (–õ–µ–Ω—Ç–∞, Ozon)
    - search_method: "selector" - –≤–≤–æ–¥ –≤ –ø–æ–ª–µ –ø–æ–∏—Å–∫–∞ (–ê—à–∞–Ω, –ú–∞–≥–Ω–∏—Ç)
    
    Returns:
        True –µ—Å–ª–∏ –ø–æ–∏—Å–∫ —É—Å–ø–µ—à–µ–Ω
    """
    
    try:
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.common.by import By
        from selenium.common.exceptions import TimeoutException
        import time
        
        logger.info(f"üìù CDP search starting for product: {product.get('product_name', 'Unknown')}")
        
        # –ü–æ–ª—É—á–∞–µ–º base_url
        base_url = getattr(lsd_config, 'base_url', None) or lsd_config.get('base_url')
        if not base_url:
            raise Exception("base_url not found in lsd_config")
        
        logger.info(f"üìù Got base_url: {base_url}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞
        search_method = search_config.get('search_method', 'url')  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 'url'
        logger.info(f"üîç Search method: {search_method}")
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
        search_query = product['product_name']
        logger.info(f"üîé Search query: '{search_query}'")
        
        # ==================== –ú–ï–¢–û–î 1: –ü–û–ò–°–ö –ß–ï–†–ï–ó –°–ï–õ–ï–ö–¢–û–† ====================
        if search_method == "selector":
            logger.info(f"üéØ Using SELECTOR search method (input field)")
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∑–∞—Ä–∞–Ω–µ–µ (–Ω—É–∂–Ω—ã –¥–ª—è –∫–ª—é—á–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏)
            container_selector = search_config.get('result_container_selector')
            item_selector = search_config.get('result_item_selector')
            url_selector = search_config.get('url_selector')
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä –ø–æ–ª—è –ø–æ–∏—Å–∫–∞
            search_selector = search_config.get('search_selector')
            if not search_selector:
                raise Exception("search_selector not found in config for selector search method")
            
            logger.info(f"üìç Search selector: {search_selector}")
            
            # –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ base_url –¥–ª—è –õ–°–î –±–µ–∑ qrator_init
            # (–¥–ª—è qrator_init –ø–µ—Ä–µ—Ö–æ–¥ —É–∂–µ —Å–¥–µ–ª–∞–Ω –≤ perform_product_search_with_cdp_cookies)
            qrator_init = search_config.get('qrator_init', False)
            if not qrator_init:
                logger.info(f"üåê Navigating to base_url: {base_url}")
                driver.get(base_url)
            else:
                logger.info(f"‚ÑπÔ∏è qrator_init=true: Skipping navigation (already done in cookie injection phase)")
                
            await asyncio.sleep(2)  # –î–∞–µ–º –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –õ–°–î –±–µ–∑ qrator_init)
            if not qrator_init:
                wait_timeout = search_config.get('wait_timeout', 30000)
                page_loaded = await wait_for_page_body_with_retries(
                    driver,
                    wait_timeout=wait_timeout,
                    max_retries=3,
                    lsd_name=lsd_config.name
                )
                
                if not page_loaded:
                    logger.warning(f"‚ö†Ô∏è Page body check failed, but continuing (will check search_selector next)")
            else:
                logger.info(f"‚ÑπÔ∏è qrator_init=true: Skipping body check (JS may still be loading)")
            
            # 2. –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª–µ –ø–æ–∏—Å–∫–∞ (—Å retry –¥–ª—è qrator_init)
            wait = WebDriverWait(driver, 10)
            search_input = None
            max_search_retries = 3 if qrator_init else 1
            
            for search_retry in range(1, max_search_retries + 1):
                try:
                    if search_selector.startswith('//'):
                        search_input = wait.until(
                            EC.presence_of_element_located((By.XPATH, search_selector))
                        )
                    else:
                        search_input = wait.until(
                            EC.presence_of_element_located((By.CSS_SELECTOR, search_selector))
                        )
                    logger.info(f"‚úÖ Found search input field")
                    break  # –ù–∞—à–ª–∏ - –≤—ã—Ö–æ–¥–∏–º
                    
                except TimeoutException:
                    if search_retry < max_search_retries:
                        logger.warning(f"üîÑ Search retry {search_retry}/{max_search_retries}: Input not found, refreshing page...")
                        
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML dump
                        save_debug_html_dump(driver, lsd_config.name, f"search_input_retry_{search_retry}", search_query)
                        
                        # Refresh –∏ –ø–∞—É–∑–∞
                        driver.refresh()
                        await asyncio.sleep(3)
                        
                        # –ü–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º wait
                        wait = WebDriverWait(driver, 10)
                    else:
                        logger.error(f"‚ùå Search input not found after {max_search_retries} retries: {search_selector}")
                        return False
            
            if not search_input:
                logger.error(f"‚ùå Failed to find search input")
                return False
            
            # 3. –û—á–∏—â–∞–µ–º –ø–æ–ª–µ –∏ –≤–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç
            search_input.clear()
            search_input.send_keys(search_query)
            logger.info(f"‚å®Ô∏è Typed query into search field")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–π –∫–ª—é—á –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –ü–ï–†–ï–î –æ—Ç–ø—Ä–∞–≤–∫–æ–π —Ñ–æ—Ä–º—ã
            from selenium_product_search import get_search_results_key
            old_key = get_search_results_key(driver, container_selector, item_selector, url_selector)
            logger.info(f"üîë Old search key: {old_key}")
            
            # 4. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É (Enter)
            from selenium.webdriver.common.keys import Keys
            search_input.send_keys(Keys.RETURN)
            logger.info(f"‚Üµ Submitted search")
            
            # –ñ–¥—ë–º —Å–º–µ–Ω—ã –∫–ª—é—á–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
            logger.info(f"‚åõ Waiting for search results to update...")
            # –ë–µ—Ä—ë–º —Ç–∞–π–º–∞—É—Ç –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
            wait_timeout_ms = search_config.get('search_results_timeout', 15000)
            key_change_timeout = wait_timeout_ms / 1000  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
            logger.info(f"‚è±Ô∏è Using search_results_timeout: {wait_timeout_ms}ms ({key_change_timeout}s)")
            
            key_check_start = time.time()
            key_changed = False
            
            while (time.time() - key_check_start) < key_change_timeout:
                new_key = get_search_results_key(driver, container_selector, item_selector, url_selector)
                
                if new_key is None:
                    # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏—Å—á–µ–∑ - –∏–¥—ë—Ç –∑–∞–≥—Ä—É–∑–∫–∞
                    await asyncio.sleep(0.3)
                    continue
                
                if new_key != old_key:
                    # –ö–ª—é—á –∏–∑–º–µ–Ω–∏–ª—Å—è!
                    elapsed = time.time() - key_check_start
                    logger.info(f"‚úÖ Results updated in {elapsed:.1f}s: {old_key} ‚Üí {new_key}")
                    key_changed = True
                    break
                
                if old_key is None and new_key is not None:
                    # –ü–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
                    elapsed = time.time() - key_check_start
                    logger.info(f"‚úÖ Results loaded in {elapsed:.1f}s: {new_key}")
                    key_changed = True
                    break
                
                await asyncio.sleep(0.3)
            
            if not key_changed:
                if new_key == old_key and new_key is not None:
                    logger.warning(f"‚ö†Ô∏è Key unchanged after {key_change_timeout}s - results may be cached")
                    # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º, —Ç–∞–∫ –∫–∞–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –µ—Å—Ç—å
                else:
                    logger.error(f"‚ùå Results didn't update after {key_change_timeout}s")
                    raise TimeoutException("Search results did not update")
            
            # 5. –£–ú–ù–û–ï –û–ñ–ò–î–ê–ù–ò–ï: –∏—â–µ–º –ª–∏–±–æ —Ç–æ–≤–∞—Ä—ã, –ª–∏–±–æ –º–æ–¥–∞–ª–∫–∏ - —á—Ç–æ –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞–Ω—å—à–µ
            # –ù–µ –¥–µ–ª–∞–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–µ—Ä–∂–µ–∫, –∂–¥—ë–º —Ä–µ–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            logger.info(f"‚è≥ Waiting for search results or modals...")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –º–æ–¥–∞–ª–∫–∏ –∏ —Ç–æ–≤–∞—Ä—ã –≤ –æ–¥–Ω–æ–º —Ü–∏–∫–ª–µ
            await handle_search_results_with_modals(driver, search_config, lsd_config)
            
        # ==================== –ú–ï–¢–û–î 2: –ü–û–ò–°–ö –ß–ï–†–ï–ó URL ====================
        else:  # search_method == "url"
            logger.info(f"üéØ Using URL search method (direct navigation)")
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π URL –ü–ï–†–ï–î –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π
            url_before_search = driver.current_url
            logger.info(f"üìç URL BEFORE search navigation: {url_before_search}")
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º search_url_pattern
            search_url_pattern = search_config.get('search_url_pattern')
            
            if not search_url_pattern:
                logger.info(f"üìù search_url_pattern not found, creating from base_url")
                if 'ozon' in base_url.lower():
                    search_url_pattern = f"{base_url}/search/?text={{query}}"
                else:
                    search_url_pattern = f"{base_url}/search?q={{query}}"
                logger.info(f"üîß Created search_url_pattern: {search_url_pattern}")
            elif '{base_url}' in search_url_pattern:
                search_url_pattern = search_url_pattern.replace('{base_url}', base_url)
                logger.info(f"üîß Substituted base_url in pattern: {search_url_pattern}")
            
            # URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
            from urllib.parse import quote_plus
            encoded_query = quote_plus(search_query)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º search_url
            try:
                search_url = search_url_pattern.format(query=encoded_query)
                logger.info(f"üéØ Formatted search URL: {search_url}")
            except KeyError as e:
                logger.error(f"‚ùå KeyError formatting URL: {e}")
                search_url = search_url_pattern.format(base_url=base_url, query=encoded_query)
                logger.info(f"üîß Fixed with both params: {search_url}")
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–∏—Å–∫–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π timeout
            logger.info(f"üåê Navigating to: {search_url}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            nav_start_time = time.time()
            
            # –ö–†–ò–¢–ò–ß–ù–û: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º TimeoutException –ø—Ä–∏ –∑–∞–≤–∏—Å–∞–Ω–∏–∏ –∑–∞–≥—Ä—É–∑–∫–∏
            from selenium.common.exceptions import TimeoutException as SeleniumTimeoutException
            
            try:
                driver.get(search_url)
                nav_time = time.time() - nav_start_time
                logger.info(f"‚úÖ Navigation complete in {nav_time:.2f}s")
                
            except SeleniumTimeoutException as e:
                nav_time = time.time() - nav_start_time
                logger.warning(f"‚è±Ô∏è Page load timeout after {nav_time:.2f}s - continuing anyway (page may be partially loaded)")
                logger.debug(f"   Timeout details: {str(e)[:200]}")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML dump –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                save_debug_html_dump(driver, lsd_config.name, "navigation_timeout", search_query)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º URL –ø–æ—Å–ª–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            url_after_get = driver.current_url
            logger.info(f"üìç Current URL after navigation: {url_after_get}")
            logger.info(f"‚è±Ô∏è Navigation took: {nav_time:.2f} seconds")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º: –ø—Ä–æ–∏–∑–æ—à–µ–ª –ª–∏ —Ä–µ–¥–∏—Ä–µ–∫—Ç –£–ñ–ï –≤ driver.get()
            if '/search/' not in url_after_get:
                logger.debug(f"üîÑ IMMEDIATE REDIRECT in driver.get()! Expected search URL, got: {url_after_get}")
                logger.debug(f"üîÑ Redirect happens DURING navigation, not after!")
        
        # ==================== –û–ë–©–ê–Ø –ß–ê–°–¢–¨: –û–ë–†–ê–ë–û–¢–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ====================
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        container_selector = search_config.get('result_container_selector')
        item_selector = search_config.get('result_item_selector')
        
        # –ö–†–ò–¢–ò–ß–ù–û: –Ø–≤–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è DOM —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        # –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ DOM –∑–∞–≥—Ä—É–∑–∏–ª—Å—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.common.by import By
        from selenium.common.exceptions import TimeoutException as SeleniumTimeoutException
        
        # –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –†–ê–ù–ù–Ø–Ø –ü–†–û–í–ï–†–ö–ê "–ù–ï –ù–ê–ô–î–ï–ù–û" (–±—ã—Å—Ç—Ä–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)
        # –ñ–¥—ë–º 3 —Å–µ–∫—É–Ω–¥—ã —á—Ç–æ–±—ã —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —É—Å–ø–µ–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è –∏ –æ—Ç—Ä–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–µ–∫—Å—Ç
        logger.info("‚è±Ô∏è Quick wait for page render (3s before NOT_FOUND check)...")
        await asyncio.sleep(3)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ—Ä–∞–∑—ã "–Ω–µ –Ω–∞–π–¥–µ–Ω–æ" –î–û –¥–æ–ª–≥–æ–≥–æ –æ–∂–∏–¥–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        not_found_phrases = search_config.get('not_found_text', [])
        if not_found_phrases:
            logger.info(f"üîç Early check: looking for 'not found' phrases before waiting for items...")
            from selenium_product_search import check_page_for_not_found
            detected_phrase = check_page_for_not_found(driver, not_found_phrases)
            
            if detected_phrase:
                # –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω - —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ë–ï–ó –¥–æ–ª–≥–æ–≥–æ –æ–∂–∏–¥–∞–Ω–∏—è!
                logger.info(f"üö´ EARLY DETECTION: Product '{search_query}' not found in {lsd_config.display_name} - phrase: '{detected_phrase}'")
                logger.info(f"‚ö° Skipping 30s wait - returning NOT_FOUND immediately")
                
                # –°–æ–∑–¥–∞—ë–º –∑–∞–≥–ª—É—à–∫—É NOT_FOUND
                result.found_items.append({
                    'name': 'not_found',
                    'price': None,
                    'unit': None,
                    'quantity': 0,
                    'available': False,
                    'url': None,
                    'matched_phrase': detected_phrase
                })
                
                # –ö–†–ò–¢–ò–ß–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º found_name –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î
                result.found_name = 'not_found'
                
                # –ü–æ–º–µ—á–∞–µ–º –ø–æ–∏—Å–∫ –∫–∞–∫ —É—Å–ø–µ—à–Ω—ã–π
                result.search_successful = True
                logger.info(f"‚úÖ NOT_FOUND marker created (early detection)")
                return True  # –ë—ã—Å—Ç—Ä—ã–π –≤–æ–∑–≤—Ä–∞—Ç!
        
        logger.info("‚è≥ Waiting for page DOM to be ready...")
        
        try:
            # –ñ–¥–µ–º –ø–æ—è–≤–ª–µ–Ω–∏—è –ª—é–±–æ–≥–æ –∏–∑ –∫–ª—é—á–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (15 —Å–µ–∫—É–Ω–¥)
            wait = WebDriverWait(driver, 15)
            
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ container –∏–ª–∏ item elements
            elements_found = False
            
            if container_selector:
                try:
                    if container_selector.startswith('//'):
                        wait.until(EC.presence_of_element_located((By.XPATH, container_selector)))
                    else:
                        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, container_selector)))
                    logger.info(f"‚úÖ Container element ready: {container_selector}")
                    elements_found = True
                except SeleniumTimeoutException:
                    logger.debug(f"‚è±Ô∏è Container not found within 15s: {container_selector}")
            
            # –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–±—É–µ–º item_selector
            if not elements_found and item_selector:
                try:
                    if item_selector.startswith('//'):
                        wait.until(EC.presence_of_element_located((By.XPATH, item_selector)))
                    else:
                        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, item_selector)))
                    logger.info(f"‚úÖ Item elements ready: {item_selector}")
                    elements_found = True
                except SeleniumTimeoutException:
                    logger.debug(f"‚è±Ô∏è Items not found within 15s: {item_selector}")
            
            if not elements_found:
                logger.warning("‚ö†Ô∏è No key elements found - page may not be fully loaded")
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML dump
                save_debug_html_dump(driver, lsd_config.name, "no_key_elements", search_query)
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ - –º–æ–∂–µ—Ç –±—ã—Ç—å, —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –ø–æ–∑–∂–µ
                
        except Exception as e:
            logger.error(f"‚ùå Error waiting for page elements: {e}")
            save_debug_html_dump(driver, lsd_config.name, "wait_error", search_query)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤
        if not container_selector or not item_selector:
            logger.warning(f"‚ö†Ô∏è Missing selectors, trying fallback...")
            result_selectors = search_config.get('result_selectors', {})
            container_selector = container_selector or result_selectors.get('container')
            item_selector = item_selector or result_selectors.get('item')
            
            if not container_selector or not item_selector:
                raise Exception("No valid result selectors found")
        
        logger.info(f"üîç Searching for products (optimized waiting)...")
        
        # –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –û–ñ–ò–î–ê–ù–ò–ï: –∏—â–µ–º —Ç–æ–≤–∞—Ä—ã, –∞ –Ω–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ—è–≤–ª—è–µ—Ç—Å—è –±—ã—Å—Ç—Ä–æ, –Ω–æ —Ç–æ–≤–∞—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–∞–π–º–∞—É—Ç –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–≤ –º—Å), –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10000 –º—Å (10 —Å–µ–∫)
            wait_timeout_ms = search_config.get('wait_timeout', 10000)
            max_wait_time = wait_timeout_ms / 1000  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—ã
            logger.info(f"‚è±Ô∏è Using wait_timeout: {wait_timeout_ms}ms ({max_wait_time}s) for items search")
            
            start_time = time.time()
            container_element = None
            items_found = False
            
            # –ë—ã—Å—Ç—Ä—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –Ω–∞–π—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏ —Ç–æ–≤–∞—Ä—ã
            last_url_check = 0
            while (time.time() - start_time) < max_wait_time:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º URL –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
                    elapsed = time.time() - start_time
                    if elapsed - last_url_check >= 2:
                        current_url = driver.current_url
                        logger.debug(f"‚è±Ô∏è [{elapsed:.1f}s] Current URL: {current_url}")
                        last_url_check = elapsed
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ base_url
                        if base_url in current_url and '/search/' not in current_url:
                            logger.warning(f"‚ö†Ô∏è REDIRECT DETECTED after {elapsed:.1f}s! URL changed to: {current_url}")
                            logger.error(f"‚ùå {lsd_config.display_name} —Ä–µ–¥–∏—Ä–µ–∫—Ç–Ω—É–ª –Ω–∞ base_url - –≤–æ–∑–º–æ–∂–Ω–æ –∫—É–∫–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã –∏–ª–∏ antibot")
                            break
                    
                    # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                    if not container_element:
                        if container_selector.startswith('//'):
                            container_element = driver.find_element(By.XPATH, container_selector)
                        else:
                            container_element = driver.find_element(By.CSS_SELECTOR, container_selector)
                        
                        elapsed = time.time() - start_time
                        logger.info(f"‚úÖ Container found after {elapsed:.1f}s: {container_selector}")
                    
                    # –®–∞–≥ 2: –ò—â–µ–º —Ç–æ–≤–∞—Ä—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                    if item_selector.startswith('//') or item_selector.startswith('.//'):
                        items = container_element.find_elements(By.XPATH, item_selector)
                    else:
                        items = container_element.find_elements(By.CSS_SELECTOR, item_selector)
                    
                    if items and len(items) > 0:
                        elapsed = time.time() - start_time
                        logger.info(f"‚úÖ Found {len(items)} items after {elapsed:.1f}s")
                        items_found = True
                        break
                    
                    # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                    await asyncio.sleep(0.3)
                    
                except Exception:
                    await asyncio.sleep(0.3)
                    continue
            
            if not items_found:
                # –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º not_found –ü–ï–†–ï–î raise
                not_found_phrases = search_config.get('not_found_text', [])
                if not_found_phrases:
                    logger.info(f"üîç Container/items not found within timeout - checking for 'not found' phrases...")
                    from selenium_product_search import check_page_for_not_found
                    detected_phrase = check_page_for_not_found(driver, not_found_phrases)
                    
                    if detected_phrase:
                        # –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –õ–°–î - —Å–æ–∑–¥–∞—ë–º –∑–∞–≥–ª—É—à–∫—É
                        logger.info(f"üö´ Product '{search_query}' not found in {lsd_config.display_name} - phrase: '{detected_phrase}'")
                        
                        # –°–æ–∑–¥–∞—ë–º –∑–∞–≥–ª—É—à–∫—É NOT_FOUND
                        result.found_items.append({
                            'name': 'not_found',
                            'price': None,
                            'unit': None,
                            'quantity': 0,
                            'available': False,
                            'url': None,
                            'matched_phrase': detected_phrase
                        })
                        
                        # –ö–†–ò–¢–ò–ß–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º found_name –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î
                        result.found_name = 'not_found'
                        
                        # –ü–æ–º–µ—á–∞–µ–º –ø–æ–∏—Å–∫ –∫–∞–∫ —É—Å–ø–µ—à–Ω—ã–π (–Ω–∞—à–ª–∏, —á—Ç–æ —Ç–æ–≤–∞—Ä–∞ –Ω–µ—Ç)
                        result.search_successful = True
                        logger.info(f"‚úÖ NOT_FOUND marker saved for '{search_query}'")
                        return True  # –£—Å–ø–µ—Ö - –Ω–µ –Ω—É–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–∫–∞—Ç—å
                
                # –§—Ä–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ - —ç—Ç–æ —Ä–µ–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞
                raise TimeoutException(f"No items found after {max_wait_time}s")
        except Exception as e:
            logger.error(f"‚ùå Products not found: {e}")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML dump –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
            save_debug_html_dump(driver, lsd_config.name, "no_products_found", search_query)
            
            return False
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤
        if item_selector.startswith('//') or item_selector.startswith('.//'):
            item_elements = container_element.find_elements(By.XPATH, item_selector)
        else:
            item_elements = container_element.find_elements(By.CSS_SELECTOR, item_selector)
        
        if not item_elements:
            logger.error(f"‚ùå No items found")
            return False
        
        logger.info(f"üì¶ Found {len(item_elements)} potential items")
        
        # –ì–æ—Ç–æ–≤–∏–º page_level_data –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
        if delivery_info:
            # –ò–∑–≤–ª–µ–∫–∞–µ–º min_order_amount –∏–∑ delivery_info
            extracted_min_order = delivery_info.get('min_order_amount')
            
            # FALLBACK –ª–æ–≥–∏–∫–∞: –µ—Å–ª–∏ –Ω–µ –∏–∑–≤–ª–µ–∫–ª–∏ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º lsd_config
            if extracted_min_order is None:
                logger.info("‚ö†Ô∏è min_order_amount not extracted from page, using lsd_config fallback")
                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: –∏–∑ delivery_cost_model –≤ –∫–æ–Ω—Ñ–∏–≥–µ
                config_delivery_model = getattr(lsd_config, 'delivery_cost_model', None)
                config_min_from_model = config_delivery_model.get('min_order_amount') if isinstance(config_delivery_model, dict) else None
                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞ lsd_config.min_order_amount
                config_min_from_attr = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                
                extracted_min_order = config_min_from_model if config_min_from_model is not None else config_min_from_attr
                logger.info(f"üîÑ Using fallback min_order_amount: {extracted_min_order}‚ÇΩ (from {'model' if config_min_from_model is not None else 'attr'})")
            
            page_level_data = {
                'min_order_amount': float(extracted_min_order),
                'delivery_cost': 0.0,
                'delivery_cost_model': delivery_info
            }
            logger.info(f"üìã Using pre-extracted delivery model (min_order: {page_level_data['min_order_amount']}‚ÇΩ)")
        else:
            logger.info(f"üì¶ Using lsd_config fallback")
            config_delivery_model = getattr(lsd_config, 'delivery_cost_model', None)
            if config_delivery_model:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ min_order_amount –≤ –º–æ–¥–µ–ª–∏
                config_min_from_model = config_delivery_model.get('min_order_amount') if isinstance(config_delivery_model, dict) else None
                config_min_from_attr = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                
                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: min_order_amount –∏–∑ –º–æ–¥–µ–ª–∏, –∏–Ω–∞—á–µ –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞
                final_min_order = config_min_from_model if config_min_from_model is not None else config_min_from_attr
                
                page_level_data = {
                    'min_order_amount': float(final_min_order),
                    'delivery_cost': getattr(lsd_config, 'delivery_cost', 0.0) or 0.0,
                    'delivery_cost_model': config_delivery_model
                }
            else:
                from selenium_product_search import convert_legacy_to_model
                config_min_order = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                config_delivery_cost = getattr(lsd_config, 'delivery_cost', 0.0) or 0.0
                page_level_data = {
                    'min_order_amount': float(config_min_order),
                    'delivery_cost': float(config_delivery_cost),
                    'delivery_cost_model': convert_legacy_to_model(config_min_order, config_delivery_cost)
                }
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä–æ–≤
        max_results = search_config.get('max_results_to_check', 20)
        logger.info(f"üìù Processing up to {max_results} items")
        
        from selenium_product_search import extract_item_data_selenium_enhanced
        
        for i, item_element in enumerate(item_elements[:max_results], 1):
            try:
                item_data = await extract_item_data_selenium_enhanced(
                    item_element=item_element,
                    search_config=search_config,
                    lsd_config=lsd_config,
                    page_level_data=page_level_data
                )
                
                if item_data:
                    result.found_items.append(item_data)
                    logger.info(f"‚úÖ [{i}] Extracted: {item_data.get('name')} - {item_data.get('price')}‚ÇΩ")
                else:
                    logger.warning(f"‚ö†Ô∏è [{i}] No data extracted")
                
            except Exception as extract_error:
                logger.warning(f"‚ö†Ô∏è [{i}] Error: {extract_error}")
                continue
        
        # –£—Å–ø–µ—Ö –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–æ–≤–∞—Ä
        if result.found_items:
            result.search_successful = True
            logger.info(f"‚úÖ Found {len(result.found_items)} items for '{search_query}'")
            return True
        else:
            logger.warning(f"‚ö†Ô∏è No valid items extracted for '{search_query}'")
            return False
            
    except Exception as e:
        error_msg = f"CDP search error: {e}"
        logger.error(f"‚ùå {error_msg}")
        result.error_message = error_msg
        return False



async def save_search_results_to_db(
    search_results: List[ProductSearchResult],
    lsd_config_id: int,
    telegram_id: int
) -> int:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—É lsd_stocks —Å –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–µ–π –µ–¥–∏–Ω–∏—Ü"""
    logger.info(f"üíæ Saving {len(search_results)} search results to lsd_stocks with unit normalization...")
    
    try:
        saved_count = 0
        
        async for db in get_async_session():
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —ç—Ç–∏—Ö order_item_id
            if search_results:
                order_item_ids = [result.order_item_id for result in search_results]
                await db.execute(
                    delete(LSDStock).where(
                        LSDStock.order_item_id.in_(order_item_ids),
                        LSDStock.lsd_config_id == lsd_config_id
                    )
                )
                logger.info(f"üßΩ Cleared old stocks for {len(order_item_ids)} items")
            
            # –ü–æ–ª—É—á–∞–µ–º order_id, over_order_percent –∏ under_order_percent –∏–∑ –ø–µ—Ä–≤–æ–≥–æ order_item
            order_id = None
            over_order_percent = 50  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            under_order_percent = 10  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            
            if search_results:
                # –ü–æ–ª—É—á–∞–µ–º order_id –∏–∑ –ø–µ—Ä–≤–æ–≥–æ order_item
                first_item_result = await db.execute(
                    select(OrderItem.order_id).where(OrderItem.id == search_results[0].order_item_id)
                )
                order_id = first_item_result.scalar_one_or_none()
                
                if order_id:
                    logger.info(f"üéØ Got order_id={order_id} for this search batch")
                    
                    # –ü–æ–ª—É—á–∞–µ–º over_order_percent –∏ under_order_percent –∏–∑ –∑–∞–∫–∞–∑–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    order_result = await db.execute(
                        select(Order.over_order_percent, Order.under_order_percent, Order.user_id).where(Order.id == order_id)
                    )
                    order_data = order_result.one_or_none()
                    
                    if order_data:
                        # –ü–æ–ª—É—á–∞–µ–º over_order_percent
                        if order_data[0] is not None:
                            over_order_percent = order_data[0]
                            logger.info(f"üìä Using over_order_percent={over_order_percent}% from order")
                        elif order_data[2]:
                            # –ï—Å–ª–∏ –≤ –∑–∞–∫–∞–∑–µ –Ω–µ—Ç, –±–µ—Ä–µ–º –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                            user_result = await db.execute(
                                select(User.over_order_percent, User.under_order_percent).where(User.id == order_data[2])
                            )
                            user_percents = user_result.one_or_none()
                            if user_percents and user_percents[0] is not None:
                                over_order_percent = user_percents[0]
                                logger.info(f"üìä Using over_order_percent={over_order_percent}% from user")
                            if user_percents and user_percents[1] is not None:
                                under_order_percent = user_percents[1]
                                logger.info(f"üìä Using under_order_percent={under_order_percent}% from user")
                        else:
                            logger.info(f"üìä Using defaults: over={over_order_percent}%, under={under_order_percent}%")
                        
                        # –ü–æ–ª—É—á–∞–µ–º under_order_percent
                        if order_data[1] is not None:
                            under_order_percent = order_data[1]
                            logger.info(f"üìä Using under_order_percent={under_order_percent}% from order")
                    else:
                        logger.info(f"üìä Using defaults: over={over_order_percent}%, under={under_order_percent}%")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            for result in search_results:
                try:
                    # –ü–†–û–í–ï–†–ö–ê –ù–ê NOT_FOUND: –µ—Å–ª–∏ found_name='not_found', —Å–æ–∑–¥–∞—ë–º –∑–∞–≥–ª—É—à–∫—É
                    if result.found_name == 'not_found':
                        # –≠—Ç–æ NOT_FOUND –∑–∞–≥–ª—É—à–∫–∞ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –±–µ–∑ –æ–±—Ä–∞–±–æ—Ç–∫–∏
                        first_item = result.found_items[0] if result.found_items else {}
                        logger.info(f"üö´ Saving NOT_FOUND marker for '{result.product_name}' (phrase: {first_item.get('matched_phrase', 'unknown')})")
                        
                        # –°–æ–∑–¥–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∑–∞–ø–∏—Å—å –≤ –ë–î
                        lsd_stock = LSDStock(
                        order_id=order_id,
                        order_item_id=result.order_item_id,
                        lsd_config_id=lsd_config_id,
                        found_name='not_found',
                        
                        # –í—Å–µ –ø–æ–ª—è NULL/0 (–¥–ª—è NOT NULL –ø–æ–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)
                        found_unit='',  # NOT NULL –ø–æ–ª–µ - –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
                        found_quantity=0,
                        base_unit='',  # NOT NULL –ø–æ–ª–µ - –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
                        base_quantity=0,
                        
                        price=0,  # NOT NULL –ø–æ–ª–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º 0
                        fprice=0,  # NOT NULL –ø–æ–ª–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º 0
                        fprice_calculation=f"Product not found in LSD - detected phrase: '{first_item.get('matched_phrase', 'N/A')}'",
                        
                        min_order_amount=0,
                        delivery_cost=0,
                        delivery_cost_model=None,
                        
                        available_stock=0,  # –í–∞–∂–Ω–æ: 0 = –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                        product_url=None,
                        search_query=result.product_name,
                        search_result_position=0,
                        
                        match_score=Decimal('0.0'),
                        is_exact_match=False,
                        
                        is_alternative=getattr(result, 'is_alternative', False),
                        alternative_for=getattr(result, 'alternative_for', None),
                        
                        requested_quantity=None,
                        requested_unit=None,
                        
                        order_item_ids_quantity=None,
                        order_item_ids_cost=None
                        )
                        
                        db.add(lsd_stock)
                        saved_count += 1
                        logger.info(f"  ‚úÖ NOT_FOUND marker saved for: {result.product_name}")
                        
                        continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –¥–ª—è —ç—Ç–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –º–æ–ª–æ—á–Ω—ã–º –ø—Ä–æ–¥—É–∫—Ç–æ–º
                    is_milk = is_milk_product(result.found_name)
                    
                    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è –¥–ª—è –º–æ–ª–æ–∫–∞
                    unit_for_processing = result.unit
                    if is_milk:
                        if result.unit == '–≥':
                            unit_for_processing = '–º–ª'
                            logger.info(f"ü•õ Milk product detected: converting '–≥' -> '–º–ª' for '{result.found_name}'")
                        elif result.unit == '–∫–≥':
                            unit_for_processing = '–ª'
                            logger.info(f"ü•õ Milk product detected: converting '–∫–≥' -> '–ª' for '{result.found_name}'")
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é —è–∏—Ü –î–û –≤—ã–∑–æ–≤–∞ get_base_unit
                    egg_category = extract_egg_category(result.found_name)
                    if egg_category:
                        logger.info(f"ü•ö Egg detected: category={egg_category}, unit={unit_for_processing}")
                    
                    # –ê–í–¢–û–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ï–î–ò–ù–ò–¶–´ –î–õ–Ø –í–ï–°–û–í–´–• –¢–û–í–ê–†–û–í
                    from shared.utils.units import detect_weight_unit_from_price
                    detected_base_unit, detected_base_quantity = detect_weight_unit_from_price(
                        found_name=result.found_name,
                        price=result.price,
                        found_unit=unit_for_processing
                    )
                    
                    # –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –≤–µ—Ä–Ω—É–ª–∞ –∑–Ω–∞—á–µ–Ω–∏—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö, –∏–Ω–∞—á–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞
                    if detected_base_unit is not None and detected_base_quantity is not None:
                        base_unit = detected_base_unit
                        base_quantity = detected_base_quantity
                        logger.info(f"‚úÖ Using auto-detected unit for weight product: base_unit='{base_unit}', base_quantity={base_quantity}")
                    else:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ quantity –∏ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π unit
                        # –ü–µ—Ä–µ–¥–∞–µ–º egg_category –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —è–∏—Ü
                        base_unit = get_base_unit(unit_for_processing, egg_category=egg_category)
                        base_quantity = convert_to_base_unit(result.quantity, unit_for_processing, base_unit, egg_category=egg_category)
                    
                    # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è base_unit
                    logger.info(f"üîç Determining base_unit: input_unit='{unit_for_processing}' -> base_unit='{base_unit}', input_quantity={result.quantity} -> base_quantity={base_quantity}")
                    
                    # –ü–æ–ª—É—á–∞–µ–º requested_quantity –∏ requested_unit –∏–∑ order_items
                    item_result = await db.execute(
                        select(OrderItem.requested_quantity, OrderItem.requested_unit)
                        .where(OrderItem.id == result.order_item_id)
                    )
                    item_data = item_result.one_or_none()
                    requested_quantity = item_data[0] if item_data else None
                    requested_unit = item_data[1] if item_data else None
                    
                    # DEBUG: –ª–æ–≥–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    logger.info(f"üîç Unit conversion: result.unit='{result.unit}' -> base_unit='{base_unit}', result.quantity={result.quantity} -> base_quantity={base_quantity}")
                    logger.info(f"üîç Product: '{result.found_name}', price={result.price}")
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º fprice –∏ —Ñ–æ—Ä–º—É–ª—É –µ–≥–æ —Ä–∞—Å—á–µ—Ç–∞
                    fprice_calculation = None
                    
                    if base_quantity > 0:
                        # –£–ü–†–û–©–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: —è–π—Ü–∞ —É–∂–µ —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ –∫–≥ —á–µ—Ä–µ–∑ convert_to_base_unit()
                        # –ü—Ä–æ—Å—Ç–æ —Å—á–∏—Ç–∞–µ–º fprice = price / base_quantity
                        fprice = result.price / base_quantity
                        fprice = round(fprice, 2)
                        
                        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—è—Å–Ω–µ–Ω–∏–µ –¥–ª—è —è–∏—Ü –∏–ª–∏ –æ–±—ã—á–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤
                        if egg_category:
                            # –î–ª—è —è–∏—Ü: —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º —Ñ–æ—Ä–º—É–ª—É —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞
                            from shared.utils.egg_categories import get_egg_weight_kg, extract_egg_count_from_name
                            egg_count = extract_egg_count_from_name(result.found_name)
                            egg_weight_kg = get_egg_weight_kg(egg_category)
                            
                            logger.info(f"ü•ö Egg product: base_quantity={base_quantity}kg, fprice={fprice:.2f}‚ÇΩ/–∫–≥")
                            
                            # –î–µ—Ç–∞–ª—å–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞: price / (egg_count * egg_coefficient_CATEGORY / 10)
                            fprice_calculation = (
                                f"price / (egg_count * egg_coefficient_{egg_category} / 10) = "
                                f"{result.price} / ({egg_count} * {egg_weight_kg} / 10) = "
                                f"{result.price} / {base_quantity:.2f} = "
                                f"{fprice:.2f} ‚ÇΩ/–∫–≥ (eggs: {egg_category})"
                            )
                        elif base_unit == '—à—Ç':
                            logger.info(f"üëî Regular piece product: base_quantity={base_quantity}pcs, fprice={fprice}‚ÇΩ/—à—Ç")
                            fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice:.2f} ‚ÇΩ/—à—Ç"
                        elif detected_base_unit is not None:
                            # –ê–í–¢–û–û–ü–†–ï–î–ï–õ–ï–ù–ù–´–ô –í–ï–°–û–í–û–ô –¢–û–í–ê–†
                            # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≤ ‚ÇΩ/–∫–≥ –¥–ª—è —Å—Ä–∞–≤–Ω–∏–º–æ—Å—Ç–∏
                            if base_quantity == 100:  # –¶–µ–Ω–∞ –∑–∞ 100–≥
                                fprice_per_kg = fprice * 10
                                logger.info(f"‚öñÔ∏è Auto-detected weight product (100g): fprice={fprice}‚ÇΩ/100–≥ = {fprice_per_kg:.2f}‚ÇΩ/–∫–≥")
                                fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice:.2f} ‚ÇΩ/100–≥ (= {fprice_per_kg:.2f} ‚ÇΩ/–∫–≥) [AUTO-DETECTED: price ‚â§ {settings.weight_unit_price_threshold}‚ÇΩ]"
                            else:  # –¶–µ–Ω–∞ –∑–∞ –∫–≥
                                logger.info(f"‚öñÔ∏è Auto-detected weight product (kg): fprice={fprice}‚ÇΩ/–∫–≥")
                                fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice:.2f} ‚ÇΩ/–∫–≥ [AUTO-DETECTED: price > {settings.weight_unit_price_threshold}‚ÇΩ]"
                        else:
                            # –í–µ—Å/–æ–±—ä–µ–º
                            fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice:.2f} ‚ÇΩ/{base_unit}"
                    else:
                        fprice = result.price
                        base_quantity = 1.0
                        fprice_calculation = f"fprice = price = {fprice:.2f} ‚ÇΩ (base_quantity was 0)"
                    
                    normalized_data = {
                        'found_unit': unit_for_processing,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –µ–¥–∏–Ω–∏—Ü—É –¥–ª—è –º–æ–ª–æ–∫–∞
                        'found_quantity': result.quantity,
                        'base_unit': base_unit,
                        'base_quantity': base_quantity,
                        'fprice': fprice,
                        'fprice_calculation': fprice_calculation
                    }
                    
                    logger.info(f"üîß Normalized '{result.found_name}': {normalized_data['found_quantity']}{normalized_data['found_unit']} -> {normalized_data['fprice']}‚ÇΩ/{normalized_data['base_unit']}")
                    
                    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º found_name –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∏ —Ä–∞—Å—á–µ—Ç–æ–º match_score
                    normalized_found_name = normalize_product_name(result.found_name)
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é –µ—Å–ª–∏ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                    if result.found_name != normalized_found_name:
                        logger.info(f"üßπ Normalized found_name: '{result.found_name}' -> '{normalized_found_name}'")
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º match_score —Å —É–∂–µ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
                    match_score, is_exact_match = calculate_advanced_match_score(
                        search_query=result.product_name,
                        found_name=result.found_name  # –§—É–Ω–∫—Ü–∏—è —Å–∞–º–∞ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç
                    )
                    match_score = Decimal(str(match_score))
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º order_item_ids_quantity –∏ order_item_ids_cost
                    order_quantity = None
                    order_cost = None
                    
                    if requested_quantity is not None and requested_unit is not None:
                        order_quantity, order_cost = calculate_order_quantity(
                            requested_quantity=float(requested_quantity),
                            requested_unit=requested_unit,
                            base_quantity=float(normalized_data['base_quantity']),
                            base_unit=normalized_data['base_unit'],
                            price=float(result.price),
                            over_order_percent=over_order_percent,
                            under_order_percent=under_order_percent
                        )
                        
                        if order_quantity is not None:
                            logger.info(f"üì¶ Calculated order quantity: {order_quantity} pcs, cost: {order_cost}‚ÇΩ for {requested_quantity}{requested_unit}")
                        else:
                            logger.warning(f"‚ö†Ô∏è Failed to calculate order quantity for {result.found_name}")
                    else:
                        logger.debug(f"üìù No requested_quantity/unit for {result.found_name}, skipping calculation")
                    
                    lsd_stock = LSDStock(
                        order_id=order_id,  # –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä—è–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –∑–∞–∫–∞–∑
                        order_item_id=result.order_item_id,
                        lsd_config_id=lsd_config_id,
                        found_name=normalized_found_name,  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
                        
                        # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                        found_unit=normalized_data['found_unit'],
                        found_quantity=normalized_data['found_quantity'],
                        base_unit=normalized_data['base_unit'],
                        base_quantity=normalized_data['base_quantity'],
                        
                        # –¶–µ–Ω—ã
                        price=result.price,
                        fprice=normalized_data['fprice'],
                        fprice_calculation=normalized_data['fprice_calculation'],
                        
                        # –£—Å–ª–æ–≤–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏ –∏ –∑–∞–∫–∞–∑–∞ (—Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
                        min_order_amount=result.min_order_amount,
                        delivery_cost=result.delivery_cost,
                        # –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏
                        delivery_cost_model=getattr(result, 'delivery_cost_model', None),
                        
                        # –ú–µ—Ç–∞-–¥–∞–Ω–Ω—ã–µ
                        available_stock=result.available_stock,
                        product_url=result.product_url,
                        search_query=result.search_query,
                        search_result_position=result.search_position,
                        
                        # –û—Ü–µ–Ω–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
                        match_score=match_score,
                        is_exact_match=is_exact_match,
                        
                        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
                        is_alternative=getattr(result, 'is_alternative', False),
                        alternative_for=getattr(result, 'alternative_for', None),
                        
                        # –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞—Å–ª–µ–¥—É–µ—Ç—Å—è –æ—Ç order_items)
                        requested_quantity=requested_quantity,
                        requested_unit=requested_unit,
                        
                        # –†–∞—Å—á–µ—Ç–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–∫–∞–∑–∞
                        order_item_ids_quantity=order_quantity,
                        order_item_ids_cost=order_cost
                    )
                    
                    db.add(lsd_stock)
                    saved_count += 1
                    
                    logger.info(f"  ‚úÖ Saved: {result.product_name} -> {normalized_found_name} ({normalized_data['fprice']}‚ÇΩ/{normalized_data['base_unit']})")
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–π match_score
                    logger.debug(f"    Match score: {match_score} (exact: {is_exact_match})")
                    
                except Exception as e:
                    logger.error(f"  ‚ùå Error saving result {result.product_name}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
            
            await db.commit()
            logger.info(f"üíæ Successfully saved {saved_count}/{len(search_results)} results to lsd_stocks")
            
            return saved_count
            
    except Exception as e:
        logger.error(f"‚ùå Database error saving search results: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return 0

async def get_user_cookies(telegram_id: int, lsd_name: str) -> Optional[dict]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã"""
    logger.info(f"üç™ Getting cookies for user {telegram_id}, lsd '{lsd_name}'")
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞
        data = await cookie_manager.load_cookies(telegram_id, lsd_name)
        
        if data and data.get('cookies'):
            cookies = data['cookies']
            local_storage = data.get('localStorage', {})
            session_storage = data.get('sessionStorage', {})
            
            logger.info(f"‚úÖ Found {len(cookies)} cookies for user {telegram_id} on {lsd_name}")
            
            return {
                'cookies': cookies,
                'localStorage': local_storage,
                'sessionStorage': session_storage,
                'lsd_config_id': data.get('lsd_config_id'),
                'created_at': data.get('created_at'),
                'metadata': data.get('session_metadata', {})
            }
        else:
            logger.warning(f"‚ö†Ô∏è No cookies found for user {telegram_id} on {lsd_name}")
            return None
            
    except Exception as e:
        logger.error(f"‚ùå Error getting user cookies: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None

async def update_user_session_cookie_reference(
    telegram_id: int,
    lsd_config_id: int,
    cookie_file_path: str,
    cookie_count: int
) -> bool:
    """
    –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ cookie —Ñ–∞–π–ª –≤ user_sessions
    
    Args:
        telegram_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        lsd_config_id: ID –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î
        cookie_file_path: –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
        cookie_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ cookies –≤ —Ñ–∞–π–ª–µ
    """
    try:
        async for db in get_async_session():
            # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é
            result = await db.execute(
                select(UserSession).where(
                    UserSession.telegram_id == telegram_id,
                    UserSession.lsd_config_id == lsd_config_id
                )
            )
            session = result.scalar_one_or_none()
            
            # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î
            session_data = {
                "cookie_file": cookie_file_path,
                "cookie_count": cookie_count,
                "last_updated": datetime.now().isoformat()
            }
            
            if session:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é
                session.data = session_data
                session.updated_at = datetime.now()
                logger.info(f"‚úÖ Updated user_session reference to {cookie_file_path}")
            else:
                # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ –±—ã–ª–æ)
                session = UserSession(
                    telegram_id=telegram_id,
                    lsd_config_id=lsd_config_id,
                    session_type='cookie_file',
                    data=session_data,
                    created_at=datetime.now(),
                    updated_at=datetime.now()
                )
                db.add(session)
                logger.info(f"‚úÖ Created new user_session reference to {cookie_file_path}")
            
            await db.commit()
            return True
            
    except Exception as e:
        logger.error(f"‚ùå Failed to update user_session reference: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def save_user_cookies(
    telegram_id: int,
    lsd_name: str,
    lsd_config_id: int,
    cookies: List[Dict[str, Any]],
    local_storage: Optional[Dict[str, str]] = None,
    session_storage: Optional[Dict[str, str]] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> bool:
    """
    –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ cookies + localStorage + sessionStorage –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ë–î
    """
    try:
        # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª
        success, cookie_file_path = await cookie_manager.save_cookies(
            telegram_id=telegram_id,
            lsd_name=lsd_name,
            lsd_config_id=lsd_config_id,
            cookies=cookies,
            local_storage=local_storage,
            session_storage=session_storage,
            metadata=metadata
        )
        
        if not success:
            logger.error(f"‚ùå Failed to save cookies to file")
            return False
        
        # 2. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –≤ –ë–î
        db_updated = await update_user_session_cookie_reference(
            telegram_id=telegram_id,
            lsd_config_id=lsd_config_id,
            cookie_file_path=cookie_file_path,
            cookie_count=len(cookies)
        )
        
        if db_updated:
            logger.info(f"‚úÖ Saved {len(cookies)} cookies for user {telegram_id} @ {lsd_name}")
        else:
            logger.warning(f"‚ö†Ô∏è Cookies saved to file but DB reference not updated")
        
        return success
        
    except Exception as e:
        logger.error(f"‚ùå Error saving cookies: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def get_lsd_config(lsd_name: str) -> Optional[LSDConfig]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    lsd_id = await get_lsd_id_by_name(lsd_name)
    if not lsd_id:
        logger.error(f"‚ùå Unknown LSD name: {lsd_name}")
        return None
    
    try:
        async for db in get_async_session():
            await db.commit()
            result = await db.execute(select(LSDConfig).where(LSDConfig.id == lsd_id))
            config = result.scalar_one_or_none()
            
            if config:
                logger.info(f"‚úÖ Found config for {config.display_name} (ID: {config.id})")
                
                if config.search_config_rpa:
                    search_pattern = config.search_config_rpa.get('search_url_pattern')
                    logger.info(f"üîç DEBUG: search_url_pattern = '{search_pattern}'")
                else:
                    logger.warning(f"‚ö†Ô∏è No search_config_rpa for {config.display_name}")
            else:
                logger.error(f"‚ùå No config found for LSD ID: {lsd_id}")
                
            return config
            
    except Exception as e:
        logger.error(f"‚ùå Database error: {e}")
        return None

# ============================================================================
# –§–û–ù–û–í–´–ô –ú–û–ù–ò–¢–û–†–ò–ù–ì –ó–ê–ö–ê–ó–û–í - –û–¢–ö–õ–Æ–ß–ï–ù–û
# ============================================================================
# –≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã, —Ç.–∫. –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–æ–º –∑–∞–∫–∞–∑–æ–≤
# –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ Order-service. RPA-service —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–∞–∫ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å
# –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ API endpoint /search/products
#
# –ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è: –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å–µ—Å—Å–∏–π –ë–î –º–µ–∂–¥—É Order-service –∏ RPA-service
# –ø—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç–µ —Å –æ–¥–Ω–∏–º –∑–∞–∫–∞–∑–æ–º
# ============================================================================

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤
async def send_telegram_message(chat_id: str, text: str, reply_to_message_id: int = None, parse_mode: str = None, disable_web_page_preview: bool = False):
    """
    –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram —á–µ—Ä–µ–∑ telegram-bot API —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º.

    –í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π telegram-bot —Å–µ—Ä–≤–∏—Å,
    –∫–æ—Ç–æ—Ä—ã–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ª–æ–≥–∏—Ä—É–µ—Ç –∏—Ö –≤ user_messages —Ç–∞–±–ª–∏—Ü—É.
    """
    try:
        import httpx

        logger.info(f"üì§ Sending message via telegram-bot API to {chat_id}, length: {len(text)} chars")

        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8001/api/send-message",
                json={
                    "chat_id": chat_id,
                    "text": text,
                    "order_id": None,  # RPA-service –Ω–µ —Å–≤—è–∑–∞–Ω —Å –∑–∞–∫–∞–∑–∞–º–∏ –Ω–∞–ø—Ä—è–º—É—é
                    "reply_to_message_id": reply_to_message_id,
                    "parse_mode": parse_mode or "HTML",
                    "disable_web_page_preview": disable_web_page_preview
                },
                timeout=30.0
            )

            if response.status_code == 200:
                result = response.json()
                if result.get("success"):
                    logger.info(f"‚úÖ Message sent successfully to {chat_id} (telegram_message_id={result.get('telegram_message_id')})")
                    return True
                else:
                    logger.error(f"‚ùå telegram-bot API returned error: {result.get('error')}")
                    return False
            else:
                logger.error(f"‚ùå telegram-bot API request failed: {response.status_code} - {response.text}")
                return False

    except Exception as e:
        logger.error(f"‚ùå Error calling telegram-bot API for {chat_id}: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

# –û—Å—Ç–∞–ª—å–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã (auth, browse –∏ —Ç.–¥.) –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
@app.post("/auth/start")
async def start_selenium_auth(request: AuthRequest, background_tasks: BackgroundTasks):
    """–ó–∞–ø—É—Å–∫ —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–π CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –õ–°–î"""
    logger.info(f"üöÄ Starting unified CDP auth for {request.lsd_name} (user: {request.telegram_id})")
    
    try:
        lsd_config = await get_lsd_config(request.lsd_name)
        if not lsd_config:
            raise HTTPException(
                status_code=404, 
                detail=f"LSD configuration not found for {request.lsd_name}"
            )
        
        logger.info(f"üìã Loaded config for {lsd_config.display_name}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—É—é CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ
        background_tasks.add_task(
            execute_selenium_auth_flow, 
            request.telegram_id,
            lsd_config,
            lsd_config.rpa_config or {}  # –ü–µ—Ä–µ–¥–∞–µ–º RPA –∫–æ–Ω—Ñ–∏–≥ –∫–∞–∫ auth_config
        )
        
        return {
            "success": True,
            "data": {
                "status": "started",
                "lsd_name": request.lsd_name,
                "display_name": lsd_config.display_name,
                "message": f"ü§ñ –ó–∞–ø—É—Å–∫–∞—é —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ {lsd_config.display_name}...",
                "method": "unified_cdp"
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error starting unified CDP auth: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/orders/process-now")
async def process_orders_now():
    """–†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–∫–∞–∑–æ–≤"""
    logger.info("üîÑ Manual order processing triggered")
    
    try:
        await process_analyzing_orders()
        return {
            "success": True,
            "message": "Order processing completed"
        }
    except Exception as e:
        logger.error(f"‚ùå Manual order processing failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/orders/monitor/status")
async def get_monitor_status():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–∫–∞–∑–æ–≤"""
    global background_task
    
    analyzing_orders = await get_analyzing_orders()
    mvp_lsds = await get_mvp_lsd_configs()
    
    return {
        "success": True,
        "data": {
            "monitor_active": background_task is not None and not background_task.done(),
            "orders_in_queue": len(analyzing_orders),
            "active_lsd_count": len(mvp_lsds),
            "active_lsds": [lsd.display_name for lsd in mvp_lsds],
            "orders_list": [
                {
                    "id": order.id,
                    "user_id": order.user_id,
                    "created_at": order.created_at.isoformat() if order.created_at else None,
                    "analysis_started_at": order.analysis_started_at.isoformat() if order.analysis_started_at else None
                }
                for order in analyzing_orders
            ],
            "version": "3.0.0 - Full Selenium Integration"
        }
    }



@app.post("/rpa/user-input-response")
async def receive_user_input(request: dict):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ SMS –∫–æ–¥–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ telegram-bot - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î"""
    try:
        telegram_id = request.get('telegram_id')
        sms_code = request.get('user_input')
        
        if not telegram_id or not sms_code:
            return {"status": "error", "message": "Missing telegram_id or user_input"}
        
        logger.info(f"üì± Received SMS code from user {telegram_id}: {sms_code[:2]}***{sms_code[-1:]}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º SMS –∫–æ–¥ –≤ –ë–î
        async for db in get_async_session():
            result = await db.execute(
                update(User)
                .where(User.telegram_id == telegram_id)
                .values(sms_code=sms_code)
            )
            await db.commit()
            
            if result.rowcount > 0:
                logger.info(f"‚úÖ SMS code saved to database for user {telegram_id}")
            else:
                logger.warning(f"‚ö†Ô∏è User {telegram_id} not found in database")
        
        return {"status": "success", "message": "SMS code received and saved"}
        
    except Exception as e:
        logger.error(f"‚ùå Error saving SMS code: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return {"status": "error", "message": str(e)}


async def perform_auth_interactions(driver, auth_config: dict, lsd_name: str, telegram_id: int, lsd_config=None) -> bool:
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –õ–°–î —á–µ—Ä–µ–∑ RPA steps"""
    try:
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import TimeoutException, NoSuchElementException
        
        wait = WebDriverWait(driver, 15)
        
        # –ü–æ–ª—É—á–∞–µ–º RPA steps –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        steps = auth_config.get('steps', [])
        if not steps:
            logger.info(f"‚ö†Ô∏è No RPA steps found for {lsd_name}, skipping automation")
            return True  # –ù–µ –æ—à–∏–±–∫–∞, –ø—Ä–æ—Å—Ç–æ –Ω–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–π
        
        logger.info(f"üîÑ Found {len(steps)} RPA steps for {lsd_name}")
        
        # –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è SMS –∫–æ–¥–∞ –º–µ–∂–¥—É —à–∞–≥–∞–º–∏
        received_sms_code = None
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_phone = await get_user_phone_number(telegram_id)
        if not user_phone:
            logger.error(f"‚ùå No phone number found for user {telegram_id}")
            return False
        
        logger.info(f"üìû Found user phone: {user_phone[:3]}***{user_phone[-4:]}")
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ RPA —à–∞–≥–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É
        for step in steps:
            step_id = step.get('id', '')
            action = step.get('action', '')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–ª–∞–≥ –ø—Ä–æ–ø—É—Å–∫–∞ (—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è verify_address)
            if step.get('_skip', False):
                logger.info(f"‚è≠Ô∏è  Skipping step {step_id} (marked by verify_address)")
                continue
            
            logger.info(f"üîÑ Executing step: {step_id} ({action})")
            
            if action == 'navigate':
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º - –Ω–∞–≤–∏–≥–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞
                logger.debug(f"‚ö†Ô∏è Skipping navigation step {step_id}")
                continue
                
            elif action == 'hover':
                success = await execute_unified_hover_step(driver, wait, step, step_id)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ª–∏ —à–∞–≥
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required hover step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional hover step {step_id} failed, but continuing...")
                    
            elif action == 'click':
                success = await execute_unified_click_step(driver, wait, step, step_id)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ª–∏ —à–∞–≥
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required click step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional click step {step_id} failed, but continuing...")
                    
            elif action == 'scroll_into_view':
                success = await execute_scroll_step(driver, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Scroll step {step_id} failed, but continuing...")
                    
            elif action == 'wait_for':
                success = await execute_unified_wait_for_step(driver, wait, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Wait_for step {step_id} failed, but continuing...")
                    
            elif action == 'clear_and_wait':
                success = await execute_unified_clear_step(driver, wait, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Clear step {step_id} failed, but continuing...")
                    
            elif action == 'type':
                # –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤ (–±—ã—Å—Ç—Ä—ã–π –≤–≤–æ–¥ —á–µ—Ä–µ–∑ send_keys)
                from unified_rpa_helpers import execute_unified_input_step
                success = await execute_unified_input_step(driver, wait, step, step_id, telegram_id)
                
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required input step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional input step {step_id} failed, but continuing...")
                    
            elif action == 'human_input':
                # –ü–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å —Ç—Ä–∏–≥–≥–µ—Ä–æ–º JS —Å–æ–±—ã—Ç–∏–π (–∏–º–∏—Ç–∞—Ü–∏—è —á–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞)
                from unified_rpa_helpers import execute_unified_human_input_step
                success = await execute_unified_human_input_step(driver, wait, step, step_id, telegram_id)
                
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required human_input step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional human_input step {step_id} failed, but continuing...")
                    
            elif action == 'request_sms_code':
                sms_code = await request_unified_sms_code(telegram_id, lsd_name, step)
                if not sms_code:
                    logger.error(f"‚ùå SMS request step failed")
                    return False
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º SMS –∫–æ–¥ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–∞—Ö
                received_sms_code = sms_code
                logger.info(f"‚úÖ SMS code stored for next steps")
                    
            elif action == 'type' and ('sms' in step_id.lower() or 'SMS' in step_id or 'code' in step_id.lower()):
                # –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ SMS —à–∞–≥–æ–≤: enter_sms, enter_sms_code, enter_code –∏ —Ç.–¥.
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π SMS –∫–æ–¥
                if not received_sms_code:
                    logger.error(f"‚ùå No SMS code available from previous step")
                    return False
                
                success = await execute_unified_sms_input_step(driver, wait, step, step_id, received_sms_code)
                if not success:
                    logger.error(f"‚ùå SMS input step failed")
                    return False
                    
            elif action == 'switch_to_default_content':
                # –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É –∫–æ–Ω—Ç–µ–Ω—Ç—É –∏–∑ iframe
                from unified_rpa_helpers import execute_unified_iframe_back_step
                success = await execute_unified_iframe_back_step(driver, wait, step, step_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required iframe back step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional iframe back step {step_id} failed, but continuing...")
                    
            elif action == 'switch_to_frame':
                # –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ iframe
                from unified_rpa_helpers import execute_unified_iframe_step
                success = await execute_unified_iframe_step(driver, wait, step, step_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required iframe switch step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional iframe switch step {step_id} failed, but continuing...")
                    
            elif action == 'extract_qr_link':
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ QR –∫–æ–¥–æ–≤ - –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                success = await execute_unified_qr_extraction_step(driver, step, step_id, telegram_id)
                if not success:
                    logger.error(f"‚ùå QR extraction step failed")
                    return False
                    
            elif action == 'wait_for_navigation':
                # –û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ—Å–ª–µ QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                url_contains = step.get('url_contains')
                timeout = step.get('timeout', 300000)  # 5 –º–∏–Ω—É—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                check_interval = step.get('check_interval', 3)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
                exclude_urls = step.get('exclude_urls', [])
                
                logger.info(f"‚è±Ô∏è Waiting for navigation to URL containing '{url_contains}' (timeout: {timeout/1000}s)")
                
                import time
                start_time = time.time()
                initial_url = driver.current_url
                
                logger.info(f"üìã Starting URL: {initial_url}")
                logger.info(f"üîç Looking for signs of successful authorization (not just URL change)...")
                
                # –î–ª—è QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ü–û–Ø–í–õ–ï–ù–ò–ï —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                # –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±–∏—Ä–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä –∫–æ—Ä–∑–∏–Ω—ã - –æ–Ω –µ—Å—Ç—å –∏ —É –Ω–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!
                auth_success_selectors = [
                    # –¢–û–õ–¨–ö–û —ç–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ—Ñ–∏–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//a[@target='_self' and @href='/my/main']",  # –°–∞–º—ã–π —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π
                    "//a[contains(@href, '/my/main')]",
                    "//a[contains(@href, '/my')]", 
                    # –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ë–ï–ó –∫–æ—Ä–∑–∏–Ω—ã!)
                    "//div[contains(@class, 'user') or contains(@class, 'profile') or contains(@class, 'account')]",
                    # –ê–≤–∞—Ç–∞—Ä –∏–ª–∏ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//div[contains(@class, 'avatar') or contains(@class, 'username')]",
                    # –û–±—â–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//*[contains(@class, 'authenticated') or contains(@data-testid, 'user')]"
                ]
                
                while (time.time() - start_time) * 1000 < timeout:
                    try:
                        current_url = driver.current_url
                        elapsed_seconds = time.time() - start_time
                        
                        # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                        if int(elapsed_seconds) % 30 == 0 and elapsed_seconds > 0:
                            logger.info(f"‚è≥ Waiting for user to authorize via QR... {elapsed_seconds:.0f}s elapsed")
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                        found_auth_element = False
                        for auth_selector in auth_success_selectors:
                            try:
                                from selenium.webdriver.common.by import By
                                elements = driver.find_elements(By.XPATH, auth_selector)
                                visible_elements = [el for el in elements if el.is_displayed()]
                                
                                if visible_elements:
                                    logger.info(f"‚úÖ Found auth element: {auth_selector}")
                                    found_auth_element = True
                                    break
                                    
                            except Exception as e:
                                continue
                        
                        if found_auth_element:
                            logger.info(f"‚úÖ Navigation successful! User authorized via QR after {elapsed_seconds:.1f}s")
                            logger.info(f"üîó Final URL: {current_url}")
                            success = True
                            break
                        
                        # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
                        await asyncio.sleep(check_interval)
                        
                    except Exception as nav_error:
                        logger.debug(f"‚ö†Ô∏è Navigation check error: {nav_error}")
                        await asyncio.sleep(check_interval)
                        continue
                        
                else:
                    # –¢–∞–π–º–∞—É—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç
                    elapsed_minutes = (time.time() - start_time) / 60
                    current_url = driver.current_url
                    logger.warning(f"‚è∞ QR authorization timeout after {elapsed_minutes:.1f}m. Current URL: {current_url}")
                    
                    # –î–ª—è QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Ç–∞–π–º–∞—É—Ç –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                    if step_id == 'wait_for_auth_success':
                        logger.info("‚ö†Ô∏è QR auth timeout - user did not complete authorization in time")
                        success = False  # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
                    else:
                        logger.error(f"‚ùå Navigation timeout for step {step_id}")
                        return False
                    
            elif action == 'wait_for' and step.get('success'):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                success = await execute_unified_auth_verification(driver, step, wait)
                if success:
                    logger.info(f"‚úÖ Authentication successful!")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è Auth verification failed, but continuing...")
            
            elif action == 'verify_address':
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏
                from selenium.webdriver.common.by import By
                from selenium.common.exceptions import NoSuchElementException
                
                address_selectors = step.get('selectors', [])
                timeout_ms = step.get('timeout', 5000)
                is_optional = step.get('optional', True)
                skip_steps_on_success = step.get('skip_steps_on_success', [])
                
                logger.info(f"üè† Checking if delivery address is already set...")
                logger.info(f"   Selectors: {address_selectors}")
                logger.info(f"   Will skip steps on success: {skip_steps_on_success}")
                
                address_found = False
                found_selector = None
                
                import time
                start_time = time.time()
                timeout_sec = timeout_ms / 1000
                
                while (time.time() - start_time) < timeout_sec:
                    for selector in address_selectors:
                        try:
                            if selector.startswith('//'):
                                element = driver.find_element(By.XPATH, selector)
                            else:
                                element = driver.find_element(By.CSS_SELECTOR, selector)
                            
                            if element.is_displayed():
                                address_found = True
                                found_selector = selector
                                break
                        except NoSuchElementException:
                            continue
                    
                    if address_found:
                        break
                    
                    await asyncio.sleep(0.2)
                
                if address_found:
                    logger.info(f"‚úÖ Address already set! Found element: {found_selector}")
                    
                    # –°–æ–∑–¥–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ ID —à–∞–≥–æ–≤ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞
                    steps_to_skip = set(skip_steps_on_success)
                    
                    # –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –æ—Å—Ç–∞–≤—à–∏–º—Å—è —à–∞–≥–∞–º –∏ –ø–æ–º–µ—á–∞–µ–º –∏—Ö –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞
                    for future_step in steps[steps.index(step) + 1:]:
                        future_step_id = future_step.get('id', '')
                        if future_step_id in steps_to_skip:
                            # –ü–æ–º–µ—á–∞–µ–º —à–∞–≥ –∫–∞–∫ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–π
                            future_step['_skip'] = True
                            logger.info(f"   ‚è≠Ô∏è  Will skip step: {future_step_id}")
                    
                    logger.info(f"‚úÖ verify_address complete - {len(steps_to_skip)} steps will be skipped")
                    success = True
                else:
                    elapsed = time.time() - start_time
                    logger.info(f"‚ÑπÔ∏è  Address not set after {elapsed:.1f}s - will proceed with address setup steps")
                    success = True  # –ù–µ –æ—à–∏–±–∫–∞ - –ø—Ä–æ—Å—Ç–æ –∞–¥—Ä–µ—Å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º optional flag
                if not success and not is_optional:
                    logger.error(f"‚ùå Required verify_address step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional verify_address step {step_id} failed, but continuing...")
                    
            elif action == 'save_address':
                # –ù–æ–≤—ã–π action: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏
                from unified_rpa_helpers import execute_save_address_step
                # –ü–µ—Ä–µ–¥–∞–µ–º lsd_config.id –≤ step –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –Ω—É–∂–Ω—É—é —Å–µ—Å—Å–∏—é
                step_with_lsd_id = step.copy()
                step_with_lsd_id['lsd_config_id'] = lsd_config.id if hasattr(lsd_config, 'id') else None
                
                success = await execute_save_address_step(driver, step_with_lsd_id, step_id, telegram_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required save_address step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional save_address step {step_id} failed, but continuing...")
                else:
                    logger.info(f"‚úÖ Address saved successfully for step {step_id}")
                    
            else:
                logger.debug(f"‚ö†Ô∏è Skipping step {step_id} ({action}) - not implemented")
                continue
            
            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —à–∞–≥–∞–º–∏
            step_pause = step.get('wait_after', 1000) / 1000
            if step_pause > 0:
                logger.info(f"‚è≥ Pausing {step_pause}s after step {step_id}...")
                await asyncio.sleep(step_pause)
        
        logger.info(f"‚úÖ Completed all RPA steps for {lsd_name}")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error in unified auth interactions: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def get_user_phone(telegram_id: int) -> Optional[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()
            
            if user and user.phone:
                logger.info(f"‚úÖ Found phone for user {telegram_id}: {user.phone[:3]}***{user.phone[-4:]}")
                return user.phone
            else:
                logger.error(f"‚ùå No phone found for user {telegram_id}")
                return None
                
    except Exception as e:
        logger.error(f"‚ùå Error getting user phone: {e}")
        return None




# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Ñ–ª–æ—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
async def execute_click_step(driver, wait, step: dict, step_id: str) -> bool:
    """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–ª–∏–∫–∞ –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for click step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
            else:
                element = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
            
            driver.execute_script("arguments[0].scrollIntoView(true);", element)
            await asyncio.sleep(0.5)
            element.click()
            
            logger.info(f"‚úÖ Successfully clicked element with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Selector failed: {selector}")
            continue
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error with selector '{selector}': {e}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not click any selector for step {step_id}")
    return False

async def execute_wait_for_step(driver, wait, step: dict, step_id: str) -> bool:
    """–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for wait_for step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            logger.info(f"‚úÖ Found element with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Wait selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not find any selector for wait_for step {step_id}")
    return False

async def execute_clear_step(driver, wait, step: dict, step_id: str) -> bool:
    """–û—á–∏—Å—Ç–∫–∞ –ø–æ–ª—è –≤–≤–æ–¥–∞"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for clear_and_wait step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            element.clear()
            logger.info(f"‚úÖ Cleared field with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Clear selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not clear field for step {step_id}")
    return False

async def execute_phone_input_step(driver, wait, step: dict, step_id: str, telegram_id: int) -> bool:
    """–í–≤–æ–¥ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    phone_number = await get_user_phone_number(telegram_id)
    if not phone_number:
        logger.error(f"‚ùå No phone number found for user {telegram_id}")
        return False
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –Ω–æ–º–µ—Ä —Å–æ–≥–ª–∞—Å–Ω–æ –∫–æ–Ω—Ñ–∏–≥—É
    phone_value = step.get('value', '{phone_without_7}')
    if '{phone_without_7}' in phone_value:
        # –£–±–∏—Ä–∞–µ–º +7 –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º
        clean_phone = phone_number.replace('+7', '').replace('+', '')
        formatted_phone = phone_value.replace('{phone_without_7}', clean_phone)
    else:
        formatted_phone = phone_number
    
    logger.info(f"üì± Entering phone number: {formatted_phone[:3]}***{formatted_phone[-4:]}")
    
    # –í–≤–æ–¥–∏–º –Ω–æ–º–µ—Ä
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for phone input step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            element.clear()
            element.send_keys(formatted_phone)
            logger.info(f"‚úÖ Successfully entered phone number with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Phone input selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not enter phone number for step {step_id}")
    return False

async def get_user_phone_number(telegram_id: int) -> Optional[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            from shared.database.models import User
            result = await db.execute(
                select(User.phone).where(User.telegram_id == telegram_id)
            )
            phone = result.scalar_one_or_none()
            
            if phone:
                logger.info(f"üì± Found phone number for user {telegram_id}: {phone[:3]}***{phone[-4:]}")
                return phone
            else:
                logger.error(f"‚ùå No phone number found for user {telegram_id}")
                return None
            
    except Exception as e:
        logger.error(f"‚ùå Database error getting phone number: {e}")
        return None



async def execute_sms_input_step(driver, wait, step: dict, step_id: str, sms_code: str) -> bool:
    """–í–≤–æ–¥ SMS –∫–æ–¥–∞ –ø–æ—Å–∏–º–≤–æ–ª—å–Ω–æ"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for SMS input step {step_id}")
        return False
    
    logger.info(f"üì± Entering SMS code: {sms_code}")
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –ø–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥
    individual_inputs = step.get('individual_inputs', False)
    
    if individual_inputs:
        # –ü–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        logger.info(f"üì± Using individual character input for SMS code")
        
        for i, char in enumerate(sms_code):
            for selector in selectors:
                try:
                    # –ò—â–µ–º –ø–æ–ª–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                    if selector.startswith('//'):
                        elements = driver.find_elements(By.XPATH, selector)
                    else:
                        elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    
                    if i < len(elements):
                        element = elements[i]
                        element.clear()
                        element.send_keys(char)
                        await asyncio.sleep(0.3)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏
                        logger.debug(f"‚úÖ Entered character {i+1}/{len(sms_code)}")
                        break
                        
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Error entering character {char}: {e}")
                    continue
        
        logger.info(f"‚úÖ Successfully entered SMS code character by character")
        return True
    
    else:
        # –û–±—ã—á–Ω—ã–π –≤–≤–æ–¥ –≤ –æ–¥–Ω–æ –ø–æ–ª–µ
        for selector in selectors:
            try:
                if selector.startswith('//'):
                    element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                else:
                    element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                
                element.clear()
                element.send_keys(sms_code)
                logger.info(f"‚úÖ Successfully entered SMS code with selector: {selector}")
                return True
                
            except (TimeoutException, NoSuchElementException):
                logger.debug(f"‚ö†Ô∏è SMS input selector failed: {selector}")
                continue
    
    logger.warning(f"‚ö†Ô∏è Could not enter SMS code for step {step_id}")
    return False

async def verify_auth_success(driver, step: dict, wait) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        selectors = step.get('selectors', [])
        if not selectors:
            logger.warning(f"‚ö†Ô∏è No selectors for auth verification")
            return False
        
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import TimeoutException
        
        for selector in selectors:
            try:
                if selector.startswith('//'):
                    element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                else:
                    element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                
                logger.info(f"‚úÖ Auth verification successful with selector: {selector}")
                return True
                
            except TimeoutException:
                logger.debug(f"‚ö†Ô∏è Auth verification selector failed: {selector}")
                continue
        
        logger.warning(f"‚ö†Ô∏è Could not verify auth success")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Error in auth verification: {e}")
        return False

# execute_auth_steps() –£–î–ê–õ–ï–ù–ê - –≤—Å–µ –õ–°–î –∏—Å–ø–æ–ª—å–∑—É—é—Ç perform_auth_interactions() —Å unified_rpa_helpers

async def execute_selenium_auth_flow(telegram_id: int, lsd_config: LSDConfig, auth_config: dict):
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –õ–°–î - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –°–∞–º–æ–∫–∞—Ç, –∏ –í–∫—É—Å–í–∏–ª–ª"""
    logger.info(f"üîÑ Starting unified CDP auth flow for {lsd_config.display_name} (user: {telegram_id})")
    
    cdp_manager = None
    
    try:
        # –®–ê–ì 1: –°–æ–∑–¥–∞–µ–º –ü–£–°–¢–£–Æ —Å–µ—Å—Å–∏—é –î–û –Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        from session_initializer import create_initial_session, update_session_with_cookies
        
        session_created = await create_initial_session(
            telegram_id=telegram_id,
            lsd_config_id=lsd_config.id,
            lsd_name=lsd_config.name
        )
        
        if not session_created:
            logger.error(f"‚ùå Failed to create initial session")
            await notify_user_auth_error(telegram_id, lsd_config.display_name, "Failed to initialize session")
            return
        
        logger.info(f"‚úÖ Initial session created/verified")
        
        # –ù–û–í–û–ï: –ß–∏—Ç–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        page_load_strategy = auth_config.get('page_load_strategy', 'none')
        navigation_wait_after = auth_config.get('navigation_wait_after', 0)
        
        logger.info(f"‚öôÔ∏è Page load strategy: '{page_load_strategy}'")
        if navigation_wait_after > 0:
            logger.info(f"‚è±Ô∏è Navigation wait after: {navigation_wait_after}ms")
        else:
            logger.debug(f"‚ÑπÔ∏è No navigation_wait_after configured (0ms)")
        
        # –®–ê–ì 2: –°–æ–∑–¥–∞–µ–º –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å –±—Ä–∞—É–∑–µ—Ä–∞
        from pathlib import Path
        profile_dir = Path(__file__).parent / "browser_profiles" / f"user_{telegram_id}_lsd_{lsd_config.name}"
        profile_dir.mkdir(parents=True, exist_ok=True)

        profile_exists = (profile_dir / "Default").exists()
        if profile_exists:
            logger.info(f"üìÅ Using existing persistent profile: {profile_dir}")
        else:
            logger.info(f"üìÅ Creating new persistent profile: {profile_dir}")

        # –®–ê–ì 2.1: –°–æ–∑–¥–∞–µ–º –±—Ä–∞—É–∑–µ—Ä (—Å CDP –∏–ª–∏ –±–µ–∑ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ñ–∏–≥–∞)
        cdp_enabled = auth_config.get('cdp_enabled', True)  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é CDP –≤–∫–ª—é—á–µ–Ω

        if cdp_enabled:
            logger.info(f"üîß Using CDP browser (cdp_enabled=true in config)")
            logger.info(f"üîß Initializing CDP manager for auth...")
            cdp_manager = CDPCookieManager(page_load_strategy=page_load_strategy)

            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä —Å CDP
            # block_media –ù–ï —É–∫–∞–∑—ã–≤–∞–µ–º = False –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é = –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã –¥–ª—è QR-–∫–æ–¥–æ–≤
            driver = cdp_manager.setup_browser_with_cdp()
            logger.info(f"‚úÖ CDP browser created for auth (NORMAL MODE - QR codes will work)")
            logger.warning(f"‚ö†Ô∏è CDP browser does NOT support persistent profiles - profile will not be saved")
        else:
            logger.info(f"üöó Using SIMPLE browser WITHOUT CDP (cdp_enabled=false in config)")
            logger.info(f"üéØ Strategy: Maximum simplicity for bypassing strict antibot protection")

            from simple_browser_manager import SimpleUndetectedBrowser
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –º–æ–±–∏–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
            mobile_mode = lsd_config.rpa_config.get('mobile_mode', False) if lsd_config.rpa_config else False
            logger.info(f"üì± Mobile mode: {'ENABLED' if mobile_mode else 'DISABLED'}")
            driver = SimpleUndetectedBrowser.create_simple_browser(
                headless=settings.rpa_headless,
                mobile_mode=mobile_mode,
                page_load_strategy=page_load_strategy,
                user_data_dir=str(profile_dir)  # –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–ï–†–°–ò–°–¢–ï–ù–¢–ù–´–ô –ü–†–û–§–ò–õ–¨
                # block_media –ù–ï —É–∫–∞–∑—ã–≤–∞–µ–º = –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é False = –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã –¥–ª—è QR-–∫–æ–¥–æ–≤
            )
            cdp_manager = None  # –ù–µ—Ç CDP –º–µ–Ω–µ–¥–∂–µ—Ä–∞
            logger.info(f"‚úÖ SIMPLE browser created for auth with persistent profile (NO CDP = NO detection)")
            logger.info(f"üíæ Profile will be automatically saved on browser close")
        
        # –®–ê–ì 3: –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ auth_url –≤ –∫–æ–Ω—Ñ–∏–≥–µ, –µ—Å–ª–∏ –Ω–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º base_url
        auth_url = auth_config.get('auth_url') or lsd_config.base_url
        
        if auth_config.get('auth_url'):
            logger.info(f"üîê Using auth_url from config: {auth_url}")
        else:
            logger.info(f"üîê Using base_url as auth_url (fallback): {auth_url}")
        
        logger.info(f"üîê Navigating to auth page: {auth_url}")
        
        # –ë–´–°–¢–†–ê–Ø –ù–ê–í–ò–ì–ê–¶–ò–Ø: –Ω–µ –∂–¥–µ–º –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏, –∞ –∏—â–µ–º –Ω—É–∂–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
        # –ü–æ–ª—É—á–∞–µ–º wait_for —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        steps = auth_config.get('steps', [])
        first_step = steps[0] if steps else None
        wait_for_selectors = []
        if first_step and first_step.get('action') == 'navigate':
            wait_for_config = first_step.get('wait_for', {})
            wait_for_selectors = wait_for_config.get('selectors', [])
            wait_for_timeout = first_step.get('timeout', 15000) / 1000
        
        if wait_for_selectors:
            logger.info(f"üöÄ Fast navigation with wait_for: {len(wait_for_selectors)} selectors, timeout={wait_for_timeout}s")
            
            # –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ë–ï–ó –û–ñ–ò–î–ê–ù–ò–Ø
            import time
            from selenium.webdriver.common.by import By
            
            driver.get(auth_url)
            start_time = time.time()
            
            # –°—Ä–∞–∑—É –ø–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—â–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
            selector_found = False
            while (time.time() - start_time) < wait_for_timeout:
                for selector in wait_for_selectors:
                    try:
                        if selector.startswith('//'):
                            elements = driver.find_elements(By.XPATH, selector)
                        else:
                            elements = driver.find_elements(By.CSS_SELECTOR, selector)
                        
                        for element in elements:
                            if element.is_displayed():
                                elapsed = time.time() - start_time
                                logger.info(f"‚úÖ Found selector after {elapsed:.1f}s: {selector}")
                                selector_found = True
                                break
                        
                        if selector_found:
                            break
                    except Exception:
                        continue
                
                if selector_found:
                    break
                
                await asyncio.sleep(0.1)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 100–º—Å
            
            if not selector_found:
                elapsed = time.time() - start_time
                logger.warning(f"‚ö†Ô∏è No wait_for selectors found after {elapsed:.1f}s, but continuing...")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML –¥–∞–º–ø –ø—Ä–∏ —Ç–∞–π–º–∞—É—Ç–µ wait_for –≤ navigate
                from unified_rpa_helpers import save_page_html_dump
                await save_page_html_dump(driver, "navigate_wait_for", "timeout")
        else:
            # –û–±—ã—á–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –±–µ–∑ wait_for
            logger.info(f"üåê Standard navigation (no wait_for selectors)")
            driver.get(auth_url)
        
        # –ù–û–í–û–ï: –ü–†–ò–ú–ï–ù–Ø–ï–ú navigation_wait_after –ü–û–°–õ–ï –ó–ê–ì–†–£–ó–ö–ò –°–¢–†–ê–ù–ò–¶–´
        if navigation_wait_after > 0:
            wait_seconds = navigation_wait_after / 1000
            logger.info(f"‚è±Ô∏è Waiting {wait_seconds}s after page load (navigation_wait_after)")
            await asyncio.sleep(wait_seconds)

        # –ü–†–ò–ú–ï–ù–Ø–ï–ú ANTIBOT –°–¢–†–ê–¢–ï–ì–ò–ò –ü–û–°–õ–ï –ù–ê–í–ò–ì–ê–¶–ò–ò –ò –ó–ê–î–ï–†–ñ–ö–ò
        logger.info(f"üõ°Ô∏è Applying antibot strategies for {lsd_config.display_name}...")
        try:
            from selenium_antibot_strategies import apply_antibot_for_lsd
            antibot_success = apply_antibot_for_lsd(driver, lsd_config.name, lsd_config.rpa_config)
            if antibot_success:
                logger.info(f"‚úÖ Antibot strategies applied successfully")
            else:
                logger.warning(f"‚ö†Ô∏è Antibot strategies partially failed, but continuing...")
        except Exception as antibot_error:
            logger.warning(f"‚ö†Ô∏è Failed to apply antibot strategies: {antibot_error}, but continuing...")
        
        # –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê RPA –®–ê–ì–û–í
        logger.info(f"ü§ñ Starting unified auth interactions...")
        success = await perform_auth_interactions(driver, auth_config, lsd_config.display_name, telegram_id, lsd_config)
        
        if success:
            logger.info(f"‚úÖ Unified auth interactions completed successfully")
            
            # –®–ê–ì 4: –ü–æ–ª—É—á–∞–µ–º –∫—É–∫–∏ + localStorage + sessionStorage –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
            local_storage = {}
            session_storage = {}
            if cdp_manager:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º CDP –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è cookies + localStorage + sessionStorage
                session_data = cdp_manager.extract_cookies_and_storage()
                cookies = session_data['cookies']
                local_storage = session_data['localStorage']
                session_storage = session_data['sessionStorage']
                logger.info(f"üç™ Extracted {len(cookies)} cookies + {len(local_storage)} localStorage + {len(session_storage)} sessionStorage items via CDP")
            else:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π Selenium API (—Ç–æ–ª—å–∫–æ cookies, storage –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)
                from simple_browser_manager import SimpleUndetectedBrowser
                cookies = SimpleUndetectedBrowser.extract_cookies(driver)
                logger.info(f"üç™ Extracted {len(cookies)} cookies via Selenium API (no storage support)")
            
            if cookies:
                # –®–ê–ì 5: –û–±–Ω–æ–≤–ª—è–µ–º –°–£–©–ï–°–¢–í–£–Æ–©–£–Æ —Å–µ—Å—Å–∏—é –∫—É–∫–∞–º–∏ + localStorage + sessionStorage (–≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π)
                from session_initializer import update_session_with_cookies
                
                saved = await update_session_with_cookies(telegram_id, lsd_config.id, cookies, local_storage, session_storage)
                
                if saved:
                    logger.info(f"‚úÖ Cookies saved successfully to existing session")

                    # –ù–û–í–û–ï: –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ CDP, –Ω—É–∂–Ω–æ —Ç–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å cookies –≤ persistent profile
                    # —á—Ç–æ–±—ã –æ–Ω–∏ –±—ã–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –ø—Ä–∏ /browse
                    if cdp_manager:
                        logger.info(f"üíæ CDP used - saving cookies to persistent profile for /browse command...")
                        try:
                            from simple_browser_manager import SimpleUndetectedBrowser

                            # –û—Ç–∫—Ä—ã–≤–∞–µ–º Simple browser —Å profile
                            temp_driver = SimpleUndetectedBrowser.create_simple_browser(
                                headless=True,  # –°–∫—Ä—ã—Ç—ã–π —Ä–µ–∂–∏–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –∑–∞–ø–∏—Å–∏
                                user_data_dir=str(profile_dir),
                                block_media=True  # –ë–ª–æ–∫–∏—Ä—É–µ–º –º–µ–¥–∏–∞ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                            )

                            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ –±–∞–∑–æ–≤—ã–π URL (–Ω—É–∂–Ω–æ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ cookies)
                            temp_driver.get(lsd_config.base_url)
                            await asyncio.sleep(1)

                            # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ cookies
                            temp_driver.delete_all_cookies()

                            # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ cookies –∏–∑ CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                            cookies_added = 0
                            for cookie in cookies:
                                try:
                                    temp_driver.add_cookie(cookie)
                                    cookies_added += 1
                                except Exception as cookie_error:
                                    logger.debug(f"   ‚ö†Ô∏è Skipped cookie {cookie.get('name')}: {cookie_error}")

                            logger.info(f"‚úÖ Added {cookies_added}/{len(cookies)} cookies to persistent profile")

                            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä - –ø—Ä–æ—Ñ–∏–ª—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è
                            temp_driver.quit()

                            logger.info(f"‚úÖ Cookies saved to persistent profile: {profile_dir}")
                            logger.info(f"üí° Now /browse command will work with authenticated session")

                        except Exception as profile_save_error:
                            logger.warning(f"‚ö†Ô∏è Failed to save cookies to persistent profile: {profile_save_error}")
                            logger.warning(f"   /browse command may not work properly")

                    logger.info(f"üì£ Calling notify_user_auth_success for user {telegram_id}...")
                    await notify_user_auth_success(telegram_id, lsd_config.display_name, len(cookies))
                    logger.info(f"‚úÖ notify_user_auth_success completed")
                else:
                    logger.error(f"‚ùå Failed to update session with cookies")
                    await notify_user_auth_error(telegram_id, lsd_config.display_name, "Failed to save cookies")
            else:
                logger.error(f"‚ùå No cookies extracted after auth")
                await notify_user_auth_error(telegram_id, lsd_config.display_name, "No cookies found")
        else:
            logger.error(f"‚ùå Unified auth interactions failed")
            await notify_user_auth_error(telegram_id, lsd_config.display_name, "Auth interactions failed")
            
    except Exception as e:
        logger.error(f"‚ùå Error in unified CDP auth flow: {e}")
        import traceback
        logger.error(traceback.format_exc())
        await notify_user_auth_error(telegram_id, lsd_config.display_name, str(e))
        
    finally:
        # –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        if cdp_manager:
            try:
                logger.info(f"üßπ Cleaning up CDP browser...")
                cdp_manager.cleanup()
                logger.info(f"‚úÖ CDP cleanup completed")
                logger.info(f"‚ö†Ô∏è CDP browser does not save persistent profile")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up CDP: {cleanup_error}")
        elif 'driver' in locals() and driver:
            try:
                logger.info(f"üßπ Cleaning up SIMPLE browser with persistent profile...")
                from simple_browser_manager import SimpleUndetectedBrowser
                SimpleUndetectedBrowser.close_browser(driver)
                logger.info(f"‚úÖ SIMPLE browser cleanup completed")

                # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
                if 'profile_dir' in locals():
                    logger.info(f"üíæ Browser profile automatically saved to: {profile_dir}")
                    logger.info(f"üíæ Profile contains: cookies, localStorage, IndexedDB, Service Workers, Cache, fingerprint")

            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up simple browser: {cleanup_error}")
# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def notify_user_about_auth_start(telegram_id: int, display_name: str, base_url: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": base_url,
                    "action": "auth_start",
                    "message": f"üîê –û—Ç–∫—Ä—ã—Ç –±—Ä–∞—É–∑–µ—Ä –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}. –ü—Ä–æ–π–¥–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ –æ—Ç–∫—Ä—ã–≤—à–µ–º—Å—è –æ–∫–Ω–µ –±—Ä–∞—É–∑–µ—Ä–∞."
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth start: {e}")

async def notify_user_auth_progress(telegram_id: int, elapsed: int, total: int):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        minutes_elapsed = elapsed // 60
        minutes_total = total // 60
        
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚è≥ –ü—Ä–æ—à–ª–æ {minutes_elapsed}/{minutes_total} –º–∏–Ω. –û–∂–∏–¥–∞—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...",
                    "action": "auth_progress",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth progress: {e}")

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è message_id —Å–æ–æ–±—â–µ–Ω–∏–π —Å QR —Å—Å—ã–ª–∫–∞–º–∏
qr_message_ids: dict[int, int] = {}

async def save_qr_message_id(telegram_id: int, message_id: int):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    logger.info(f"üíæ Saving QR message_id {message_id} for user {telegram_id}")
    await _save_qr_message_id_to_db(telegram_id, message_id)
    logger.info(f"‚úÖ QR message_id saved to DB")

async def _save_qr_message_id_to_db(telegram_id: int, message_id: int):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±–∞–∑—É"""
    try:
        async for db in get_async_session():
            await db.execute(
                update(User)
                .where(User.telegram_id == telegram_id)
                .values(sms_code=str(message_id))  # –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º sms_code
            )
            await db.commit()
            break
    except Exception as e:
        logger.error(f"‚ùå Error saving message_id to DB: {e}")

async def get_qr_message_id(telegram_id: int) -> int | None:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π –∏–∑ –±–∞–∑—ã"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(User.sms_code).where(User.telegram_id == telegram_id)
            )
            sms_code = result.scalar_one_or_none()
            
            if sms_code and sms_code.isdigit():
                message_id = int(sms_code)
                # –û—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
                await db.execute(
                    update(User)
                    .where(User.telegram_id == telegram_id)
                    .values(sms_code=None)
                )
                await db.commit()
                return message_id
            break
    except Exception as e:
        logger.error(f"‚ùå Error getting message_id from DB: {e}")
    return None

async def notify_user_auth_success(telegram_id: int, display_name: str, cookies_count: int):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        
        # –ü–æ–ª—É—á–∞–µ–º message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π
        qr_message_id = await get_qr_message_id(telegram_id)
        logger.info(f"üéØ Retrieved qr_message_id for user {telegram_id}: {qr_message_id}")
        
        payload = {
            "telegram_id": telegram_id,
            "message": f"‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ {display_name} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!",
            "action": "auth_complete",
            "qr_message_id": qr_message_id,  # –î–æ–±–∞–≤–ª—è–µ–º message_id
            "result": {
                "lsd_name": display_name.lower().replace(" ", "_"),
                "display_name": display_name,
                "cookies_count": cookies_count
            }
        }
        
        logger.info(f"üì§ Sending auth success to telegram-bot: {payload}")
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8001/rpa/auth-success",
                json=payload,
                timeout=5.0
            )
            
            logger.info(f"‚úÖ Auth success notification sent, response: {response.status_code}")
            
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth success: {e}")
        import traceback
        logger.error(traceback.format_exc())

async def notify_user_auth_timeout(telegram_id: int, display_name: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ç–∞–π–º–∞—É—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚ùå –¢–∞–π–º–∞—É—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                    "action": "auth_timeout",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth timeout: {e}")

async def notify_user_auth_error(telegram_id: int, display_name: str, error_message: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}: {error_message}",
                    "action": "auth_error",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth error: {e}")

async def save_user_cookies_to_db(telegram_id: int, lsd_config_id: int, cookies: list) -> bool:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—É–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            # –ü–æ–ª—É—á–∞–µ–º –∏–º—è –∏ –∞–¥—Ä–µ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_result = await db.execute(
                select(User.first_name, User.last_name, User.address).where(User.telegram_id == telegram_id)
            )
            user_data = user_result.first()
            
            if user_data:
                first_name, last_name, address = user_data
                user_name = f"{first_name or ''} {last_name or ''}".strip() or f"User {telegram_id}"
            else:
                user_name = f"User {telegram_id}"
                address = None
            
            logger.info(f"üë§ User name: {user_name}")
            if address:
                logger.info(f"üè† User address: {address[:50]}...")
            
            # –ü–æ–ª—É—á–∞–µ–º lsd_name –ø–æ lsd_config_id
            lsd_result = await db.execute(
                select(LSDConfig.name).where(LSDConfig.id == lsd_config_id)
            )
            lsd_name = lsd_result.scalar_one_or_none()
            
            if not lsd_name:
                logger.error(f"‚ùå Could not find lsd_name for lsd_config_id={lsd_config_id}")
                lsd_name = f"lsd_{lsd_config_id}"
            
            logger.info(f"üè™ LSD name: {lsd_name}")
            
            # –ù–∞—Ö–æ–¥–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
            result = await db.execute(
                select(UserSession).where(
                    UserSession.telegram_id == telegram_id,
                    UserSession.lsd_config_id == lsd_config_id
                )
            )
            session = result.scalar_one_or_none()
            
            if session:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é
                from datetime import datetime, timedelta
                session.data = {'cookies': cookies}
                session.expires_at = datetime.now() + timedelta(days=30)
                session.user_name = user_name
                session.lsd_name = lsd_name
                session.default_delivery_address = address  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞–¥—Ä–µ—Å
                logger.info(f"‚ôæÔ∏è Updated session {session.id}: user_name='{user_name}', lsd_name='{lsd_name}', address='{address[:30] if address else None}...'")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
                from datetime import datetime, timedelta
                expires_at = datetime.now() + timedelta(days=30)
                
                new_session = UserSession(
                    telegram_id=telegram_id,
                    lsd_config_id=lsd_config_id,
                    data={'cookies': cookies},
                    expires_at=expires_at,
                    user_name=user_name,
                    lsd_name=lsd_name,
                    default_delivery_address=address  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞–¥—Ä–µ—Å
                )
                db.add(new_session)
                logger.info(f"‚ûï Created session: user_name='{user_name}', lsd_name='{lsd_name}', address='{address[:30] if address else None}...'")
            
            await db.commit()
            logger.info(f"üíæ Successfully saved {len(cookies)} cookies to database")
            return True
            
    except Exception as e:
        logger.error(f"‚ùå Database error saving cookies: {e}")
        return False

@app.post("/browse/open")
async def browse_open(request: BrowseRequest):
    """
    –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –±—Ä–∞—É–∑–µ—Ä —Å –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–º –ø—Ä–æ—Ñ–∏–ª–µ–º (–∫–∞–∫ —Ä–µ–∞–ª—å–Ω—ã–π Chrome)
    –ö—É–∫–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ SQLite –±–∞–∑–µ Chrome - —Å–∞–π—Ç –Ω–µ –º–æ–∂–µ—Ç –∏—Ö –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å
    """
    logger.info(f"üåê Opening browser for user {request.telegram_id} @ {request.lsd_name} (timeout: {request.auto_close_timeout}s)")

    driver = None
    profile_dir = None

    try:
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –õ–°–î
        lsd_config = await get_lsd_config(request.lsd_name)
        if not lsd_config:
            raise HTTPException(
                status_code=404,
                detail=f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è {request.lsd_name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
            )

        # –ü—É—Ç—å –∫ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–º—É –ø—Ä–æ—Ñ–∏–ª—é
        from pathlib import Path
        profile_dir = Path(__file__).parent / "browser_profiles" / f"user_{request.telegram_id}_lsd_{request.lsd_name}"

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ—Ñ–∏–ª—å
        profile_exists = (profile_dir / "Default" / "Cookies").exists()

        if profile_exists:
            logger.info(f"üìÅ Using persistent profile: {profile_dir}")
            logger.info(f"‚ôªÔ∏è Profile exists with Cookies SQLite DB")
        else:
            logger.info(f"üìÅ Profile doesn't exist, will create: {profile_dir}")
            logger.info(f"üîß Creating new profile and injecting cookies from JSON...")

        # –ö–†–ò–¢–ò–ß–ù–û: –£–±–∏–≤–∞–µ–º –í–°–ï Chrome –ø—Ä–æ—Ü–µ—Å—Å—ã —Å —ç—Ç–∏–º –ø—Ä–æ—Ñ–∏–ª–µ–º –ü–ï–†–ï–î –∏–Ω—ä–µ–∫—Ü–∏–µ–π
        # Chrome –¥–µ—Ä–∂–∏—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –Ω–∞ SQLite –±–∞–∑—É –∏ –Ω–µ –≤–∏–¥–∏—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π
        logger.info(f"üî™ Killing any existing Chrome processes with this profile...")
        import subprocess
        profile_dir_str = str(profile_dir)
        
        try:
            # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ Chrome –ø—Ä–æ—Ü–µ—Å—Å—ã —Å —ç—Ç–∏–º user-data-dir
            result = subprocess.run(
                ['ps', 'aux'],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            killed_count = 0
            for line in result.stdout.split('\n'):
                if 'Chrome' in line and profile_dir_str in line:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º PID
                    parts = line.split()
                    if len(parts) >= 2:
                        try:
                            pid = int(parts[1])
                            subprocess.run(['kill', '-9', str(pid)], timeout=2)
                            killed_count += 1
                            logger.debug(f"   Killed Chrome process: {pid}")
                        except (ValueError, subprocess.TimeoutExpired):
                            continue
            
            if killed_count > 0:
                logger.info(f"‚úÖ Killed {killed_count} Chrome processes")
                # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ cleanup
                import time
                time.sleep(1)
            else:
                logger.info(f"‚ÑπÔ∏è No Chrome processes found (good!)")
                
        except Exception as kill_error:
            logger.warning(f"‚ö†Ô∏è Failed to kill Chrome processes: {kill_error}")
            # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º - –≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –Ω–µ—Ç

        # –ù–û–í–ê–Ø –°–¢–†–ê–¢–ï–ì–ò–Ø: –ò—Å–ø–æ–ª—å–∑—É–µ–º persistent profile –≤–º–µ—Å—Ç–æ CDP –∏–Ω—ä–µ–∫—Ü–∏–∏
        # –≠—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å session binding —Å METRO —Å–µ—Ä–≤–µ—Ä–æ–º

        base_url = lsd_config.base_url

        logger.info(f"üîß Opening browser with persistent profile: {profile_dir}")
        logger.info(f"üí° Cookies already in SQLite with Chrome encryption - no injection needed")

        from simple_browser_manager import SimpleUndetectedBrowser

        # –û—Ç–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø—Ä–æ—Ñ–∏–ª–µ–º
        # Cookies —É–∂–µ —Ç–∞–º, –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã Chrome Keychain, –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ —Å–µ—Å—Å–∏–∏
        driver = SimpleUndetectedBrowser.create_simple_browser(
            headless=False,  # –í–∏–¥–∏–º—ã–π —Ä–µ–∂–∏–º –¥–ª—è browse
            user_data_dir=str(profile_dir),
            block_media=False  # –†–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ –º–µ–¥–∏–∞ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ UX
        )

        logger.info(f"‚úÖ Browser opened with profile")

        # –ù–∞–≤–∏–≥–∞—Ü–∏—è –Ω–∞ —Å–∞–π—Ç
        logger.info(f"üìç Navigating to {base_url}...")
        driver.get(base_url)

        # –î–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞ –Ω–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏
        await asyncio.sleep(1)

        logger.info(f"‚úÖ Browser ready - cookies loaded from persistent profile")

        logger.info(f"‚è≥ Browser will stay open for {request.auto_close_timeout} seconds...")
        logger.info(f"üñ±Ô∏è You can interact with the browser during this time")
        logger.info(f"üíæ All changes will be saved to the persistent profile automatically")

        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –¥–ª—è –∞–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏—è –±—Ä–∞—É–∑–µ—Ä–∞
        async def auto_close_browser():
            """–§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –±—Ä–∞—É–∑–µ—Ä–∞"""
            try:
                await asyncio.sleep(request.auto_close_timeout)

                logger.info(f"üö™ Auto-closing browser for user {request.telegram_id}...")
                try:
                    driver.quit()
                    logger.info(f"‚úÖ Browser closed successfully")
                except Exception as quit_error:
                    logger.warning(f"‚ö†Ô∏è Error during quit: {quit_error}")
                    # Force kill if needed
                    try:
                        driver.service.process.terminate()
                    except:
                        pass

                logger.info(f"üíæ Profile preserved at: {profile_dir}")

            except Exception as e:
                logger.error(f"‚ùå Error in auto_close_browser task: {e}")

        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É (–Ω–µ –∂–¥–µ–º –µ—ë –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è)
        asyncio.create_task(auto_close_browser())

        # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç - –±—Ä–∞—É–∑–µ—Ä –æ—Ç–∫—Ä—ã—Ç
        return {
            "success": True,
            "data": {
                "message": f"Browser opened for {lsd_config.display_name}. Will auto-close in {request.auto_close_timeout}s",
                "cookies_loaded": 0,  # –ö—É–∫–∏ —É–∂–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ SQLite
                "auto_close_timeout": request.auto_close_timeout
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Error in browse_open: {e}")
        import traceback
        logger.error(traceback.format_exc())

        # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∑–∞–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ (–Ω–µ –æ—Å—Ç–∞–≤–ª—è–µ–º –≤–∏—Å–µ—Ç—å)
        if driver:
            try:
                logger.info(f"üßπ Cleaning up browser due to error...")
                driver.quit()
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up browser: {cleanup_error}")

        raise HTTPException(status_code=500, detail=str(e))

# –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
async def execute_rpa_flow(session_id: str, telegram_id: int, display_name: str, lsd_name: str):
    """–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è RPA —Ñ–ª–æ—É"""
    logger.info(f"üé≠ Executing RPA flow for session {session_id}")
    # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è RPA –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    pass

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8004)
