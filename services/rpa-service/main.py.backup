#!/usr/bin/env python3
"""
–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π RPA —Å–µ—Ä–≤–∏—Å —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Selenium
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

import re
import json
import logging
import asyncio
from typing import Dict, Any, Optional, List
from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel
import uvicorn
import urllib.parse as urlparse
import html
from decimal import Decimal
import time

# –ò–º–ø–æ—Ä—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞
from shared.database import get_async_session
from shared.database.models import LSDConfig, User, Order, OrderItem, LSDStock, UserSession
from shared.utils.text_normalizer import normalize_product_name
from order_quantity_calculator import calculate_order_quantity
from shared.utils.text_processing import get_word_synonyms, enhanced_lemmatize, normalize_and_extract_keywords, detect_processing_modifiers

from selenium_browser_manager_fixed import UndetectedBrowserManager

# –ò–ú–ü–û–†–¢ SELENIUM –ü–û–ò–°–ö–ê –¢–û–í–ê–†–û–í
from selenium_product_search import ProductSearchResult

# –ò–ú–ü–û–†–¢ CDP COOKIE MANAGER
from cdp_cookie_manager import CDPCookieManager

# –ò–ú–ü–û–†–¢ COOKIE FILE MANAGER
from cookie_file_manager import cookie_manager

# –ò–ú–ü–û–†–¢ –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–´–• RPA HELPERS
from unified_rpa_helpers import (
    execute_unified_click_step,
    execute_unified_hover_step,  # –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è!
    execute_scroll_step, 
    execute_unified_wait_for_step,
    execute_unified_clear_step,
    execute_unified_phone_input_step,
    request_unified_sms_code,
    execute_unified_sms_input_step,
    execute_unified_auth_verification,
    execute_unified_qr_extraction_step,
    execute_save_address_step  # –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–¥—Ä–µ—Å–∞!
)

from browser_profile_manager import profile_manager
from contextlib import asynccontextmanager

from shared.models.base import OrderStatus
from shared.utils.units import get_base_unit, convert_to_base_unit
from shared.utils.egg_categories import get_egg_category_coefficient, extract_egg_category, extract_egg_count_from_name
from sqlalchemy import select, update
from config.settings import settings
from shared.database.models import LSDStock
from sqlalchemy import delete
from datetime import datetime

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
from dotenv import load_dotenv
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –µ–¥–∏–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
from shared.utils.unified_logging import setup_service_logging
setup_service_logging('rpa-service', level=logging.INFO)
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
active_browser_sessions = {}
max_concurrent_sessions = 2
background_task = None

# =============== –§–£–ù–ö–¶–ò–Ø –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –ú–û–õ–û–ß–ù–´–• –ü–†–û–î–£–ö–¢–û–í ===============

def is_milk_product(product_name: str) -> bool:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–æ–¥—É–∫—Ç –º–æ–ª–æ—á–Ω—ã–º –ø–æ –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—é"""
    if not product_name:
        return False
    
    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    name_lower = product_name.lower()
    
    # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –º–æ–ª–æ—á–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤
    milk_keywords = [
        '–º–æ–ª–æ–∫–æ', 'milk', '–∫–µ—Ñ–∏—Ä', '—Ä—è–∂–µ–Ω–∫–∞', '—Å–ª–∏–≤–∫–∏', '–π–æ–≥—É—Ä—Ç',
        '—Ç–≤–æ—Ä–æ–≥', '—Å–º–µ—Ç–∞–Ω–∞', '–ø—Ä–æ—Å—Ç–æ–∫–≤–∞—à–∞', '–≤–∞—Ä–µ–Ω–µ—Ü', '–±–∏—Ñ–∏–¥–æ–∫',
        '—Å–Ω–µ–∂–æ–∫', '–∞—Ü–∏–¥–æ—Ñ–∏–ª–∏–Ω', '–ø–∞—Ö—Ç–∞', '—Å—ã–≤–æ—Ä–æ—Ç–∫–∞'
    ]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
    for keyword in milk_keywords:
        if keyword in name_lower:
            # –ò—Å–∫–ª—é—á–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–µ-–º–æ–ª–æ—á–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã
            exclude_keywords = ['—Å–≥—É—â–µ–Ω–∫–∞', '—Å–≥—É—â–µ–Ω–Ω–æ–µ', '—Å—É—Ö–æ–µ –º–æ–ª–æ–∫–æ', '–ø–æ—Ä–æ—à–æ–∫']
            if any(exclude in name_lower for exclude in exclude_keywords):
                return False
            return True
    
    return False

# =============== –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –†–ê–°–ß–ï–¢–ê MATCH_SCORE v2.0 ===============

def levenshtein_distance(s1: str, s2: str) -> int:
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –õ–µ–≤–µ–Ω—à—Ç–µ–π–Ω–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Å—Ç—Ä–æ–∫–∞–º–∏"""
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    
    if len(s2) == 0:
        return len(s1)
    
    previous_row = list(range(len(s2) + 1))
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]

def fuzzy_word_similarity(word1: str, word2: str) -> float:
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –Ω–µ—á—ë—Ç–∫–æ–π —Å—Ö–æ–∂–µ—Å—Ç–∏ –º–µ–∂–¥—É —Å–ª–æ–≤–∞–º–∏ (0.0 - 1.0)"""
    if word1 == word2:
        return 1.0
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω–æ–Ω–∏–º—ã –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞–ø–∏—Å–∞–Ω–∏—è
    synonyms = get_word_synonyms(word1)
    if word2 in synonyms:
        return 0.95
    
    # –ï—Å–ª–∏ –æ–¥–Ω–æ —Å–ª–æ–≤–æ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ –¥—Ä—É–≥–æ–º
    if word1 in word2 or word2 in word1:
        shorter = min(len(word1), len(word2))
        longer = max(len(word1), len(word2))
        return shorter / longer * 0.9
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –õ–µ–≤–µ–Ω—à—Ç–µ–π–Ω–∞
    max_len = max(len(word1), len(word2))
    if max_len == 0:
        return 1.0
    
    distance = levenshtein_distance(word1, word2)
    similarity = 1.0 - (distance / max_len)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ö–æ–∂–µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—ã—Å–æ–∫–∞—è
    return similarity if similarity >= 0.7 else 0.0

def calculate_advanced_match_score(search_query: str, found_name: str) -> tuple[float, bool]:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–∞—Å—á—ë—Ç match_score v5.3 - —Å —à—Ç—Ä–∞—Ñ–æ–º –∑–∞ –Ω–µ–∑–∞–ø—Ä–æ—à–µ–Ω–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –ø—Ä–æ–¥—É–∫—Ç–æ–≤"""
    if not search_query or not found_name:
        return 0.0, False
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤
    normalized_search_query = normalize_product_name(search_query)
    normalized_found_name = normalize_product_name(found_name)
    
    logger.debug(f"üßπ Normalized names for scoring:")
    logger.debug(f"   Search: '{search_query}' -> '{normalized_search_query}'")
    logger.debug(f"   Found:  '{found_name}' -> '{normalized_found_name}'")
    
    search_words = normalize_and_extract_keywords(normalized_search_query)
    found_words = normalize_and_extract_keywords(normalized_found_name)
    
    logger.debug(f"Enhanced match analysis: '{normalized_search_query}' -> {search_words} vs '{normalized_found_name}' -> {found_words}")
    
    if not search_words:
        return 0.3, False
    
    # –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –Ω–∞–±–æ—Ä–æ–≤ —Å–ª–æ–≤
    if set(search_words) == set(found_words):
        logger.debug("Exact keyword set match")
        return 1.0, True
    
    # –ü–æ–¥—Å—á—ë—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    total_search_words = len(search_words)
    total_found_words = len(found_words)
    match_score = 0.0
    exact_matches = 0
    fuzzy_matches = 0
    
    for search_word in search_words:
        best_match_score = 0.0
        found_exact = False
        
        for found_word in found_words:
            similarity = fuzzy_word_similarity(search_word, found_word)
            
            if similarity == 1.0:
                best_match_score = 1.0
                found_exact = True
                break
            elif similarity >= 0.95:
                best_match_score = max(best_match_score, 0.95)
            elif similarity >= 0.7:
                best_match_score = max(best_match_score, similarity * 0.8)
        
        if found_exact:
            exact_matches += 1
            match_score += 1.0
        elif best_match_score >= 0.7:
            fuzzy_matches += 1
            match_score += best_match_score
    
    base_score = match_score / total_search_words
    bonus = 0.0
    penalty = 0.0
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ
    has_full_coverage = (exact_matches + fuzzy_matches) >= total_search_words
    
    # –®—Ç—Ä–∞—Ñ –∑–∞ –¥–ª–∏–Ω—É
    word_count_ratio = total_found_words / total_search_words
    if word_count_ratio > 2.0:
        length_penalty = min(0.3, (word_count_ratio - 2.0) * 0.1)
        penalty += length_penalty
        logger.debug(f"‚ö†Ô∏è Length penalty: -{length_penalty:.2f}")
    
    # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –®–¢–†–ê–§ –∑–∞ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞
    if search_words and found_words:
        first_search_word = search_words[0]
        first_found_word = found_words[0]
        
        first_word_similarity = fuzzy_word_similarity(first_search_word, first_found_word)
        
        if first_word_similarity < 0.7:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ø-3
            found_in_top3 = False
            top3_position = -1
            for i, found_word in enumerate(found_words[:3]):
                if fuzzy_word_similarity(first_search_word, found_word) >= 0.8:
                    found_in_top3 = True
                    top3_position = i
                    break
            
            if not found_in_top3:
                # –ù–ï –≤ —Ç–æ–ø-3: —à—Ç—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø–æ–ª–Ω–æ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è
                if has_full_coverage:
                    first_word_mismatch_penalty = 0.25  # –ú—è–≥–∫–∏–π —à—Ç—Ä–∞—Ñ –µ—Å–ª–∏ –í–°–ï —Å–ª–æ–≤–∞ –Ω–∞–π–¥–µ–Ω—ã
                    penalty += first_word_mismatch_penalty
                    logger.debug(f"‚ö†Ô∏è First word not in top-3, BUT full coverage (-0.25)")
                else:
                    first_word_mismatch_penalty = 0.45  # –ñ–µ—Å—Ç–∫–∏–π —à—Ç—Ä–∞—Ñ
                    penalty += first_word_mismatch_penalty
                    logger.debug(f"‚ùå CRITICAL: First word not in top-3 AND incomplete (-0.45)")
            else:
                # –í —Ç–æ–ø-3 –Ω–æ –Ω–µ –ø–µ—Ä–≤–æ–µ
                coverage_ratio = (exact_matches + fuzzy_matches) / total_search_words
                if coverage_ratio >= 0.9:
                    first_word_mismatch_penalty = 0.15
                    logger.debug(f"‚ö†Ô∏è First word at pos {top3_position+1} but high coverage (-0.15)")
                else:
                    first_word_mismatch_penalty = 0.25
                    logger.debug(f"‚ö†Ô∏è First word at pos {top3_position+1} with low coverage (-0.25)")
                penalty += first_word_mismatch_penalty
        else:
            # –•–æ—Ä–æ—à–µ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞
            if first_word_similarity >= 0.95:
                bonus += 0.2
                logger.debug(f"‚úÖ First word high similarity: +0.2")
            elif first_word_similarity >= 0.7:
                bonus += 0.1
                logger.debug(f"‚úÖ First word medium similarity: +0.1")
    
    # –ë–æ–Ω—É—Å—ã –¥–∞—é—Ç—Å—è –ø—Ä–∏ penalty < 0.5 (—Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–Ω—ã–π –ø–æ—Ä–æ–≥)
    if total_search_words <= 2 and has_full_coverage:
        if penalty < 0.5:
            full_coverage_bonus = 0.15
            bonus += full_coverage_bonus
            logger.debug(f"‚úÖ Full coverage bonus: +{full_coverage_bonus:.2f}")
    
    exact_ratio = exact_matches / total_search_words
    if exact_ratio >= 0.5:
        if penalty < 0.5:
            exact_match_bonus = exact_ratio * 0.1
            bonus += exact_match_bonus
            logger.debug(f"‚úÖ Exact ratio bonus: +{exact_match_bonus:.2f}")
    
    # –®–¢–†–ê–§ –ó–ê –ù–ï–ó–ê–ü–†–û–®–ï–ù–ù–£–Æ –û–ë–†–ê–ë–û–¢–ö–£ –ü–†–û–î–£–ö–¢–ê (v5.3)
    search_modifiers = detect_processing_modifiers(normalized_search_query)
    found_modifiers = detect_processing_modifiers(normalized_found_name)
    
    # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ –Ω–∞–π–¥–µ–Ω–Ω–æ–º, –Ω–æ –ù–ï–¢ –≤ –∑–∞–ø—Ä–æ—Å–µ
    unrequested_modifiers = found_modifiers - search_modifiers
    
    if unrequested_modifiers:
        # –ï—Å—Ç—å –Ω–µ–∑–∞–ø—Ä–æ—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
        processing_penalty = 0.40  # –°–∏–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ
        penalty += processing_penalty
        logger.debug(f"‚ùå Unrequested processing: {unrequested_modifiers} (-{processing_penalty:.2f})")
    
    # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –ø—Ä–∏ penalty < 0.3
    if has_full_coverage and penalty < 0.3:
        min_score_for_full_coverage = 0.7
        if (base_score + bonus - penalty) < min_score_for_full_coverage:
            coverage_adjustment = min_score_for_full_coverage - (base_score + bonus - penalty)
            bonus += coverage_adjustment
            logger.debug(f"‚úÖ Coverage floor: +{coverage_adjustment:.2f}")
    
    final_score = base_score + bonus - penalty
    final_score = max(0.0, min(1.0, final_score))
    final_score = round(final_score, 3)
    
    is_exact = (exact_matches >= total_search_words or 
               (final_score >= 0.95 and exact_matches + fuzzy_matches >= total_search_words))
    
    logger.debug(f"Score breakdown v5.3: base={base_score:.3f}, bonus={bonus:.3f}, penalty={penalty:.3f}, final={final_score:.3f}")
    
    return final_score, is_exact

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è lsd_config_id –ø–æ –∏–º–µ–Ω–∏ –∏–∑ –ë–î
async def get_lsd_id_by_name(lsd_name: str) -> Optional[int]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ ID –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î –ø–æ –∏–º–µ–Ω–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(LSDConfig.id).where(LSDConfig.name == lsd_name)
            )
            lsd_id = result.scalar_one_or_none()
            
            if lsd_id:
                logger.debug(f"üì¶ LSD mapping: '{lsd_name}' -> ID {lsd_id}")
            else:
                logger.warning(f"‚ö†Ô∏è LSD '{lsd_name}' not found in database")
            
            return lsd_id
            
    except Exception as e:
        logger.error(f"‚ùå Error getting LSD ID for '{lsd_name}': {e}")
        return None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan event handler"""
    global background_task
    
    # Startup
    # –û–¢–ö–õ–Æ–ß–ï–ù–û: –§–æ–Ω–æ–≤—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–∫–∞–∑–æ–≤ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ Order-service
    # Order-service —É–ø—Ä–∞–≤–ª—è–µ—Ç –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –∑–∞–∫–∞–∑–∞ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç RPA-service —á–µ—Ä–µ–∑ API
    # logger.info("üöÄ Starting background order monitoring...")

    logger.info("üöÄ RPA Service started (background monitoring disabled)")
    
    yield
    
    # Shutdown
    logger.info("üõë Shutting down RPA service...")
    if background_task:
        background_task.cancel()
        try:
            await background_task
        except asyncio.CancelledError:
            pass

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è SMS –∫–æ–¥–æ–≤ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ë–î

app = FastAPI(
    title="Korzinka RPA Service", 
    description="RPA —Å–µ—Ä–≤–∏—Å —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Selenium",
    version="3.0.0",
    lifespan=lifespan
)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã - –ò–°–ü–û–õ–¨–ó–£–ï–ú –ì–õ–û–ë–ê–õ–¨–ù–£–Æ –ù–ê–°–¢–†–û–ô–ö–£ HEADLESS
active_sessions: Dict[str, Any] = {}
telegram_callbacks: Dict[str, Dict[str, Any]] = {}
success_notifications_sent: Dict[int, Dict[str, Any]] = {}
selenium_manager = UndetectedBrowserManager(headless=settings.rpa_headless, debug=settings.rpa_debug)

# API –º–æ–¥–µ–ª–∏
class BrowseRequest(BaseModel):
    telegram_id: int
    lsd_name: str
    auto_close_timeout: int = 300
    use_selenium: bool = True

class AuthRequest(BaseModel):
    telegram_id: int
    lsd_name: str

class SMSCodeRequest(BaseModel):
    session_id: str
    sms_code: str

class ProductSearchRequest(BaseModel):
    telegram_id: int
    lsd_name: str
    products: List[Dict[str, Any]]

class ProductSearchResponse(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    message: Optional[str] = None

@app.get("/health")
async def health():
    return {
        "status": "healthy", 
        "service": "rpa-service-selenium",
        "active_sessions": len(active_sessions),
        "browser_profile": profile_manager.default_profile,
        "version": "3.0.0 - Full Selenium Integration"
    }

@app.post("/search/products")
async def search_products(request: ProductSearchRequest):
    """–ü–æ–∏—Å–∫ —Ç–æ–≤–∞—Ä–æ–≤ –≤ –õ–°–î —á–µ—Ä–µ–∑ Selenium RPA"""
    logger.info(f"üîç Starting Selenium product search for {request.lsd_name} (user: {request.telegram_id})")
    logger.info(f"üì¶ Products to search: {len(request.products)}")
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—É–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –õ–°–î
        cookies_data = await get_user_cookies(request.telegram_id, request.lsd_name)
        if not cookies_data:
            raise HTTPException(
                status_code=400,
                detail=f"–ö—É–∫–∏ –¥–ª—è {request.lsd_name} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é."
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –õ–°–î
        lsd_config = await get_lsd_config(request.lsd_name)
        if not lsd_config:
            raise HTTPException(
                status_code=404,
                detail=f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è {request.lsd_name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ–∏—Å–∫–∞ –¥–ª—è –õ–°–î
        search_config = lsd_config.search_config_rpa
        if not search_config:
            raise HTTPException(
                status_code=400,
                detail=f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–ª—è {request.lsd_name}"
            )
        
        logger.info(f"üìã Using enhanced search config for {lsd_config.display_name}")
        
        # –í–´–ü–û–õ–ù–Ø–ï–ú SELENIUM –ü–û–ò–°–ö –° CDP –ü–†–ï–î–ó–ê–ì–†–£–ó–ö–û–ô –ö–£–ö
        search_results = await perform_product_search_with_cdp_cookies(
            lsd_config=lsd_config,
            search_config=search_config,
            cookies=cookies_data['cookies'],
            products=request.products,
            telegram_id=request.telegram_id
        )
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        product_search_results = []
        for result in search_results:
            if result.found_items:
                for item in result.found_items:
                    # –°–æ–∑–¥–∞–µ–º ProductSearchResult –∏–∑ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                    psr = ProductSearchResult(
                        order_item_id=result.order_item_id,
                        product_name=result.product_name,
                        found_name=item.get('name', result.product_name),
                        price=item.get('price', 0.0),
                        unit=item.get('unit', '—à—Ç'),
                        quantity=item.get('quantity', 1.0),  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                        available_stock=1 if item.get('available', True) else 0,
                        product_url=item.get('url'),
                        lsd_name=request.lsd_name,
                        search_position=len(product_search_results) + 1,
                        min_order_amount=item.get('min_order_amount', 0.0),
                        delivery_cost=item.get('delivery_cost', 0.0),
                        delivery_cost_model=item.get('delivery_cost_model')  # –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å
                    )
                    product_search_results.append(psr)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ lsd_stocks
        saved_count = await save_search_results_to_db(
            search_results=product_search_results,
            lsd_config_id=lsd_config.id,
            telegram_id=request.telegram_id
        )
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º failed_products (—Ç–æ–≤–∞—Ä—ã –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤)
        searched_item_ids = {product['order_item_id'] for product in request.products}
        found_item_ids = {result.order_item_id for result in product_search_results}
        failed_products = list(searched_item_ids - found_item_ids)
        
        logger.info(f"‚úÖ Selenium product search completed: {len(product_search_results)} results, {saved_count} saved to DB")
        if failed_products:
            logger.warning(f"‚ö†Ô∏è {len(failed_products)} products not found: {failed_products}")
        
        return {
            "success": True,
            "data": {
                "method": "selenium",
                "lsd_name": request.lsd_name,
                "display_name": lsd_config.display_name,
                "products_searched": len(request.products),
                "results_found": len(product_search_results),
                "results_saved": saved_count,
                "failed_products": failed_products,  # NEW: —Å–ø–∏—Å–æ–∫ order_item_id –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                "results": [
                    {
                        "order_item_id": result.order_item_id,
                        "product_name": result.product_name,
                        "found_name": result.found_name,
                        "price": result.price,
                        "unit": result.unit,
                        "product_url": result.product_url,
                        "search_position": result.search_position
                    }
                    for result in product_search_results[:20]  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 20
                ]
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Error in Selenium product search: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

async def perform_product_search_with_cdp_cookies(
    lsd_config,
    search_config: dict,
    cookies: list,
    products: List[Dict[str, Any]],
    telegram_id: int
) -> List[ProductSearchResult]:
    """
    –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ —Å –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–æ–π –∫—É–∫ —á–µ—Ä–µ–∑ CDP
    """
    
    logger.info(f"üîç Starting product search with CDP cookie preloading for {len(products)} products on {lsd_config.display_name}")
    
    results = []
    cdp_manager = None
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ CDP –∏–ª–∏ SimpleUndetectedBrowser
        cdp_enabled = True
        if hasattr(lsd_config, 'rpa_config') and lsd_config.rpa_config:
            cdp_enabled = lsd_config.rpa_config.get('cdp_enabled', True)
        
        if cdp_enabled:
            # –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê: CDP –±—Ä–∞—É–∑–µ—Ä
            logger.info(f"üîß Using CDP browser for search (cdp_enabled=true)")
            
            # –°–æ–∑–¥–∞–µ–º CDP –º–µ–Ω–µ–¥–∂–µ—Ä
            logger.info(f"üîß Initializing CDP cookie manager...")
            cdp_manager = CDPCookieManager()
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä —Å CDP (–∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É)
            driver = cdp_manager.setup_browser_with_cdp()  # headless –±—É–¥–µ—Ç –≤–∑—è—Ç –∏–∑ settings.rpa_headless
            
            logger.info(f"‚úÖ CDP browser created successfully")
        else:
            # –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: SimpleUndetectedBrowser –±–µ–∑ CDP (–∫–∞–∫ –≤ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏)
            logger.info(f"üöó Using SIMPLE browser WITHOUT CDP for search (cdp_enabled=false)")
            logger.info(f"üéØ Strategy: Maximum simplicity for bypassing strict antibot protection")
            
            from simple_browser_manager import SimpleUndetectedBrowser
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –º–æ–±–∏–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
            mobile_mode = lsd_config.rpa_config.get('mobile_mode', False) if lsd_config.rpa_config else False
            logger.info(f"üì± Mobile mode: {'ENABLED' if mobile_mode else 'DISABLED'}")
            driver = SimpleUndetectedBrowser.create_simple_browser(
                headless=settings.rpa_headless,
                mobile_mode=mobile_mode
            )
            cdp_manager = None  # –ù–µ—Ç CDP –º–µ–Ω–µ–¥–∂–µ—Ä–∞
            logger.info(f"‚úÖ SIMPLE browser created for search (NO CDP = NO detection)")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª–µ–≤–æ–π –¥–æ–º–µ–Ω –∏–∑ URL
        base_url = lsd_config.base_url
        target_domain = base_url.split('//')[1].split('/')[0] if '//' in base_url else base_url
        
        logger.info(f"üéØ Target domain: {target_domain}")
        
        # –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –î–õ–Ø QRATOR: —Å–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –ë–ï–ó –∫—É–∫, –ø–æ—Ç–æ–º –∏–Ω—ä–µ–∫—Ç–∏—Ä—É–µ–º
        qrator_init = search_config.get('qrator_init', False)
        if qrator_init:
            url_base = search_config.get('url_base', base_url)
            
            # –®–ê–ì 1: –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –ë–ï–ó –∫—É–∫ (–∫–∞–∫ –≤ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏)
            logger.info(f"üîê qrator_init=true: Opening {url_base} WITHOUT cookies first (like in auth flow)")
            driver.get(url_base)
            await asyncio.sleep(2)  # –î–∞—ë–º —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è
            
            # –®–ê–ì 2: –ü—Ä–∏–º–µ–Ω—è–µ–º antibot —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞ —á–∏—Å—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
            logger.info(f"üõ°Ô∏è Applying antibot strategies on clean page...")
            try:
                from selenium_antibot_strategies import apply_antibot_for_lsd
                antibot_success = apply_antibot_for_lsd(driver, lsd_config.name)
                if antibot_success:
                    logger.info(f"‚úÖ Antibot strategies applied successfully")
                else:
                    logger.warning(f"‚ö†Ô∏è Antibot strategies partially failed, but continuing...")
            except Exception as antibot_error:
                logger.warning(f"‚ö†Ô∏è Failed to apply antibot strategies: {antibot_error}, but continuing...")
            
            # –®–ê–ì 3: –¢–µ–ø–µ—Ä—å –∏–Ω—ä–µ–∫—Ç–∏—Ä—É–µ–º –∫—É–∫–∏ –≤ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã–π –±—Ä–∞—É–∑–µ—Ä
            logger.info(f"üç™ Now injecting {len(cookies)} cookies into already-open browser...")
            injected_count = 0
            for cookie in cookies:
                try:
                    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫—É–∫—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ Selenium API
                    selenium_cookie = {
                        'name': cookie.get('name'),
                        'value': cookie.get('value', ''),
                        'domain': cookie.get('domain', target_domain),
                        'path': cookie.get('path', '/')
                    }
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                    if 'secure' in cookie:
                        selenium_cookie['secure'] = bool(cookie['secure'])
                    if 'httpOnly' in cookie:
                        selenium_cookie['httpOnly'] = bool(cookie['httpOnly'])
                    if 'expirationDate' in cookie:
                        selenium_cookie['expiry'] = int(cookie['expirationDate'])
                    elif 'expiry' in cookie:
                        selenium_cookie['expiry'] = int(cookie['expiry'])
                    if 'sameSite' in cookie and cookie['sameSite'] in ['Strict', 'Lax', 'None']:
                        selenium_cookie['sameSite'] = cookie['sameSite']
                    
                    driver.add_cookie(selenium_cookie)
                    injected_count += 1
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Failed to inject cookie {cookie.get('name')}: {e}")
                    continue
            
            logger.info(f"‚úÖ Injected {injected_count}/{len(cookies)} cookies via Selenium API")
            
            # –®–ê–ì 4: –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —á—Ç–æ–±—ã –∫—É–∫–∏ –ø—Ä–∏–º–µ–Ω–∏–ª–∏—Å—å
            logger.info(f"üîÑ Refreshing page to apply cookies...")
            driver.refresh()
            await asyncio.sleep(3)  # –î–∞—ë–º —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è —Å –∫—É–∫–∞–º–∏
            
            # DEBUG: –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            current_url = driver.current_url
            logger.info(f"üìç Current URL after qrator_init + cookies: {current_url}")
            
            from datetime import datetime
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            html_log_path = f"/Users/ss/GenAI/korzinka/logs/qrator_init_page_{lsd_config.name}_{timestamp}.html"
            try:
                with open(html_log_path, 'w', encoding='utf-8') as f:
                    f.write(f"<!-- URL: {current_url} -->\n")
                    f.write(f"<!-- TIMESTAMP: {timestamp} -->\n")
                    f.write(f"<!-- Cookies injected: {injected_count}/{len(cookies)} -->\n")
                    f.write(f"<!-- Browser type: {'CDP' if cdp_manager else 'SIMPLE'} -->\n\n")
                    f.write(driver.page_source)
                logger.info(f"üìù qrator_init page HTML saved to {html_log_path}")
            except Exception as log_error:
                logger.error(f"‚ùå Failed to save HTML: {log_error}")
            
            logger.info(f"‚úÖ qrator_init complete: page opened clean, cookies injected, page refreshed")
        elif cdp_manager:
            # –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê: –∏–Ω—ä–µ–∫—Ü–∏—è —á–µ—Ä–µ–∑ CDP –¥–ª—è –õ–°–î –±–µ–∑ qrator_init
            logger.info(f"üîç qrator_init=false: Using CDP cookie injection (direct mode)")
            
            # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—ä–µ–∫—Ü–∏—è –∫—É–∫ —á–µ—Ä–µ–∑ CDP
            injected_count = cdp_manager.inject_cookies_before_navigation(
                cookies=cookies,
                target_domain=target_domain
            )
            
            if injected_count == 0:
                logger.error(f"‚ùå Failed to inject any cookies via CDP")
                raise Exception("CDP cookie injection failed")
            
            logger.info(f"‚úÖ Successfully injected {injected_count}/{len(cookies)} cookies via CDP")
        
        logger.info(f"üîç CDP cookie injection complete - ready for search navigation")
        
        # === –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –£–°–õ–û–í–ò–ô –î–û–°–¢–ê–í–ö–ò (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –∫–æ–Ω—Ñ–∏–≥–µ) ===
        delivery_info = None
        if 'delivery_ranges' in search_config:
            logger.info(f"üì¶ Found delivery_ranges config, extracting delivery conditions...")
            try:
                # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ base_url –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —É—Å–ª–æ–≤–∏–π –¥–æ—Å—Ç–∞–≤–∫–∏
                logger.info(f"üåê Navigating to {base_url} to extract delivery info")
                driver.get(base_url)
                
                # –£–º–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —á–µ—Ä–µ–∑ –ø–µ—Ä–≤—ã–π trigger selector
                from selenium.webdriver.support.ui import WebDriverWait
                from selenium.webdriver.support import expected_conditions as EC
                from selenium.webdriver.common.by import By
                
                trigger_config = search_config['delivery_ranges'].get('trigger', {})
                trigger_selectors = trigger_config.get('selectors', [])
                
                if trigger_selectors:
                    # –ñ–¥–µ–º –ø–æ—è–≤–ª–µ–Ω–∏—è —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ–≥–æ trigger —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ (–∑–Ω–∞—á–∏—Ç —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –≥–æ—Ç–æ–≤–∞)
                    page_ready = False
                    wait = WebDriverWait(driver, 10)
                    for trigger_sel in trigger_selectors:
                        try:
                            if trigger_sel.startswith('//'):
                                wait.until(EC.presence_of_element_located((By.XPATH, trigger_sel)))
                            else:
                                wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, trigger_sel)))
                            page_ready = True
                            logger.info(f"‚úÖ Page ready - trigger element found")
                            break
                        except Exception:
                            continue
                    
                    if not page_ready:
                        logger.warning(f"‚ö†Ô∏è No trigger elements found, but continuing...")
                        await asyncio.sleep(2)  # Fallback –∑–∞–¥–µ—Ä–∂–∫–∞
                else:
                    # –ù–µ—Ç trigger —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ—Ä–æ—Ç–∫—É—é –∑–∞–¥–µ—Ä–∂–∫—É
                    await asyncio.sleep(2)
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –¥–æ—Å—Ç–∞–≤–∫–∏
                from selenium_product_search import extract_delivery_ranges, parse_delivery_ranges_to_model
                
                delivery_ranges = await extract_delivery_ranges(
                    driver=driver,
                    delivery_config=search_config['delivery_ranges'],
                    telegram_id=telegram_id  # –ü–µ—Ä–µ–¥–∞–µ–º –¥–ª—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤
                )
                
                if delivery_ranges:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–æ–¥–µ–ª—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
                    delivery_info = parse_delivery_ranges_to_model(delivery_ranges)
                    logger.info(f"‚úÖ Extracted delivery info: {len(delivery_ranges)} ranges")
                    logger.debug(f"üìä Delivery model: {delivery_info}")
                else:
                    logger.warning(f"‚ö†Ô∏è No delivery ranges extracted")
                    
            except Exception as e:
                logger.error(f"‚ùå Error extracting delivery info: {e}")
                import traceback
                logger.error(traceback.format_exc())
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ delivery_info
        else:
            logger.info(f"üì¶ No delivery_ranges in config, skipping delivery info extraction")
        
        # –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ –ü–û–ò–°–ö–ê –ü–û –ü–†–û–î–£–ö–¢–ê–ú
        for i, product in enumerate(products, 1):
            product_name = product['product_name']
            is_alternative_group = product.get('is_alternative_group', False)
            alternatives = product.get('alternatives', [])
            
            logger.info(f"\n{'='*60}")
            logger.info(f"üîé [{i}/{len(products)}] Processing product: {product_name}")
            
            if is_alternative_group and alternatives:
                logger.info(f"üîÑ This is an alternative group with {len(alternatives)} alternatives: {alternatives}")
                logger.info(f"üëâ Will search: '{product_name}' + {alternatives}")
            else:
                logger.info(f"üëâ Single product search (no alternatives)")
            
            # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞
            search_variants = [{
                'name': product_name,
                'is_alternative': False,
                'alternative_for': None
            }]
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã
            if is_alternative_group and alternatives:
                for alt_name in alternatives:
                    search_variants.append({
                        'name': alt_name,
                        'is_alternative': True,
                        'alternative_for': product_name
                    })
            
            logger.info(f"üìã Total search variants: {len(search_variants)}")
            
            # –ò—â–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            for variant_idx, variant in enumerate(search_variants, 1):
                variant_name = variant['name']
                is_alt = variant['is_alternative']
                alt_for = variant['alternative_for']
                
                alt_marker = "üîÑ" if is_alt else "üîé"
                logger.info(f"\n{alt_marker} [{i}.{variant_idx}] Searching: '{variant_name}'" + 
                          (f" (alternative for '{alt_for}')" if is_alt else ""))
                
                try:
                    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                    result = ProductSearchResult(
                        order_item_id=product['order_item_id'],
                        product_name=variant_name,
                        search_query=variant_name,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º product_name –¥–ª—è –ø–æ–∏—Å–∫–∞
                        is_alternative=is_alt,
                        alternative_for=alt_for
                    )
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ –¥–ª—è —ç—Ç–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ —á–µ—Ä–µ–∑ CDP –¥—Ä–∞–π–≤–µ—Ä
                    search_success = await search_single_product_cdp(
                        driver=driver,
                        lsd_config=lsd_config,
                        search_config=search_config,
                        product={
                            **product,  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                            'product_name': variant_name  # –ü–æ–¥–º–µ–Ω—è–µ–º –∏–º—è –¥–ª—è –ø–æ–∏—Å–∫–∞
                        },
                        result=result,
                        delivery_info=delivery_info
                    )
                    
                    if search_success:
                        found_count = len(result.found_items)
                        logger.info(f"‚úÖ [{i}.{variant_idx}] Found {found_count} items for '{variant_name}'")
                    else:
                        logger.warning(f"‚ö†Ô∏è [{i}.{variant_idx}] No items found for '{variant_name}'")
                    
                    results.append(result)
                    
                except Exception as variant_error:
                    logger.error(f"‚ùå [{i}.{variant_idx}] Error searching '{variant_name}': {variant_error}")
                    
                    # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å –æ—à–∏–±–∫–æ–π
                    error_result = ProductSearchResult(
                        order_item_id=product['order_item_id'],
                        product_name=variant_name,
                        search_query=product['original_text'],
                        is_alternative=is_alt,
                        alternative_for=alt_for
                    )
                    error_result.search_successful = False
                    error_result.error_message = str(variant_error)
                    results.append(error_result)
                
                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏
                if variant_idx < len(search_variants):
                    await asyncio.sleep(2)
            
            logger.info(f"{'='*60}\n")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ü–û–°–õ–ï –ø–µ—Ä–≤–æ–≥–æ –ø–æ–∏—Å–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è CDP)
            if i == 1 and cdp_manager:  # –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –ø–æ–∏—Å–∫–∞ –∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ CDP
                auth_status = cdp_manager.verify_authentication()
                if auth_status['is_authenticated']:
                    logger.info(f"‚úÖ User authenticated via CDP cookies after first search")
                else:
                    logger.warning(f"‚ö†Ô∏è Authentication unclear, but continuing search") 
            
            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –ø—Ä–æ–¥—É–∫—Ç–∞–º–∏ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π)
            if i < len(products):
                pause_time = 3
                logger.info(f"‚è≥ Pausing {pause_time}s before next product...\n")
                await asyncio.sleep(pause_time)
        
        logger.info(f"üéâ CDP product search completed: {len(results)} products processed")
        
        # üíæ –°–û–•–†–ê–ù–Ø–ï–ú COOKIES –ü–ï–†–ï–î –í–û–ó–í–†–ê–¢–û–ú –†–ï–ó–£–õ–¨–¢–ê–¢–û–í
        logger.info(f"üíæ Extracting and saving updated cookies before returning results...")
        try:
            if cdp_manager:
                updated_cookies = cdp_manager.extract_cookies()
                if updated_cookies:
                    logger.info(f"üîÑ Saving {len(updated_cookies)} cookies to file...")
                    cookies_saved = await save_user_cookies(
                        telegram_id=telegram_id,
                        lsd_name=lsd_config.name,
                        lsd_config_id=lsd_config.id,
                        cookies=updated_cookies,
                        metadata={
                            'last_search_count': len(products),
                            'last_url': driver.current_url
                        }
                    )
                    if cookies_saved:
                        logger.info(f"‚úÖ Updated cookies saved to file and DB updated")
                    else:
                        logger.warning(f"‚ö†Ô∏è Failed to save updated cookies")
                else:
                    logger.warning(f"‚ö†Ô∏è No cookies extracted from CDP")
            else:
                # SimpleUndetectedBrowser
                from simple_browser_manager import SimpleUndetectedBrowser
                updated_cookies = SimpleUndetectedBrowser.extract_cookies(driver)
                if updated_cookies:
                    logger.info(f"üîÑ Saving {len(updated_cookies)} cookies to file...")
                    cookies_saved = await save_user_cookies(
                        telegram_id=telegram_id,
                        lsd_name=lsd_config.name,
                        lsd_config_id=lsd_config.id,
                        cookies=updated_cookies,
                        metadata={
                            'last_search_count': len(products),
                            'last_url': driver.current_url
                        }
                    )
                    if cookies_saved:
                        logger.info(f"‚úÖ Updated cookies saved to file and DB updated")
                    else:
                        logger.warning(f"‚ö†Ô∏è Failed to save updated cookies")
                else:
                    logger.warning(f"‚ö†Ô∏è No cookies extracted from SIMPLE browser")
        except Exception as cookie_save_error:
            logger.error(f"‚ùå Error saving cookies: {cookie_save_error}")
        
        return results
        
    except Exception as e:
        logger.error(f"‚ùå Critical error in CDP product search: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise
        
    finally:
        # –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ (—Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç–∏–µ –±—Ä–∞—É–∑–µ—Ä–∞)
        logger.info(f"üßπ Cleaning up browser resources...")
        if cdp_manager:
            try:
                logger.info(f"üßπ Closing CDP browser...")
                cdp_manager.cleanup()
                logger.info(f"‚úÖ CDP browser closed successfully")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error closing CDP browser: {cleanup_error}")
        else:
            try:
                logger.info(f"üßπ Closing SIMPLE browser...")
                driver.quit()
                logger.info(f"‚úÖ SIMPLE browser closed successfully")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error closing SIMPLE browser: {cleanup_error}")

async def handle_search_results_with_modals(driver, search_config: dict, lsd_config):
    """
    –£–º–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∂–¥—ë–º –ª–∏–±–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏,
    –ª–∏–±–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω. –ß—Ç–æ –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞–Ω—å—à–µ - —Ç–æ –∏ –æ–±—Ä–∞–±–æ—Ç–∞–µ–º.
    –ù–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–µ—Ä–∂–µ–∫ - —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.
    """
    from selenium.webdriver.common.by import By
    import time
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞
    container_selector = search_config.get('result_container_selector')
    post_search_modals = search_config.get('post_search_modals', [])
    
    if not container_selector:
        logger.warning("‚ö†Ô∏è No container selector configured")
        return
    
    max_wait_time = 10  # –ú–∞–∫—Å–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥
    check_interval = 0.2  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 200–º—Å
    start_time = time.time()
    
    container_found = False
    modal_handled = False
    
    logger.debug(f"üîç Starting smart wait: container='{container_selector}', modals={len(post_search_modals)}")
    
    while (time.time() - start_time) < max_wait_time:
        elapsed = time.time() - start_time
        
        try:
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ (–æ–Ω–∏ –º–æ–≥—É—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç)
            if not modal_handled and post_search_modals:
                for modal in post_search_modals:
                    modal_id = modal.get('id', 'unknown')
                    trigger_selector = modal.get('trigger_selector')
                    action_selector = modal.get('action_selector')
                    
                    if not trigger_selector or not action_selector:
                        continue
                    
                    try:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–æ–¥–∞–ª–∫–∏
                        if trigger_selector.startswith('//'):
                            modal_element = driver.find_element(By.XPATH, trigger_selector)
                        else:
                            modal_element = driver.find_element(By.CSS_SELECTOR, trigger_selector)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –≤–∏–¥–∏–º—ã–π
                        if modal_element.is_displayed():
                            logger.info(f"‚úÖ Modal '{modal_id}' detected after {elapsed:.1f}s, handling...")
                            
                            # –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ
                            if action_selector.startswith('//'):
                                action_element = driver.find_element(By.XPATH, action_selector)
                            else:
                                action_element = driver.find_element(By.CSS_SELECTOR, action_selector)
                            
                            action_element.click()
                            logger.info(f"‚úÖ Modal '{modal_id}' handled successfully")
                            modal_handled = True
                            
                            # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª–∫–∏
                            await asyncio.sleep(0.3)
                            break
                    except Exception:
                        # –ú–æ–¥–∞–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                        continue
            
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
            if not container_found:
                try:
                    if container_selector.startswith('//'):
                        container_element = driver.find_element(By.XPATH, container_selector)
                    else:
                        container_element = driver.find_element(By.CSS_SELECTOR, container_selector)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤–∏–¥–∏–º—ã–π
                    if container_element.is_displayed():
                        logger.info(f"‚úÖ Container found after {elapsed:.1f}s")
                        container_found = True
                        # –ù–∞—à–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä - –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞
                        return
                except Exception:
                    # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –µ—â—ë –Ω–µ –ø–æ—è–≤–∏–ª—Å—è
                    pass
            
            # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Check error: {e}")
            await asyncio.sleep(check_interval)
            continue
    
    # –¢–∞–π–º–∞—É—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç
    if not container_found and not modal_handled:
        logger.warning(f"‚ö†Ô∏è Timeout after {max_wait_time}s: no container or modals found")
    elif not container_found:
        logger.warning(f"‚ö†Ô∏è Timeout after {max_wait_time}s: modal handled but container not found")

async def handle_post_search_modals(driver, search_config: dict):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –ø–æ—Å–ª–µ –ø–æ–∏—Å–∫–∞
    (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤–æ–∑—Ä–∞—Å—Ç–∞ –≤ –ê—à–∞–Ω–µ)
    """
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
    
    post_search_modals = search_config.get('post_search_modals', [])
    if not post_search_modals:
        return
    
    logger.info(f"üîç Checking for post-search modals ({len(post_search_modals)} configured)...")
    
    for modal in post_search_modals:
        modal_id = modal.get('id', 'unknown')
        trigger_selector = modal.get('trigger_selector')
        action_selector = modal.get('action_selector')
        timeout_ms = modal.get('timeout', 3000)
        is_optional = modal.get('optional', True)
        
        if not trigger_selector or not action_selector:
            logger.warning(f"‚ö†Ô∏è Modal {modal_id}: missing selectors")
            continue
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—è–≤–ª–µ–Ω–∏–µ –º–æ–¥–∞–ª–∫–∏
            wait = WebDriverWait(driver, timeout_ms / 1000)
            
            if trigger_selector.startswith('//'):
                modal_element = wait.until(
                    EC.presence_of_element_located((By.XPATH, trigger_selector))
                )
            else:
                modal_element = wait.until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, trigger_selector))
                )
            
            logger.info(f"‚úÖ Modal '{modal_id}' detected, handling...")
            
            # –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ
            if action_selector.startswith('//'):
                action_element = driver.find_element(By.XPATH, action_selector)
            else:
                action_element = driver.find_element(By.CSS_SELECTOR, action_selector)
            
            action_element.click()
            logger.info(f"‚úÖ Modal '{modal_id}' handled successfully")
            
            # –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –º–æ–¥–∞–ª–∫–∏
            await asyncio.sleep(0.5)
            
        except TimeoutException:
            if is_optional:
                logger.debug(f"‚ÑπÔ∏è Modal '{modal_id}' not found (optional, continuing)")
            else:
                logger.warning(f"‚ö†Ô∏è Required modal '{modal_id}' not found")
        except Exception as e:
            logger.error(f"‚ùå Error handling modal '{modal_id}': {e}")
            if not is_optional:
                raise

async def search_single_product_cdp(
    driver,
    lsd_config,
    search_config: dict,
    product: Dict[str, Any],
    result: ProductSearchResult,
    delivery_info: dict = None
) -> bool:
    """
    –ü–æ–∏—Å–∫ –æ–¥–Ω–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ —á–µ—Ä–µ–∑ CDP –¥—Ä–∞–π–≤–µ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–≤—É—Ö –º–µ—Ç–æ–¥–æ–≤:
    - search_method: "url" - –ø—Ä—è–º–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ URL (–õ–µ–Ω—Ç–∞, Ozon)
    - search_method: "selector" - –≤–≤–æ–¥ –≤ –ø–æ–ª–µ –ø–æ–∏—Å–∫–∞ (–ê—à–∞–Ω, –ú–∞–≥–Ω–∏—Ç)
    
    Returns:
        True –µ—Å–ª–∏ –ø–æ–∏—Å–∫ —É—Å–ø–µ—à–µ–Ω
    """
    
    try:
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.common.by import By
        from selenium.common.exceptions import TimeoutException
        import time
        
        logger.info(f"üìù CDP search starting for product: {product.get('product_name', 'Unknown')}")
        
        # –ü–æ–ª—É—á–∞–µ–º base_url
        base_url = getattr(lsd_config, 'base_url', None) or lsd_config.get('base_url')
        if not base_url:
            raise Exception("base_url not found in lsd_config")
        
        logger.info(f"üìù Got base_url: {base_url}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞
        search_method = search_config.get('search_method', 'url')  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 'url'
        logger.info(f"üîç Search method: {search_method}")
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
        search_query = product['product_name']
        logger.info(f"üîé Search query: '{search_query}'")
        
        # ==================== –ú–ï–¢–û–î 1: –ü–û–ò–°–ö –ß–ï–†–ï–ó –°–ï–õ–ï–ö–¢–û–† ====================
        if search_method == "selector":
            logger.info(f"üéØ Using SELECTOR search method (input field)")
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä –ø–æ–ª—è –ø–æ–∏—Å–∫–∞
            search_selector = search_config.get('search_selector')
            if not search_selector:
                raise Exception("search_selector not found in config for selector search method")
            
            logger.info(f"üìç Search selector: {search_selector}")
            
            # –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ base_url –¥–ª—è –õ–°–î –±–µ–∑ qrator_init
            # (–¥–ª—è qrator_init –ø–µ—Ä–µ—Ö–æ–¥ —É–∂–µ —Å–¥–µ–ª–∞–Ω –≤ perform_product_search_with_cdp_cookies)
            qrator_init = search_config.get('qrator_init', False)
            if not qrator_init:
                logger.info(f"üåê Navigating to base_url: {base_url}")
                driver.get(base_url)
            else:
                logger.info(f"‚ÑπÔ∏è qrator_init=true: Skipping navigation (already done in cookie injection phase)")
                
            await asyncio.sleep(2)  # –î–∞–µ–º –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è
            
            # 2. –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª–µ –ø–æ–∏—Å–∫–∞
            wait = WebDriverWait(driver, 10)
            try:
                if search_selector.startswith('//'):
                    search_input = wait.until(
                        EC.presence_of_element_located((By.XPATH, search_selector))
                    )
                else:
                    search_input = wait.until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, search_selector))
                    )
                logger.info(f"‚úÖ Found search input field")
            except TimeoutException:
                logger.error(f"‚ùå Search input not found: {search_selector}")
                return False
            
            # 3. –û—á–∏—â–∞–µ–º –ø–æ–ª–µ –∏ –≤–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç
            search_input.clear()
            search_input.send_keys(search_query)
            logger.info(f"‚å®Ô∏è Typed query into search field")
            
            # 4. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É (Enter)
            from selenium.webdriver.common.keys import Keys
            search_input.send_keys(Keys.RETURN)
            logger.info(f"‚Üµ Submitted search")
            
            # 5. –£–ú–ù–û–ï –û–ñ–ò–î–ê–ù–ò–ï: –∏—â–µ–º –ª–∏–±–æ —Ç–æ–≤–∞—Ä—ã, –ª–∏–±–æ –º–æ–¥–∞–ª–∫–∏ - —á—Ç–æ –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞–Ω—å—à–µ
            # –ù–µ –¥–µ–ª–∞–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–µ—Ä–∂–µ–∫, –∂–¥—ë–º —Ä–µ–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            logger.info(f"‚è≥ Waiting for search results or modals...")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –º–æ–¥–∞–ª–∫–∏ –∏ —Ç–æ–≤–∞—Ä—ã –≤ –æ–¥–Ω–æ–º —Ü–∏–∫–ª–µ
            await handle_search_results_with_modals(driver, search_config, lsd_config)
            
        # ==================== –ú–ï–¢–û–î 2: –ü–û–ò–°–ö –ß–ï–†–ï–ó URL ====================
        else:  # search_method == "url"
            logger.info(f"üéØ Using URL search method (direct navigation)")
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º search_url_pattern
            search_url_pattern = search_config.get('search_url_pattern')
            
            if not search_url_pattern:
                logger.info(f"üìù search_url_pattern not found, creating from base_url")
                if 'ozon' in base_url.lower():
                    search_url_pattern = f"{base_url}/search/?text={{query}}"
                else:
                    search_url_pattern = f"{base_url}/search?q={{query}}"
                logger.info(f"üîß Created search_url_pattern: {search_url_pattern}")
            elif '{base_url}' in search_url_pattern:
                search_url_pattern = search_url_pattern.replace('{base_url}', base_url)
                logger.info(f"üîß Substituted base_url in pattern: {search_url_pattern}")
            
            # URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
            from urllib.parse import quote_plus
            encoded_query = quote_plus(search_query)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º search_url
            try:
                search_url = search_url_pattern.format(query=encoded_query)
                logger.info(f"üéØ Formatted search URL: {search_url}")
            except KeyError as e:
                logger.error(f"‚ùå KeyError formatting URL: {e}")
                search_url = search_url_pattern.format(base_url=base_url, query=encoded_query)
                logger.info(f"üîß Fixed with both params: {search_url}")
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–∏—Å–∫–∞
            logger.info(f"üåê Navigating to: {search_url}")
            driver.get(search_url)
            logger.info(f"‚úÖ Navigation complete: {driver.current_url}")
        
        # ==================== –û–ë–©–ê–Ø –ß–ê–°–¢–¨: –û–ë–†–ê–ë–û–¢–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ====================
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        container_selector = search_config.get('result_container_selector')
        item_selector = search_config.get('result_item_selector')
        
        if not container_selector or not item_selector:
            logger.warning(f"‚ö†Ô∏è Missing selectors, trying fallback...")
            result_selectors = search_config.get('result_selectors', {})
            container_selector = container_selector or result_selectors.get('container')
            item_selector = item_selector or result_selectors.get('item')
            
            if not container_selector or not item_selector:
                raise Exception("No valid result selectors found")
        
        logger.info(f"üîç Searching for products (optimized waiting)...")
        
        # –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –û–ñ–ò–î–ê–ù–ò–ï: –∏—â–µ–º —Ç–æ–≤–∞—Ä—ã, –∞ –Ω–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ—è–≤–ª—è–µ—Ç—Å—è –±—ã—Å—Ç—Ä–æ, –Ω–æ —Ç–æ–≤–∞—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
        try:
            max_wait_time = 10  # –ú–∞–∫—Å–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥ –¥–ª—è –ª—é–±–æ–≥–æ –õ–°–î
            start_time = time.time()
            container_element = None
            items_found = False
            
            # –ë—ã—Å—Ç—Ä—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –Ω–∞–π—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏ —Ç–æ–≤–∞—Ä—ã
            while (time.time() - start_time) < max_wait_time:
                try:
                    # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                    if not container_element:
                        if container_selector.startswith('//'):
                            container_element = driver.find_element(By.XPATH, container_selector)
                        else:
                            container_element = driver.find_element(By.CSS_SELECTOR, container_selector)
                        
                        elapsed = time.time() - start_time
                        logger.info(f"‚úÖ Container found after {elapsed:.1f}s: {container_selector}")
                    
                    # –®–∞–≥ 2: –ò—â–µ–º —Ç–æ–≤–∞—Ä—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                    if item_selector.startswith('//') or item_selector.startswith('.//'):
                        items = container_element.find_elements(By.XPATH, item_selector)
                    else:
                        items = container_element.find_elements(By.CSS_SELECTOR, item_selector)
                    
                    if items and len(items) > 0:
                        elapsed = time.time() - start_time
                        logger.info(f"‚úÖ Found {len(items)} items after {elapsed:.1f}s")
                        items_found = True
                        break
                    
                    # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                    await asyncio.sleep(0.3)
                    
                except Exception:
                    await asyncio.sleep(0.3)
                    continue
            
            if not items_found:
                raise TimeoutException(f"No items found after {max_wait_time}s")
        except Exception as e:
            logger.error(f"‚ùå Products not found: {e}")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            try:
                from datetime import datetime
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                html_log_path = f"/Users/ss/GenAI/korzinka/logs/page-dump-{lsd_config.name}-{timestamp}.html"
                
                with open(html_log_path, 'w', encoding='utf-8') as f:
                    f.write(f"<!-- SEARCH QUERY: {search_query} -->\n")
                    f.write(f"<!-- URL: {driver.current_url} -->\n")
                    f.write(f"<!-- SEARCH_METHOD: {search_method} -->\n")
                    f.write(f"<!-- CONTAINER_SELECTOR: {container_selector} -->\n")
                    f.write(f"<!-- ITEM_SELECTOR: {item_selector} -->\n")
                    f.write(f"<!-- TIMESTAMP: {timestamp} -->\n\n")
                    f.write(driver.page_source)
                
                logger.info(f"üìù Page HTML saved to {html_log_path}")
            except Exception as log_error:
                logger.error(f"‚ùå Failed to save HTML: {log_error}")
            
            return False
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤
        if item_selector.startswith('//') or item_selector.startswith('.//'):
            item_elements = container_element.find_elements(By.XPATH, item_selector)
        else:
            item_elements = container_element.find_elements(By.CSS_SELECTOR, item_selector)
        
        if not item_elements:
            logger.error(f"‚ùå No items found")
            return False
        
        logger.info(f"üì¶ Found {len(item_elements)} potential items")
        
        # –ì–æ—Ç–æ–≤–∏–º page_level_data –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
        if delivery_info:
            page_level_data = {
                'min_order_amount': 0.0,
                'delivery_cost': 0.0,
                'delivery_cost_model': delivery_info
            }
            logger.info(f"üìã Using pre-extracted delivery model")
        else:
            logger.info(f"üì¶ Using lsd_config fallback")
            config_delivery_model = getattr(lsd_config, 'delivery_cost_model', None)
            if config_delivery_model:
                page_level_data = {
                    'min_order_amount': getattr(lsd_config, 'min_order_amount', 0.0) or 0.0,
                    'delivery_cost': getattr(lsd_config, 'delivery_cost', 0.0) or 0.0,
                    'delivery_cost_model': config_delivery_model
                }
            else:
                from selenium_product_search import convert_legacy_to_model
                config_min_order = getattr(lsd_config, 'min_order_amount', 0.0) or 0.0
                config_delivery_cost = getattr(lsd_config, 'delivery_cost', 0.0) or 0.0
                page_level_data = {
                    'min_order_amount': float(config_min_order),
                    'delivery_cost': float(config_delivery_cost),
                    'delivery_cost_model': convert_legacy_to_model(config_min_order, config_delivery_cost)
                }
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä–æ–≤
        max_results = search_config.get('max_results_to_check', 20)
        logger.info(f"üìù Processing up to {max_results} items")
        
        from selenium_product_search import extract_item_data_selenium_enhanced
        
        for i, item_element in enumerate(item_elements[:max_results], 1):
            try:
                item_data = await extract_item_data_selenium_enhanced(
                    item_element=item_element,
                    search_config=search_config,
                    lsd_config=lsd_config,
                    page_level_data=page_level_data
                )
                
                if item_data:
                    result.found_items.append(item_data)
                    logger.info(f"‚úÖ [{i}] Extracted: {item_data.get('name')} - {item_data.get('price')}‚ÇΩ")
                else:
                    logger.warning(f"‚ö†Ô∏è [{i}] No data extracted")
                
            except Exception as extract_error:
                logger.warning(f"‚ö†Ô∏è [{i}] Error: {extract_error}")
                continue
        
        # –£—Å–ø–µ—Ö –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–æ–≤–∞—Ä
        if result.found_items:
            result.search_successful = True
            logger.info(f"‚úÖ Found {len(result.found_items)} items for '{search_query}'")
            return True
        else:
            logger.warning(f"‚ö†Ô∏è No valid items extracted for '{search_query}'")
            return False
            
    except Exception as e:
        error_msg = f"CDP search error: {e}"
        logger.error(f"‚ùå {error_msg}")
        result.error_message = error_msg
        return False



async def save_search_results_to_db(
    search_results: List[ProductSearchResult],
    lsd_config_id: int,
    telegram_id: int
) -> int:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—É lsd_stocks —Å –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–µ–π –µ–¥–∏–Ω–∏—Ü"""
    logger.info(f"üíæ Saving {len(search_results)} search results to lsd_stocks with unit normalization...")
    
    try:
        saved_count = 0
        
        async for db in get_async_session():
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —ç—Ç–∏—Ö order_item_id
            if search_results:
                order_item_ids = [result.order_item_id for result in search_results]
                await db.execute(
                    delete(LSDStock).where(
                        LSDStock.order_item_id.in_(order_item_ids),
                        LSDStock.lsd_config_id == lsd_config_id
                    )
                )
                logger.info(f"üßΩ Cleared old stocks for {len(order_item_ids)} items")
            
            # –ü–æ–ª—É—á–∞–µ–º order_id –∏ over_order_percent –∏–∑ –ø–µ—Ä–≤–æ–≥–æ order_item
            order_id = None
            over_order_percent = 50  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            
            if search_results:
                # –ü–æ–ª—É—á–∞–µ–º order_id –∏–∑ –ø–µ—Ä–≤–æ–≥–æ order_item
                first_item_result = await db.execute(
                    select(OrderItem.order_id).where(OrderItem.id == search_results[0].order_item_id)
                )
                order_id = first_item_result.scalar_one_or_none()
                
                if order_id:
                    logger.info(f"üéØ Got order_id={order_id} for this search batch")
                    
                    # –ü–æ–ª—É—á–∞–µ–º over_order_percent –∏–∑ –∑–∞–∫–∞–∑–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    order_result = await db.execute(
                        select(Order.over_order_percent, Order.user_id).where(Order.id == order_id)
                    )
                    order_data = order_result.one_or_none()
                    
                    if order_data and order_data[0] is not None:
                        over_order_percent = order_data[0]
                        logger.info(f"üìä Using over_order_percent={over_order_percent}% from order")
                    elif order_data and order_data[1]:
                        # –ï—Å–ª–∏ –≤ –∑–∞–∫–∞–∑–µ –Ω–µ—Ç, –±–µ—Ä–µ–º –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                        user_result = await db.execute(
                            select(User.over_order_percent).where(User.id == order_data[1])
                        )
                        user_percent = user_result.scalar_one_or_none()
                        if user_percent is not None:
                            over_order_percent = user_percent
                            logger.info(f"üìä Using over_order_percent={over_order_percent}% from user")
                    else:
                        logger.info(f"üìä Using default over_order_percent={over_order_percent}%")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            for result in search_results:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –º–æ–ª–æ—á–Ω—ã–º –ø—Ä–æ–¥—É–∫—Ç–æ–º
                    is_milk = is_milk_product(result.found_name)
                    
                    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è –¥–ª—è –º–æ–ª–æ–∫–∞
                    unit_for_processing = result.unit
                    if is_milk:
                        if result.unit == '–≥':
                            unit_for_processing = '–º–ª'
                            logger.info(f"ü•õ Milk product detected: converting '–≥' -> '–º–ª' for '{result.found_name}'")
                        elif result.unit == '–∫–≥':
                            unit_for_processing = '–ª'
                            logger.info(f"ü•õ Milk product detected: converting '–∫–≥' -> '–ª' for '{result.found_name}'")
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ quantity –∏ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π unit
                    base_unit = get_base_unit(unit_for_processing)
                    base_quantity = convert_to_base_unit(result.quantity, unit_for_processing, base_unit)
                    
                    # –ü–æ–ª—É—á–∞–µ–º requested_quantity –∏ requested_unit –∏–∑ order_items
                    item_result = await db.execute(
                        select(OrderItem.requested_quantity, OrderItem.requested_unit)
                        .where(OrderItem.id == result.order_item_id)
                    )
                    item_data = item_result.one_or_none()
                    requested_quantity = item_data[0] if item_data else None
                    requested_unit = item_data[1] if item_data else None
                    
                    # DEBUG: –ª–æ–≥–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    logger.info(f"üîç Unit conversion: result.unit='{result.unit}' -> base_unit='{base_unit}', result.quantity={result.quantity} -> base_quantity={base_quantity}")
                    logger.info(f"üîç Product: '{result.found_name}', price={result.price}")
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º fprice –∏ —Ñ–æ—Ä–º—É–ª—É –µ–≥–æ —Ä–∞—Å—á–µ—Ç–∞
                    fprice_calculation = None
                    
                    if base_quantity > 0:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–π—Ü–∞
                        egg_category = extract_egg_category(result.found_name)
                        
                        # DEBUG: –ª–æ–≥–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —è–∏—Ü
                        if egg_category:
                            logger.info(f"ü•ö Detected egg category: {egg_category} for '{result.found_name}', base_unit={base_unit}, base_quantity={base_quantity}")
                        else:
                            logger.info(f"üî¥ NOT an egg (no category detected): '{result.found_name}'")
                        
                        if egg_category and base_unit == '–∫–≥':  # –Ø–π—Ü–∞ –≤ –≥—Ä–∞–º–º–∞—Ö
                            # –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Ü–µ–Ω–µ –∑–∞ –∫–∏–ª–æ–≥—Ä–∞–º–º
                            from shared.utils.egg_categories import get_egg_weight_kg
                            
                            egg_weight_kg = get_egg_weight_kg(egg_category)
                            eggs_count = 10 if egg_category != '–ü–ï–†–ï–ü–ï–õ–ò–ù–û–ï' else 20
                            
                            # –û–±—â–∏–π –≤–µ—Å —É–ø–∞–∫–æ–≤–∫–∏ –≤ –∫–≥
                            total_weight_kg = eggs_count * egg_weight_kg
                            
                            # –¶–µ–Ω–∞ –∑–∞ –∫–∏–ª–æ–≥—Ä–∞–º–º
                            fprice = result.price / total_weight_kg
                            fprice = round(fprice, 2)
                            
                            fprice_calculation = f"fprice = price / total_weight_kg = {result.price} / ({eggs_count} * {egg_weight_kg}) = {fprice} ‚ÇΩ/–∫–≥ ({egg_category})"
                            
                            # –û—Å—Ç–∞–≤–ª—è–µ–º base_unit = '–∫–≥'
                            base_unit = '–∫–≥'
                            base_quantity = total_weight_kg
                            
                        elif egg_category and result.unit.lower() in ['—É–ø', '—É–ø–∞–∫', '—É–ø–∞–∫.', 'pack', '—É–ø–∞–∫–æ–≤–∫–∞']:  # –Ø–π—Ü–∞ –≤ —É–ø–∞–∫–æ–≤–∫–µ
                            from shared.utils.egg_categories import get_egg_weight_kg
                            
                            eggs_count = extract_egg_count_from_name(result.found_name)
                            egg_weight_kg = get_egg_weight_kg(egg_category)
                            total_weight_kg = eggs_count * egg_weight_kg
                            
                            fprice = result.price / total_weight_kg
                            fprice = round(fprice, 2)
                            
                            fprice_calculation = f"fprice = price / total_weight_kg = {result.price} / ({eggs_count} * {egg_weight_kg}) = {fprice} ‚ÇΩ/–∫–≥ ({egg_category})"
                            
                            base_unit = '–∫–≥'
                            base_quantity = total_weight_kg
                            
                        elif base_unit == '—à—Ç' and egg_category:  # –®—Ç—É—á–Ω—ã–µ —è–π—Ü–∞
                            logger.info(f"ü•ö MATCHED CONDITION: –®—Ç—É—á–Ω—ã–µ —è–π—Ü–∞ (base_unit={base_unit}, egg_category={egg_category})")
                            from shared.utils.egg_categories import get_egg_weight_kg
                            
                            egg_weight_kg = get_egg_weight_kg(egg_category)
                            total_weight_kg = base_quantity * egg_weight_kg
                            
                            fprice = result.price / total_weight_kg
                            fprice = round(fprice, 2)
                            
                            fprice_calculation = f"fprice = price / (pcs * egg_grade_weight) = {result.price} / ({base_quantity} * {egg_weight_kg}) = {fprice} ‚ÇΩ/–∫–≥ ({egg_category})"
                            
                            base_unit = '–∫–≥'
                            base_quantity = total_weight_kg
                            logger.info(f"‚úÖ Converted to kg: base_unit={base_unit}, base_quantity={base_quantity}, fprice={fprice}")
                            
                        elif base_unit == '—à—Ç':  # –®—Ç—É—á–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã (–Ω–µ —è–π—Ü–∞)
                            logger.info(f"üëî MATCHED CONDITION: –®—Ç—É—á–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã (–ù–ï —è–π—Ü–∞) (base_unit={base_unit}, egg_category={egg_category})")
                            fprice = result.price / base_quantity
                            fprice = round(fprice, 2)
                            fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice:.2f} ‚ÇΩ/—à—Ç"
                            
                        else:  # –í–µ—Å/–æ–±—ä–µ–º
                            fprice = result.price / base_quantity
                            fprice = round(fprice, 2)
                            fprice_calculation = f"fprice = price / base_quantity = {result.price} / {base_quantity} = {fprice} ‚ÇΩ/{base_unit}"
                    else:
                        fprice = result.price
                        base_quantity = 1.0
                        fprice_calculation = f"fprice = price = {fprice} ‚ÇΩ (base_quantity was 0)"
                    
                    normalized_data = {
                        'found_unit': unit_for_processing,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –µ–¥–∏–Ω–∏—Ü—É –¥–ª—è –º–æ–ª–æ–∫–∞
                        'found_quantity': result.quantity,
                        'base_unit': base_unit,
                        'base_quantity': base_quantity,
                        'fprice': fprice,
                        'fprice_calculation': fprice_calculation
                    }
                    
                    logger.info(f"üîß Normalized '{result.found_name}': {normalized_data['found_quantity']}{normalized_data['found_unit']} -> {normalized_data['fprice']}‚ÇΩ/{normalized_data['base_unit']}")
                    
                    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º found_name –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∏ —Ä–∞—Å—á–µ—Ç–æ–º match_score
                    normalized_found_name = normalize_product_name(result.found_name)
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é –µ—Å–ª–∏ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                    if result.found_name != normalized_found_name:
                        logger.info(f"üßπ Normalized found_name: '{result.found_name}' -> '{normalized_found_name}'")
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º match_score —Å —É–∂–µ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
                    match_score, is_exact_match = calculate_advanced_match_score(
                        search_query=result.product_name,
                        found_name=result.found_name  # –§—É–Ω–∫—Ü–∏—è —Å–∞–º–∞ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç
                    )
                    match_score = Decimal(str(match_score))
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º order_item_ids_quantity –∏ order_item_ids_cost
                    order_quantity = None
                    order_cost = None
                    
                    if requested_quantity is not None and requested_unit is not None:
                        order_quantity, order_cost = calculate_order_quantity(
                            requested_quantity=float(requested_quantity),
                            requested_unit=requested_unit,
                            base_quantity=float(normalized_data['base_quantity']),
                            base_unit=normalized_data['base_unit'],
                            price=float(result.price),
                            over_order_percent=over_order_percent
                        )
                        
                        if order_quantity is not None:
                            logger.info(f"üì¶ Calculated order quantity: {order_quantity} pcs, cost: {order_cost}‚ÇΩ for {requested_quantity}{requested_unit}")
                        else:
                            logger.warning(f"‚ö†Ô∏è Failed to calculate order quantity for {result.found_name}")
                    else:
                        logger.debug(f"üìù No requested_quantity/unit for {result.found_name}, skipping calculation")
                    
                    lsd_stock = LSDStock(
                        order_id=order_id,  # –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä—è–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –∑–∞–∫–∞–∑
                        order_item_id=result.order_item_id,
                        lsd_config_id=lsd_config_id,
                        found_name=normalized_found_name,  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
                        
                        # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                        found_unit=normalized_data['found_unit'],
                        found_quantity=normalized_data['found_quantity'],
                        base_unit=normalized_data['base_unit'],
                        base_quantity=normalized_data['base_quantity'],
                        
                        # –¶–µ–Ω—ã
                        price=result.price,
                        fprice=normalized_data['fprice'],
                        fprice_calculation=normalized_data['fprice_calculation'],
                        
                        # –£—Å–ª–æ–≤–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏ –∏ –∑–∞–∫–∞–∑–∞ (—Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
                        min_order_amount=result.min_order_amount,
                        delivery_cost=result.delivery_cost,
                        # –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏
                        delivery_cost_model=getattr(result, 'delivery_cost_model', None),
                        
                        # –ú–µ—Ç–∞-–¥–∞–Ω–Ω—ã–µ
                        available_stock=result.available_stock,
                        product_url=result.product_url,
                        search_query=result.search_query,
                        search_result_position=result.search_position,
                        
                        # –û—Ü–µ–Ω–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
                        match_score=match_score,
                        is_exact_match=is_exact_match,
                        
                        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
                        is_alternative=getattr(result, 'is_alternative', False),
                        alternative_for=getattr(result, 'alternative_for', None),
                        
                        # –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞—Å–ª–µ–¥—É–µ—Ç—Å—è –æ—Ç order_items)
                        requested_quantity=requested_quantity,
                        requested_unit=requested_unit,
                        
                        # –†–∞—Å—á–µ—Ç–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–∫–∞–∑–∞
                        order_item_ids_quantity=order_quantity,
                        order_item_ids_cost=order_cost
                    )
                    
                    db.add(lsd_stock)
                    saved_count += 1
                    
                    logger.info(f"  ‚úÖ Saved: {result.product_name} -> {normalized_found_name} ({normalized_data['fprice']}‚ÇΩ/{normalized_data['base_unit']})")
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–π match_score
                    logger.debug(f"    Match score: {match_score} (exact: {is_exact_match})")
                    
                except Exception as e:
                    logger.error(f"  ‚ùå Error saving result {result.product_name}: {e}")
            
            await db.commit()
            logger.info(f"üíæ Successfully saved {saved_count}/{len(search_results)} results to lsd_stocks")
            
            return saved_count
            
    except Exception as e:
        logger.error(f"‚ùå Database error saving search results: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return 0

async def get_user_cookies(telegram_id: int, lsd_name: str) -> Optional[dict]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã"""
    logger.info(f"üç™ Getting cookies for user {telegram_id}, lsd '{lsd_name}'")
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞
        data = await cookie_manager.load_cookies(telegram_id, lsd_name)
        
        if data and data.get('cookies'):
            cookies = data['cookies']
            logger.info(f"‚úÖ Found {len(cookies)} cookies for user {telegram_id} on {lsd_name}")
            
            return {
                'cookies': cookies,
                'lsd_config_id': data.get('lsd_config_id'),
                'created_at': data.get('created_at'),
                'metadata': data.get('session_metadata', {})
            }
        else:
            logger.warning(f"‚ö†Ô∏è No cookies found for user {telegram_id} on {lsd_name}")
            return None
            
    except Exception as e:
        logger.error(f"‚ùå Error getting user cookies: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None

async def update_user_session_cookie_reference(
    telegram_id: int,
    lsd_config_id: int,
    cookie_file_path: str,
    cookie_count: int
) -> bool:
    """
    –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ cookie —Ñ–∞–π–ª –≤ user_sessions
    
    Args:
        telegram_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        lsd_config_id: ID –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î
        cookie_file_path: –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
        cookie_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ cookies –≤ —Ñ–∞–π–ª–µ
    """
    try:
        async for db in get_async_session():
            # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é
            result = await db.execute(
                select(UserSession).where(
                    UserSession.telegram_id == telegram_id,
                    UserSession.lsd_config_id == lsd_config_id
                )
            )
            session = result.scalar_one_or_none()
            
            # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î
            session_data = {
                "cookie_file": cookie_file_path,
                "cookie_count": cookie_count,
                "last_updated": datetime.now().isoformat()
            }
            
            if session:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é
                session.data = session_data
                session.updated_at = datetime.now()
                logger.info(f"‚úÖ Updated user_session reference to {cookie_file_path}")
            else:
                # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ –±—ã–ª–æ)
                session = UserSession(
                    telegram_id=telegram_id,
                    lsd_config_id=lsd_config_id,
                    session_type='cookie_file',
                    data=session_data,
                    created_at=datetime.now(),
                    updated_at=datetime.now()
                )
                db.add(session)
                logger.info(f"‚úÖ Created new user_session reference to {cookie_file_path}")
            
            await db.commit()
            return True
            
    except Exception as e:
        logger.error(f"‚ùå Failed to update user_session reference: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def save_user_cookies(
    telegram_id: int,
    lsd_name: str,
    lsd_config_id: int,
    cookies: List[Dict[str, Any]],
    metadata: Optional[Dict[str, Any]] = None
) -> bool:
    """
    –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ cookies –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ë–î
    """
    try:
        # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª
        success, cookie_file_path = await cookie_manager.save_cookies(
            telegram_id=telegram_id,
            lsd_name=lsd_name,
            lsd_config_id=lsd_config_id,
            cookies=cookies,
            metadata=metadata
        )
        
        if not success:
            logger.error(f"‚ùå Failed to save cookies to file")
            return False
        
        # 2. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –≤ –ë–î
        db_updated = await update_user_session_cookie_reference(
            telegram_id=telegram_id,
            lsd_config_id=lsd_config_id,
            cookie_file_path=cookie_file_path,
            cookie_count=len(cookies)
        )
        
        if db_updated:
            logger.info(f"‚úÖ Saved {len(cookies)} cookies for user {telegram_id} @ {lsd_name}")
        else:
            logger.warning(f"‚ö†Ô∏è Cookies saved to file but DB reference not updated")
        
        return success
        
    except Exception as e:
        logger.error(f"‚ùå Error saving cookies: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def get_lsd_config(lsd_name: str) -> Optional[LSDConfig]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –õ–°–î –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    lsd_id = await get_lsd_id_by_name(lsd_name)
    if not lsd_id:
        logger.error(f"‚ùå Unknown LSD name: {lsd_name}")
        return None
    
    try:
        async for db in get_async_session():
            await db.commit()
            result = await db.execute(select(LSDConfig).where(LSDConfig.id == lsd_id))
            config = result.scalar_one_or_none()
            
            if config:
                logger.info(f"‚úÖ Found config for {config.display_name} (ID: {config.id})")
                
                if config.search_config_rpa:
                    search_pattern = config.search_config_rpa.get('search_url_pattern')
                    logger.info(f"üîç DEBUG: search_url_pattern = '{search_pattern}'")
                else:
                    logger.warning(f"‚ö†Ô∏è No search_config_rpa for {config.display_name}")
            else:
                logger.error(f"‚ùå No config found for LSD ID: {lsd_id}")
                
            return config
            
    except Exception as e:
        logger.error(f"‚ùå Database error: {e}")
        return None

# ============================================================================
# –§–û–ù–û–í–´–ô –ú–û–ù–ò–¢–û–†–ò–ù–ì –ó–ê–ö–ê–ó–û–í - –û–¢–ö–õ–Æ–ß–ï–ù–û
# ============================================================================
# –≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã, —Ç.–∫. –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–æ–º –∑–∞–∫–∞–∑–æ–≤
# –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ Order-service. RPA-service —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–∞–∫ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å
# –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ API endpoint /search/products
#
# –ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è: –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å–µ—Å—Å–∏–π –ë–î –º–µ–∂–¥—É Order-service –∏ RPA-service
# –ø—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç–µ —Å –æ–¥–Ω–∏–º –∑–∞–∫–∞–∑–æ–º
# ============================================================================

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤
async def send_telegram_message(chat_id: str, text: str, reply_to_message_id: int = None, parse_mode: str = None, disable_web_page_preview: bool = False):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram –≥—Ä—É–ø–ø—É"""
    try:
        import httpx
        from config.settings import settings
        
        url = f"https://api.telegram.org/bot{settings.telegram_bot_token}/sendMessage"
        
        payload = {
            "chat_id": chat_id,
            "text": text
        }
        
        if reply_to_message_id:
            payload["reply_to_message_id"] = reply_to_message_id
        
        if parse_mode:
            payload["parse_mode"] = parse_mode
        
        if disable_web_page_preview:
            payload["disable_web_page_preview"] = True
        
        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=payload, timeout=10.0)
            
        if response.status_code == 200:
            logger.info(f"‚úÖ Message sent successfully to chat {chat_id}")
            return True
        else:
            logger.error(f"‚ùå Failed to send message: {response.status_code} - {response.text}")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Error sending Telegram message: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

# –û—Å—Ç–∞–ª—å–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã (auth, browse –∏ —Ç.–¥.) –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
@app.post("/auth/start")
async def start_selenium_auth(request: AuthRequest, background_tasks: BackgroundTasks):
    """–ó–∞–ø—É—Å–∫ —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–π CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –õ–°–î"""
    logger.info(f"üöÄ Starting unified CDP auth for {request.lsd_name} (user: {request.telegram_id})")
    
    try:
        lsd_config = await get_lsd_config(request.lsd_name)
        if not lsd_config:
            raise HTTPException(
                status_code=404, 
                detail=f"LSD configuration not found for {request.lsd_name}"
            )
        
        logger.info(f"üìã Loaded config for {lsd_config.display_name}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—É—é CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ
        background_tasks.add_task(
            execute_selenium_auth_flow, 
            request.telegram_id,
            lsd_config,
            lsd_config.rpa_config or {}  # –ü–µ—Ä–µ–¥–∞–µ–º RPA –∫–æ–Ω—Ñ–∏–≥ –∫–∞–∫ auth_config
        )
        
        return {
            "success": True,
            "data": {
                "status": "started",
                "lsd_name": request.lsd_name,
                "display_name": lsd_config.display_name,
                "message": f"ü§ñ –ó–∞–ø—É—Å–∫–∞—é —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ {lsd_config.display_name}...",
                "method": "unified_cdp"
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error starting unified CDP auth: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/orders/process-now")
async def process_orders_now():
    """–†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–∫–∞–∑–æ–≤"""
    logger.info("üîÑ Manual order processing triggered")
    
    try:
        await process_analyzing_orders()
        return {
            "success": True,
            "message": "Order processing completed"
        }
    except Exception as e:
        logger.error(f"‚ùå Manual order processing failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/orders/monitor/status")
async def get_monitor_status():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–∫–∞–∑–æ–≤"""
    global background_task
    
    analyzing_orders = await get_analyzing_orders()
    mvp_lsds = await get_mvp_lsd_configs()
    
    return {
        "success": True,
        "data": {
            "monitor_active": background_task is not None and not background_task.done(),
            "orders_in_queue": len(analyzing_orders),
            "active_lsd_count": len(mvp_lsds),
            "active_lsds": [lsd.display_name for lsd in mvp_lsds],
            "orders_list": [
                {
                    "id": order.id,
                    "user_id": order.user_id,
                    "created_at": order.created_at.isoformat() if order.created_at else None,
                    "analysis_started_at": order.analysis_started_at.isoformat() if order.analysis_started_at else None
                }
                for order in analyzing_orders
            ],
            "version": "3.0.0 - Full Selenium Integration"
        }
    }



@app.post("/rpa/user-input-response")
async def receive_user_input(request: dict):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ SMS –∫–æ–¥–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ telegram-bot - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î"""
    try:
        telegram_id = request.get('telegram_id')
        sms_code = request.get('user_input')
        
        if not telegram_id or not sms_code:
            return {"status": "error", "message": "Missing telegram_id or user_input"}
        
        logger.info(f"üì± Received SMS code from user {telegram_id}: {sms_code[:2]}***{sms_code[-1:]}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º SMS –∫–æ–¥ –≤ –ë–î
        async for db in get_async_session():
            result = await db.execute(
                update(User)
                .where(User.telegram_id == telegram_id)
                .values(sms_code=sms_code)
            )
            await db.commit()
            
            if result.rowcount > 0:
                logger.info(f"‚úÖ SMS code saved to database for user {telegram_id}")
            else:
                logger.warning(f"‚ö†Ô∏è User {telegram_id} not found in database")
        
        return {"status": "success", "message": "SMS code received and saved"}
        
    except Exception as e:
        logger.error(f"‚ùå Error saving SMS code: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return {"status": "error", "message": str(e)}


async def perform_auth_interactions(driver, auth_config: dict, lsd_name: str, telegram_id: int, lsd_config=None) -> bool:
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –õ–°–î —á–µ—Ä–µ–∑ RPA steps"""
    try:
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import TimeoutException, NoSuchElementException
        
        wait = WebDriverWait(driver, 15)
        
        # –ü–æ–ª—É—á–∞–µ–º RPA steps –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        steps = auth_config.get('steps', [])
        if not steps:
            logger.info(f"‚ö†Ô∏è No RPA steps found for {lsd_name}, skipping automation")
            return True  # –ù–µ –æ—à–∏–±–∫–∞, –ø—Ä–æ—Å—Ç–æ –Ω–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–π
        
        logger.info(f"üîÑ Found {len(steps)} RPA steps for {lsd_name}")
        
        # –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è SMS –∫–æ–¥–∞ –º–µ–∂–¥—É —à–∞–≥–∞–º–∏
        received_sms_code = None
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_phone = await get_user_phone_number(telegram_id)
        if not user_phone:
            logger.error(f"‚ùå No phone number found for user {telegram_id}")
            return False
        
        logger.info(f"üìû Found user phone: {user_phone[:3]}***{user_phone[-4:]}")
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ RPA —à–∞–≥–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É
        for step in steps:
            step_id = step.get('id', '')
            action = step.get('action', '')
            
            logger.info(f"üîÑ Executing step: {step_id} ({action})")
            
            if action == 'navigate':
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º - –Ω–∞–≤–∏–≥–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞
                logger.debug(f"‚ö†Ô∏è Skipping navigation step {step_id}")
                continue
                
            elif action == 'hover':
                success = await execute_unified_hover_step(driver, wait, step, step_id)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ª–∏ —à–∞–≥
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required hover step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional hover step {step_id} failed, but continuing...")
                    
            elif action == 'click':
                success = await execute_unified_click_step(driver, wait, step, step_id)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ª–∏ —à–∞–≥
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required click step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional click step {step_id} failed, but continuing...")
                    
            elif action == 'scroll_into_view':
                success = await execute_scroll_step(driver, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Scroll step {step_id} failed, but continuing...")
                    
            elif action == 'wait_for':
                success = await execute_unified_wait_for_step(driver, wait, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Wait_for step {step_id} failed, but continuing...")
                    
            elif action == 'clear_and_wait':
                success = await execute_unified_clear_step(driver, wait, step, step_id)
                if not success:
                    logger.warning(f"‚ö†Ô∏è Clear step {step_id} failed, but continuing...")
                    
            elif action == 'type':
                # –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤ (–±—ã—Å—Ç—Ä—ã–π –≤–≤–æ–¥ —á–µ—Ä–µ–∑ send_keys)
                from unified_rpa_helpers import execute_unified_input_step
                success = await execute_unified_input_step(driver, wait, step, step_id, telegram_id)
                
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required input step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional input step {step_id} failed, but continuing...")
                    
            elif action == 'human_input':
                # –ü–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å —Ç—Ä–∏–≥–≥–µ—Ä–æ–º JS —Å–æ–±—ã—Ç–∏–π (–∏–º–∏—Ç–∞—Ü–∏—è —á–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞)
                from unified_rpa_helpers import execute_unified_human_input_step
                success = await execute_unified_human_input_step(driver, wait, step, step_id, telegram_id)
                
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required human_input step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional human_input step {step_id} failed, but continuing...")
                    
            elif action == 'request_sms_code':
                sms_code = await request_unified_sms_code(telegram_id, lsd_name, step)
                if not sms_code:
                    logger.error(f"‚ùå SMS request step failed")
                    return False
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º SMS –∫–æ–¥ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–∞—Ö
                received_sms_code = sms_code
                logger.info(f"‚úÖ SMS code stored for next steps")
                    
            elif action == 'type' and ('sms' in step_id.lower() or 'SMS' in step_id or 'code' in step_id.lower()):
                # –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ SMS —à–∞–≥–æ–≤: enter_sms, enter_sms_code, enter_code –∏ —Ç.–¥.
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π SMS –∫–æ–¥
                if not received_sms_code:
                    logger.error(f"‚ùå No SMS code available from previous step")
                    return False
                
                success = await execute_unified_sms_input_step(driver, wait, step, step_id, received_sms_code)
                if not success:
                    logger.error(f"‚ùå SMS input step failed")
                    return False
                    
            elif action == 'switch_to_default_content':
                # –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É –∫–æ–Ω—Ç–µ–Ω—Ç—É –∏–∑ iframe
                from unified_rpa_helpers import execute_unified_iframe_back_step
                success = await execute_unified_iframe_back_step(driver, wait, step, step_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required iframe back step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional iframe back step {step_id} failed, but continuing...")
                    
            elif action == 'switch_to_frame':
                # –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ iframe
                from unified_rpa_helpers import execute_unified_iframe_step
                success = await execute_unified_iframe_step(driver, wait, step, step_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required iframe switch step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional iframe switch step {step_id} failed, but continuing...")
                    
            elif action == 'extract_qr_link':
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ QR –∫–æ–¥–æ–≤ - –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                success = await execute_unified_qr_extraction_step(driver, step, step_id, telegram_id)
                if not success:
                    logger.error(f"‚ùå QR extraction step failed")
                    return False
                    
            elif action == 'wait_for_navigation':
                # –û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ—Å–ª–µ QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                url_contains = step.get('url_contains')
                timeout = step.get('timeout', 300000)  # 5 –º–∏–Ω—É—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                check_interval = step.get('check_interval', 3)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
                exclude_urls = step.get('exclude_urls', [])
                
                logger.info(f"‚è±Ô∏è Waiting for navigation to URL containing '{url_contains}' (timeout: {timeout/1000}s)")
                
                import time
                start_time = time.time()
                initial_url = driver.current_url
                
                logger.info(f"üìã Starting URL: {initial_url}")
                logger.info(f"üîç Looking for signs of successful authorization (not just URL change)...")
                
                # –î–ª—è QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ü–û–Ø–í–õ–ï–ù–ò–ï —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                # –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±–∏—Ä–∞–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä –∫–æ—Ä–∑–∏–Ω—ã - –æ–Ω –µ—Å—Ç—å –∏ —É –Ω–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!
                auth_success_selectors = [
                    # –¢–û–õ–¨–ö–û —ç–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ—Ñ–∏–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//a[@target='_self' and @href='/my/main']",  # –°–∞–º—ã–π —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π
                    "//a[contains(@href, '/my/main')]",
                    "//a[contains(@href, '/my')]", 
                    # –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ë–ï–ó –∫–æ—Ä–∑–∏–Ω—ã!)
                    "//div[contains(@class, 'user') or contains(@class, 'profile') or contains(@class, 'account')]",
                    # –ê–≤–∞—Ç–∞—Ä –∏–ª–∏ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//div[contains(@class, 'avatar') or contains(@class, 'username')]",
                    # –û–±—â–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    "//*[contains(@class, 'authenticated') or contains(@data-testid, 'user')]"
                ]
                
                while (time.time() - start_time) * 1000 < timeout:
                    try:
                        current_url = driver.current_url
                        elapsed_seconds = time.time() - start_time
                        
                        # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                        if int(elapsed_seconds) % 30 == 0 and elapsed_seconds > 0:
                            logger.info(f"‚è≥ Waiting for user to authorize via QR... {elapsed_seconds:.0f}s elapsed")
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                        found_auth_element = False
                        for auth_selector in auth_success_selectors:
                            try:
                                from selenium.webdriver.common.by import By
                                elements = driver.find_elements(By.XPATH, auth_selector)
                                visible_elements = [el for el in elements if el.is_displayed()]
                                
                                if visible_elements:
                                    logger.info(f"‚úÖ Found auth element: {auth_selector}")
                                    found_auth_element = True
                                    break
                                    
                            except Exception as e:
                                continue
                        
                        if found_auth_element:
                            logger.info(f"‚úÖ Navigation successful! User authorized via QR after {elapsed_seconds:.1f}s")
                            logger.info(f"üîó Final URL: {current_url}")
                            success = True
                            break
                        
                        # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
                        await asyncio.sleep(check_interval)
                        
                    except Exception as nav_error:
                        logger.debug(f"‚ö†Ô∏è Navigation check error: {nav_error}")
                        await asyncio.sleep(check_interval)
                        continue
                        
                else:
                    # –¢–∞–π–º–∞—É—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç
                    elapsed_minutes = (time.time() - start_time) / 60
                    current_url = driver.current_url
                    logger.warning(f"‚è∞ QR authorization timeout after {elapsed_minutes:.1f}m. Current URL: {current_url}")
                    
                    # –î–ª—è QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Ç–∞–π–º–∞—É—Ç –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                    if step_id == 'wait_for_auth_success':
                        logger.info("‚ö†Ô∏è QR auth timeout - user did not complete authorization in time")
                        success = False  # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
                    else:
                        logger.error(f"‚ùå Navigation timeout for step {step_id}")
                        return False
                    
            elif action == 'wait_for' and step.get('success'):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                success = await execute_unified_auth_verification(driver, step, wait)
                if success:
                    logger.info(f"‚úÖ Authentication successful!")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è Auth verification failed, but continuing...")
                    
            elif action == 'save_address':
                # –ù–æ–≤—ã–π action: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –¥–æ—Å—Ç–∞–≤–∫–∏
                from unified_rpa_helpers import execute_save_address_step
                # –ü–µ—Ä–µ–¥–∞–µ–º lsd_config.id –≤ step –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –Ω—É–∂–Ω—É—é —Å–µ—Å—Å–∏—é
                step_with_lsd_id = step.copy()
                step_with_lsd_id['lsd_config_id'] = lsd_config.id if hasattr(lsd_config, 'id') else None
                
                success = await execute_save_address_step(driver, step_with_lsd_id, step_id, telegram_id)
                is_optional = step.get('optional', False)
                if not success and not is_optional:
                    logger.error(f"‚ùå Required save_address step {step_id} failed")
                    return False
                elif not success and is_optional:
                    logger.warning(f"‚ö†Ô∏è Optional save_address step {step_id} failed, but continuing...")
                else:
                    logger.info(f"‚úÖ Address saved successfully for step {step_id}")
                    
            else:
                logger.debug(f"‚ö†Ô∏è Skipping step {step_id} ({action}) - not implemented")
                continue
            
            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —à–∞–≥–∞–º–∏
            step_pause = step.get('wait_after', 1000) / 1000
            if step_pause > 0:
                logger.info(f"‚è≥ Pausing {step_pause}s after step {step_id}...")
                await asyncio.sleep(step_pause)
        
        logger.info(f"‚úÖ Completed all RPA steps for {lsd_name}")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error in unified auth interactions: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def get_user_phone(telegram_id: int) -> Optional[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()
            
            if user and user.phone:
                logger.info(f"‚úÖ Found phone for user {telegram_id}: {user.phone[:3]}***{user.phone[-4:]}")
                return user.phone
            else:
                logger.error(f"‚ùå No phone found for user {telegram_id}")
                return None
                
    except Exception as e:
        logger.error(f"‚ùå Error getting user phone: {e}")
        return None




# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Ñ–ª–æ—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
async def execute_click_step(driver, wait, step: dict, step_id: str) -> bool:
    """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–ª–∏–∫–∞ –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for click step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
            else:
                element = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
            
            driver.execute_script("arguments[0].scrollIntoView(true);", element)
            await asyncio.sleep(0.5)
            element.click()
            
            logger.info(f"‚úÖ Successfully clicked element with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Selector failed: {selector}")
            continue
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error with selector '{selector}': {e}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not click any selector for step {step_id}")
    return False

async def execute_wait_for_step(driver, wait, step: dict, step_id: str) -> bool:
    """–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for wait_for step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            logger.info(f"‚úÖ Found element with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Wait selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not find any selector for wait_for step {step_id}")
    return False

async def execute_clear_step(driver, wait, step: dict, step_id: str) -> bool:
    """–û—á–∏—Å—Ç–∫–∞ –ø–æ–ª—è –≤–≤–æ–¥–∞"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for clear_and_wait step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            element.clear()
            logger.info(f"‚úÖ Cleared field with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Clear selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not clear field for step {step_id}")
    return False

async def execute_phone_input_step(driver, wait, step: dict, step_id: str, telegram_id: int) -> bool:
    """–í–≤–æ–¥ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    phone_number = await get_user_phone_number(telegram_id)
    if not phone_number:
        logger.error(f"‚ùå No phone number found for user {telegram_id}")
        return False
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –Ω–æ–º–µ—Ä —Å–æ–≥–ª–∞—Å–Ω–æ –∫–æ–Ω—Ñ–∏–≥—É
    phone_value = step.get('value', '{phone_without_7}')
    if '{phone_without_7}' in phone_value:
        # –£–±–∏—Ä–∞–µ–º +7 –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º
        clean_phone = phone_number.replace('+7', '').replace('+', '')
        formatted_phone = phone_value.replace('{phone_without_7}', clean_phone)
    else:
        formatted_phone = phone_number
    
    logger.info(f"üì± Entering phone number: {formatted_phone[:3]}***{formatted_phone[-4:]}")
    
    # –í–≤–æ–¥–∏–º –Ω–æ–º–µ—Ä
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for phone input step {step_id}")
        return False
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    for selector in selectors:
        try:
            if selector.startswith('//'):
                element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
            else:
                element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            
            element.clear()
            element.send_keys(formatted_phone)
            logger.info(f"‚úÖ Successfully entered phone number with selector: {selector}")
            return True
            
        except (TimeoutException, NoSuchElementException):
            logger.debug(f"‚ö†Ô∏è Phone input selector failed: {selector}")
            continue
    
    logger.warning(f"‚ö†Ô∏è Could not enter phone number for step {step_id}")
    return False

async def get_user_phone_number(telegram_id: int) -> Optional[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            from shared.database.models import User
            result = await db.execute(
                select(User.phone).where(User.telegram_id == telegram_id)
            )
            phone = result.scalar_one_or_none()
            
            if phone:
                logger.info(f"üì± Found phone number for user {telegram_id}: {phone[:3]}***{phone[-4:]}")
                return phone
            else:
                logger.error(f"‚ùå No phone number found for user {telegram_id}")
                return None
            
    except Exception as e:
        logger.error(f"‚ùå Database error getting phone number: {e}")
        return None



async def execute_sms_input_step(driver, wait, step: dict, step_id: str, sms_code: str) -> bool:
    """–í–≤–æ–¥ SMS –∫–æ–¥–∞ –ø–æ—Å–∏–º–≤–æ–ª—å–Ω–æ"""
    selectors = step.get('selectors', [])
    if not selectors:
        logger.warning(f"‚ö†Ô∏è No selectors for SMS input step {step_id}")
        return False
    
    logger.info(f"üì± Entering SMS code: {sms_code}")
    
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –ø–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥
    individual_inputs = step.get('individual_inputs', False)
    
    if individual_inputs:
        # –ü–æ—Å–∏–º–≤–æ–ª—å–Ω—ã–π –≤–≤–æ–¥ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        logger.info(f"üì± Using individual character input for SMS code")
        
        for i, char in enumerate(sms_code):
            for selector in selectors:
                try:
                    # –ò—â–µ–º –ø–æ–ª–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                    if selector.startswith('//'):
                        elements = driver.find_elements(By.XPATH, selector)
                    else:
                        elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    
                    if i < len(elements):
                        element = elements[i]
                        element.clear()
                        element.send_keys(char)
                        await asyncio.sleep(0.3)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏
                        logger.debug(f"‚úÖ Entered character {i+1}/{len(sms_code)}")
                        break
                        
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Error entering character {char}: {e}")
                    continue
        
        logger.info(f"‚úÖ Successfully entered SMS code character by character")
        return True
    
    else:
        # –û–±—ã—á–Ω—ã–π –≤–≤–æ–¥ –≤ –æ–¥–Ω–æ –ø–æ–ª–µ
        for selector in selectors:
            try:
                if selector.startswith('//'):
                    element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                else:
                    element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                
                element.clear()
                element.send_keys(sms_code)
                logger.info(f"‚úÖ Successfully entered SMS code with selector: {selector}")
                return True
                
            except (TimeoutException, NoSuchElementException):
                logger.debug(f"‚ö†Ô∏è SMS input selector failed: {selector}")
                continue
    
    logger.warning(f"‚ö†Ô∏è Could not enter SMS code for step {step_id}")
    return False

async def verify_auth_success(driver, step: dict, wait) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        selectors = step.get('selectors', [])
        if not selectors:
            logger.warning(f"‚ö†Ô∏è No selectors for auth verification")
            return False
        
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import TimeoutException
        
        for selector in selectors:
            try:
                if selector.startswith('//'):
                    element = wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                else:
                    element = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                
                logger.info(f"‚úÖ Auth verification successful with selector: {selector}")
                return True
                
            except TimeoutException:
                logger.debug(f"‚ö†Ô∏è Auth verification selector failed: {selector}")
                continue
        
        logger.warning(f"‚ö†Ô∏è Could not verify auth success")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Error in auth verification: {e}")
        return False

# execute_auth_steps() –£–î–ê–õ–ï–ù–ê - –≤—Å–µ –õ–°–î –∏—Å–ø–æ–ª—å–∑—É—é—Ç perform_auth_interactions() —Å unified_rpa_helpers

async def execute_selenium_auth_flow(telegram_id: int, lsd_config: LSDConfig, auth_config: dict):
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è CDP –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –õ–°–î - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –°–∞–º–æ–∫–∞—Ç, –∏ –í–∫—É—Å–í–∏–ª–ª"""
    logger.info(f"üîÑ Starting unified CDP auth flow for {lsd_config.display_name} (user: {telegram_id})")
    
    cdp_manager = None
    
    try:
        # –®–ê–ì 1: –°–æ–∑–¥–∞–µ–º –ü–£–°–¢–£–Æ —Å–µ—Å—Å–∏—é –î–û –Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        from session_initializer import create_initial_session, update_session_with_cookies
        
        session_created = await create_initial_session(
            telegram_id=telegram_id,
            lsd_config_id=lsd_config.id,
            lsd_name=lsd_config.name
        )
        
        if not session_created:
            logger.error(f"‚ùå Failed to create initial session")
            await notify_user_auth_error(telegram_id, lsd_config.display_name, "Failed to initialize session")
            return
        
        logger.info(f"‚úÖ Initial session created/verified")
        
        # –®–ê–ì 2: –°–æ–∑–¥–∞–µ–º –±—Ä–∞—É–∑–µ—Ä (—Å CDP –∏–ª–∏ –±–µ–∑ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ñ–∏–≥–∞)
        cdp_enabled = auth_config.get('cdp_enabled', True)  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é CDP –≤–∫–ª—é—á–µ–Ω
        
        if cdp_enabled:
            logger.info(f"üîß Using CDP browser (cdp_enabled=true in config)")
            logger.info(f"üîß Initializing CDP manager for auth...")
            cdp_manager = CDPCookieManager()
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä —Å CDP
            driver = cdp_manager.setup_browser_with_cdp()
            logger.info(f"‚úÖ CDP browser created for auth")
        else:
            logger.info(f"üöó Using SIMPLE browser WITHOUT CDP (cdp_enabled=false in config)")
            logger.info(f"üéØ Strategy: Maximum simplicity for bypassing strict antibot protection")
            
            from simple_browser_manager import SimpleUndetectedBrowser
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –º–æ–±–∏–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
            mobile_mode = lsd_config.rpa_config.get('mobile_mode', False) if lsd_config.rpa_config else False
            logger.info(f"üì± Mobile mode: {'ENABLED' if mobile_mode else 'DISABLED'}")
            driver = SimpleUndetectedBrowser.create_simple_browser(
                headless=settings.rpa_headless,
                mobile_mode=mobile_mode
            )
            cdp_manager = None  # –ù–µ—Ç CDP –º–µ–Ω–µ–¥–∂–µ—Ä–∞
            logger.info(f"‚úÖ SIMPLE browser created for auth (NO CDP = NO detection)")
        
        # –®–ê–ì 3: –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ auth_url –≤ –∫–æ–Ω—Ñ–∏–≥–µ, –µ—Å–ª–∏ –Ω–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º base_url
        auth_url = auth_config.get('auth_url') or lsd_config.base_url
        
        if auth_config.get('auth_url'):
            logger.info(f"üîê Using auth_url from config: {auth_url}")
        else:
            logger.info(f"üîê Using base_url as auth_url (fallback): {auth_url}")
        
        logger.info(f"üîê Navigating to auth page: {auth_url}")
        
        # –ë–´–°–¢–†–ê–Ø –ù–ê–í–ò–ì–ê–¶–ò–Ø: –Ω–µ –∂–¥–µ–º –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏, –∞ –∏—â–µ–º –Ω—É–∂–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
        # –ü–æ–ª—É—á–∞–µ–º wait_for —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        steps = auth_config.get('steps', [])
        first_step = steps[0] if steps else None
        wait_for_selectors = []
        if first_step and first_step.get('action') == 'navigate':
            wait_for_config = first_step.get('wait_for', {})
            wait_for_selectors = wait_for_config.get('selectors', [])
            wait_for_timeout = first_step.get('timeout', 15000) / 1000
        
        if wait_for_selectors:
            logger.info(f"üöÄ Fast navigation with wait_for: {len(wait_for_selectors)} selectors, timeout={wait_for_timeout}s")
            
            # –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ë–ï–ó –û–ñ–ò–î–ê–ù–ò–Ø
            import time
            from selenium.webdriver.common.by import By
            
            driver.get(auth_url)
            start_time = time.time()
            
            # –°—Ä–∞–∑—É –ø–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—â–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
            selector_found = False
            while (time.time() - start_time) < wait_for_timeout:
                for selector in wait_for_selectors:
                    try:
                        if selector.startswith('//'):
                            elements = driver.find_elements(By.XPATH, selector)
                        else:
                            elements = driver.find_elements(By.CSS_SELECTOR, selector)
                        
                        for element in elements:
                            if element.is_displayed():
                                elapsed = time.time() - start_time
                                logger.info(f"‚úÖ Found selector after {elapsed:.1f}s: {selector}")
                                selector_found = True
                                break
                        
                        if selector_found:
                            break
                    except Exception:
                        continue
                
                if selector_found:
                    break
                
                await asyncio.sleep(0.1)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 100–º—Å
            
            if not selector_found:
                elapsed = time.time() - start_time
                logger.warning(f"‚ö†Ô∏è No wait_for selectors found after {elapsed:.1f}s, but continuing...")
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º HTML –¥–∞–º–ø –ø—Ä–∏ —Ç–∞–π–º–∞—É—Ç–µ wait_for –≤ navigate
                from unified_rpa_helpers import save_page_html_dump
                await save_page_html_dump(driver, "navigate_wait_for", "timeout")
        else:
            # –û–±—ã—á–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –±–µ–∑ wait_for
            logger.info(f"üåê Standard navigation (no wait_for selectors)")
            driver.get(auth_url)
        
        # –ü–†–ò–ú–ï–ù–Ø–ï–ú ANTIBOT –°–¢–†–ê–¢–ï–ì–ò–ò –°–†–ê–ó–£ –ü–û–°–õ–ï –ù–ê–í–ò–ì–ê–¶–ò–ò
        logger.info(f"üõ°Ô∏è Applying antibot strategies for {lsd_config.display_name}...")
        try:
            from selenium_antibot_strategies import apply_antibot_for_lsd
            antibot_success = apply_antibot_for_lsd(driver, lsd_config.name)
            if antibot_success:
                logger.info(f"‚úÖ Antibot strategies applied successfully")
            else:
                logger.warning(f"‚ö†Ô∏è Antibot strategies partially failed, but continuing...")
        except Exception as antibot_error:
            logger.warning(f"‚ö†Ô∏è Failed to apply antibot strategies: {antibot_error}, but continuing...")
        
        # –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê RPA –®–ê–ì–û–í
        logger.info(f"ü§ñ Starting unified auth interactions...")
        success = await perform_auth_interactions(driver, auth_config, lsd_config.display_name, telegram_id, lsd_config)
        
        if success:
            logger.info(f"‚úÖ Unified auth interactions completed successfully")
            
            # –®–ê–ì 4: –ü–æ–ª—É—á–∞–µ–º –∫—É–∫–∏ –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
            if cdp_manager:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º CDP –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è cookies
                cookies = cdp_manager.extract_cookies()
                logger.info(f"üç™ Extracted {len(cookies)} cookies via CDP")
            else:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π Selenium API
                from simple_browser_manager import SimpleUndetectedBrowser
                cookies = SimpleUndetectedBrowser.extract_cookies(driver)
                logger.info(f"üç™ Extracted {len(cookies)} cookies via Selenium API")
            
            if cookies:
                # –®–ê–ì 5: –û–±–Ω–æ–≤–ª—è–µ–º –°–£–©–ï–°–¢–í–£–Æ–©–£–Æ —Å–µ—Å—Å–∏—é –∫—É–∫–∞–º–∏ (–≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π)
                from session_initializer import update_session_with_cookies
                
                saved = await update_session_with_cookies(telegram_id, lsd_config.id, cookies)
                
                if saved:
                    logger.info(f"‚úÖ Cookies saved successfully to existing session")
                    logger.info(f"üì£ Calling notify_user_auth_success for user {telegram_id}...")
                    await notify_user_auth_success(telegram_id, lsd_config.display_name, len(cookies))
                    logger.info(f"‚úÖ notify_user_auth_success completed")
                else:
                    logger.error(f"‚ùå Failed to update session with cookies")
                    await notify_user_auth_error(telegram_id, lsd_config.display_name, "Failed to save cookies")
            else:
                logger.error(f"‚ùå No cookies extracted after auth")
                await notify_user_auth_error(telegram_id, lsd_config.display_name, "No cookies found")
        else:
            logger.error(f"‚ùå Unified auth interactions failed")
            await notify_user_auth_error(telegram_id, lsd_config.display_name, "Auth interactions failed")
            
    except Exception as e:
        logger.error(f"‚ùå Error in unified CDP auth flow: {e}")
        import traceback
        logger.error(traceback.format_exc())
        await notify_user_auth_error(telegram_id, lsd_config.display_name, str(e))
        
    finally:
        # –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        if cdp_manager:
            try:
                logger.info(f"üßπ Cleaning up CDP browser...")
                cdp_manager.cleanup()
                logger.info(f"‚úÖ CDP cleanup completed")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up CDP: {cleanup_error}")
        elif 'driver' in locals() and driver:
            try:
                logger.info(f"üßπ Cleaning up SIMPLE browser...")
                from simple_browser_manager import SimpleUndetectedBrowser
                SimpleUndetectedBrowser.close_browser(driver)
                logger.info(f"‚úÖ SIMPLE browser cleanup completed")
            except Exception as cleanup_error:
                logger.error(f"‚ùå Error cleaning up simple browser: {cleanup_error}")
# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def notify_user_about_auth_start(telegram_id: int, display_name: str, base_url: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": base_url,
                    "action": "auth_start",
                    "message": f"üîê –û—Ç–∫—Ä—ã—Ç –±—Ä–∞—É–∑–µ—Ä –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}. –ü—Ä–æ–π–¥–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ –æ—Ç–∫—Ä—ã–≤—à–µ–º—Å—è –æ–∫–Ω–µ –±—Ä–∞—É–∑–µ—Ä–∞."
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth start: {e}")

async def notify_user_auth_progress(telegram_id: int, elapsed: int, total: int):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        minutes_elapsed = elapsed // 60
        minutes_total = total // 60
        
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚è≥ –ü—Ä–æ—à–ª–æ {minutes_elapsed}/{minutes_total} –º–∏–Ω. –û–∂–∏–¥–∞—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...",
                    "action": "auth_progress",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth progress: {e}")

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è message_id —Å–æ–æ–±—â–µ–Ω–∏–π —Å QR —Å—Å—ã–ª–∫–∞–º–∏
qr_message_ids: dict[int, int] = {}

async def save_qr_message_id(telegram_id: int, message_id: int):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    logger.info(f"üíæ Saving QR message_id {message_id} for user {telegram_id}")
    await _save_qr_message_id_to_db(telegram_id, message_id)
    logger.info(f"‚úÖ QR message_id saved to DB")

async def _save_qr_message_id_to_db(telegram_id: int, message_id: int):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±–∞–∑—É"""
    try:
        async for db in get_async_session():
            await db.execute(
                update(User)
                .where(User.telegram_id == telegram_id)
                .values(sms_code=str(message_id))  # –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º sms_code
            )
            await db.commit()
            break
    except Exception as e:
        logger.error(f"‚ùå Error saving message_id to DB: {e}")

async def get_qr_message_id(telegram_id: int) -> int | None:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π –∏–∑ –±–∞–∑—ã"""
    try:
        async for db in get_async_session():
            result = await db.execute(
                select(User.sms_code).where(User.telegram_id == telegram_id)
            )
            sms_code = result.scalar_one_or_none()
            
            if sms_code and sms_code.isdigit():
                message_id = int(sms_code)
                # –û—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è
                await db.execute(
                    update(User)
                    .where(User.telegram_id == telegram_id)
                    .values(sms_code=None)
                )
                await db.commit()
                return message_id
            break
    except Exception as e:
        logger.error(f"‚ùå Error getting message_id from DB: {e}")
    return None

async def notify_user_auth_success(telegram_id: int, display_name: str, cookies_count: int):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        
        # –ü–æ–ª—É—á–∞–µ–º message_id —Å–æ–æ–±—â–µ–Ω–∏—è —Å QR —Å—Å—ã–ª–∫–æ–π
        qr_message_id = await get_qr_message_id(telegram_id)
        logger.info(f"üéØ Retrieved qr_message_id for user {telegram_id}: {qr_message_id}")
        
        payload = {
            "telegram_id": telegram_id,
            "message": f"‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ {display_name} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!",
            "action": "auth_complete",
            "qr_message_id": qr_message_id,  # –î–æ–±–∞–≤–ª—è–µ–º message_id
            "result": {
                "lsd_name": display_name.lower().replace(" ", "_"),
                "display_name": display_name,
                "cookies_count": cookies_count
            }
        }
        
        logger.info(f"üì§ Sending auth success to telegram-bot: {payload}")
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8001/rpa/auth-success",
                json=payload,
                timeout=5.0
            )
            
            logger.info(f"‚úÖ Auth success notification sent, response: {response.status_code}")
            
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth success: {e}")
        import traceback
        logger.error(traceback.format_exc())

async def notify_user_auth_timeout(telegram_id: int, display_name: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ç–∞–π–º–∞—É—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚ùå –¢–∞–π–º–∞—É—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                    "action": "auth_timeout",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth timeout: {e}")

async def notify_user_auth_error(telegram_id: int, display_name: str, error_message: str):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            await client.post(
                "http://localhost:8001/rpa/qr-code-extracted",
                json={
                    "telegram_id": telegram_id,
                    "qr_link": f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ {display_name}: {error_message}",
                    "action": "auth_error",
                    "message": ""
                },
                timeout=5.0
            )
    except Exception as e:
        logger.error(f"‚ùå Error notifying user about auth error: {e}")

async def save_user_cookies_to_db(telegram_id: int, lsd_config_id: int, cookies: list) -> bool:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—É–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async for db in get_async_session():
            # –ü–æ–ª—É—á–∞–µ–º –∏–º—è –∏ –∞–¥—Ä–µ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_result = await db.execute(
                select(User.first_name, User.last_name, User.address).where(User.telegram_id == telegram_id)
            )
            user_data = user_result.first()
            
            if user_data:
                first_name, last_name, address = user_data
                user_name = f"{first_name or ''} {last_name or ''}".strip() or f"User {telegram_id}"
            else:
                user_name = f"User {telegram_id}"
                address = None
            
            logger.info(f"üë§ User name: {user_name}")
            if address:
                logger.info(f"üè† User address: {address[:50]}...")
            
            # –ü–æ–ª—É—á–∞–µ–º lsd_name –ø–æ lsd_config_id
            lsd_result = await db.execute(
                select(LSDConfig.name).where(LSDConfig.id == lsd_config_id)
            )
            lsd_name = lsd_result.scalar_one_or_none()
            
            if not lsd_name:
                logger.error(f"‚ùå Could not find lsd_name for lsd_config_id={lsd_config_id}")
                lsd_name = f"lsd_{lsd_config_id}"
            
            logger.info(f"üè™ LSD name: {lsd_name}")
            
            # –ù–∞—Ö–æ–¥–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
            result = await db.execute(
                select(UserSession).where(
                    UserSession.telegram_id == telegram_id,
                    UserSession.lsd_config_id == lsd_config_id
                )
            )
            session = result.scalar_one_or_none()
            
            if session:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–µ—Å—Å–∏—é
                from datetime import datetime, timedelta
                session.data = {'cookies': cookies}
                session.expires_at = datetime.now() + timedelta(days=30)
                session.user_name = user_name
                session.lsd_name = lsd_name
                session.default_delivery_address = address  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞–¥—Ä–µ—Å
                logger.info(f"‚ôæÔ∏è Updated session {session.id}: user_name='{user_name}', lsd_name='{lsd_name}', address='{address[:30] if address else None}...'")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
                from datetime import datetime, timedelta
                expires_at = datetime.now() + timedelta(days=30)
                
                new_session = UserSession(
                    telegram_id=telegram_id,
                    lsd_config_id=lsd_config_id,
                    data={'cookies': cookies},
                    expires_at=expires_at,
                    user_name=user_name,
                    lsd_name=lsd_name,
                    default_delivery_address=address  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞–¥—Ä–µ—Å
                )
                db.add(new_session)
                logger.info(f"‚ûï Created session: user_name='{user_name}', lsd_name='{lsd_name}', address='{address[:30] if address else None}...'")
            
            await db.commit()
            logger.info(f"üíæ Successfully saved {len(cookies)} cookies to database")
            return True
            
    except Exception as e:
        logger.error(f"‚ùå Database error saving cookies: {e}")
        return False

# –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
async def execute_rpa_flow(session_id: str, telegram_id: int, display_name: str, lsd_name: str):
    """–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è RPA —Ñ–ª–æ—É"""
    logger.info(f"üé≠ Executing RPA flow for session {session_id}")
    # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è RPA –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    pass

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8004)
